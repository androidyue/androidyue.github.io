<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[技术小黑屋]]></title>
  <link href="http://droidyue.com/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2014-12-19T23:28:44+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[应用认领那些事]]></title>
    <link href="http://droidyue.com/blog/2014/12/14/android-yingyong-renling/"/>
    <updated>2014-12-14T19:35:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/12/14/android-yingyong-renling</id>
    <content type="html"><![CDATA[<p>最近公司的一款产品提交国内市场，发现有些国内市场提示需要进行应用认领。原因就是别人（或者市场抓取）已经在我们之前将这个应用提交到了该市场。认领成功后，这个应用就重回你的怀抱了，其实认领很简单，这里讲到的自然是对未签名的包进行签名。由于这样的操作细小琐屑，这样更需要记录一下，免得以后麻烦。</p>

<!--more-->


<h2>如何认领</h2>

<ul>
<li>一般的就是市场提供一个未签名的apk包，认领方进行签名后，上传即可认领成功。</li>
<li>另一种就是提供公司证明，这个我们不讲，也没什么可以讲。</li>
</ul>


<p>通常情况下认领都会有对一个未签名的apk包签名认证这种方式，因为签名是软件发布商所独有的，通过对比测试需认领的包的签名和刚签过名的apk包是否一致，如果一致就认领成功，否则失败。</p>

<h2>对未签名包签名</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore your_keystore  -storepass your_storepass -keypass your_keypass -signedjar path_of_signed_apk  path_of_unsigned_apk your_alias
</span></code></pre></td></tr></table></div></figure>


<h3>需要替换的值</h3>

<ul>
<li>your_key_store keystore文件路径</li>
<li>your_storepass   store密码</li>
<li>your_keypass    key密码</li>
<li>path_of_signed_apk 签名后apk保存的目录</li>
<li>path_of_unsigned_apk 待签名的apk包</li>
<li>your_alias keystore中的别名</li>
</ul>


<p>注意上面的签名算法sigalg 使用SHA1withRSA或者MD5withRSA都可以。</p>

<h2>验证签名</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>jarsigner -verify -certs -verbose your_app.apk
</span></code></pre></td></tr></table></div></figure>


<p>比如我们验证百度金融的apk，会得到类似这样的结果</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>19:23 <span class="nv">$ </span>jarsigner -verify -certs -verbose BaiduFinance.apk | more
</span><span class='line'>
</span><span class='line'>s      61679 Fri Nov 14 19:50:16 CST 2014 META-INF/MANIFEST.MF
</span><span class='line'>
</span><span class='line'>      X.509, <span class="nv">CN</span><span class="o">=</span>Baidu, <span class="nv">OU</span><span class="o">=</span>Baidu Inc., <span class="nv">O</span><span class="o">=</span>Baidu Inc., <span class="nv">L</span><span class="o">=</span>Beijing, <span class="nv">ST</span><span class="o">=</span>Beijing, <span class="nv">C</span><span class="o">=</span>CN
</span><span class='line'>      <span class="o">[</span>certificate is valid from 12/6/13 10:19 AM to 11/24/63 10:19 AM<span class="o">]</span>
</span><span class='line'>      <span class="o">[</span>CertPath not validated: Path does not chain with any of the trust anchors<span class="o">]</span>
</span><span class='line'>
</span><span class='line'>       61800 Fri Nov 14 19:50:16 CST 2014 META-INF/MCO_BAID.SF
</span><span class='line'>         936 Fri Nov 14 19:50:16 CST 2014 META-INF/MCO_BAID.RSA
</span><span class='line'>sm      2304 Fri Nov 14 19:49:32 CST 2014 assets/mean/data_mean_24_bank_card
</span></code></pre></td></tr></table></div></figure>


<h2>疑难问题</h2>

<h3>No -tsa or -tsacert is provided and this jar is not timestamped</h3>

<p>在签名时加入下面的选项</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>jarsigner -tsa http://timestamp.digicert.com
</span></code></pre></td></tr></table></div></figure>


<h3>Windows无法打开文件</h3>

<p>有些Windows工具无法打开签名后的apk，如果你的签名没有错误，并且验证过，这种情况请忽略。</p>

<h3>签名认领失败</h3>

<p>如果签名认领失败的话，请检查目前线上的包是否进行了二次打包被别人篡改了签名，如果是的话，需要进行商务上的沟通来解决了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的substring真的会引起内存泄露么？]]></title>
    <link href="http://droidyue.com/blog/2014/12/14/substring-memory-issue-in-java/"/>
    <updated>2014-12-14T12:02:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/12/14/substring-memory-issue-in-java</id>
    <content type="html"><![CDATA[<p>在Java中开发，String是我们开发程序可以说必须要使用的类型，String有一个substring方法用来截取字符串，我们想必也常常使用。但是你知道么，关于Java 6中的substring是否会引起内存泄露，在国外的论坛和社区有着一些讨论，以至于Java官方已经将其标记成bug，并且为此Java 7 还重新进行了实现。读到这里可能你的问题就来了，substring怎么会引起内存泄露呢？那么我们就带着问题，走进小黑屋，看看substring有没有内存泄露，又是怎么导致所谓的内存泄露。</p>

<!--more-->


<h2>基本介绍</h2>

<p>substring方法提供两种重载，第一种为只接受开始截取位置一个参数的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">String</span> <span class="nf">substring</span><span class="o">(</span><span class="kt">int</span> <span class="n">beginIndex</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>比如我们使用上面的方法，<code>"unhappy".substring(2)</code> 返回结果 <code>"happy"</code></p>

<p>另一种重载就是接受一个开始截取位置和一个结束截取位置的参数的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">String</span> <span class="nf">substring</span><span class="o">(</span><span class="kt">int</span> <span class="n">beginIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">endIndex</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用这个方法，<code>"smiles".substring(1, 5)</code> 返回结果 <code>"mile"</code></p>

<p>通过这个介绍我们基本了解了substring的作用，这样便于我们理解下面的内容。</p>

<h2>准备工作</h2>

<p>因为这个问题出现的情况在Java 6，如果你的Java版本号不是Java 6 需要调整一下。</p>

<h3>终端调整（适用于Mac系统）</h3>

<p>查看java版本号</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>13:03 <span class="nv">$ </span>java -version
</span><span class='line'>java version <span class="s2">&quot;1.8.0_25&quot;</span>
</span><span class='line'>Java<span class="o">(</span>TM<span class="o">)</span> SE Runtime Environment <span class="o">(</span>build 1.8.0_25-b17<span class="o">)</span>
</span><span class='line'>Java HotSpot<span class="o">(</span>TM<span class="o">)</span> 64-Bit Server VM <span class="o">(</span>build 25.25-b02, mixed mode<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>切换到1.6</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">export</span> <span class="n">JAVA_HOME</span><span class="o">=</span><span class="n">$</span><span class="o">(/</span><span class="n">usr</span><span class="o">/</span><span class="n">libexec</span><span class="o">/</span><span class="n">java_home</span> <span class="o">-</span><span class="n">v</span> <span class="mf">1.6</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ubuntu使用<code>alternatives --config java</code>，Fedora上面使用<code>alternatives --config java</code>。</p>

<p>如果你使用Eclipse，可以选择工程，右击，选择Properties（属性）&mdash; Java Compiler（Java编译器）进行特殊指定。</p>

<h2>问题重现</h2>

<p>这里贴一下java官方bug里用到的重现问题的代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestGC</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">largeString</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">100000</span><span class="o">]);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">String</span> <span class="nf">getString</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">largeString</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">ArrayList</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">ArrayList</span><span class="o">();</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">TestGC</span> <span class="n">gc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestGC</span><span class="o">();</span>
</span><span class='line'>            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">gc</span><span class="o">.</span><span class="na">getString</span><span class="o">());</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然而上面的代码，只要使用Java 6 （Java 7和8 都不会抛出异常）运行一下就会报java.lang.OutOfMemoryError: Java heap space的异常，这说明没有足够的堆内存供我们创建对象，JVM选择了抛出异常操作。</p>

<p>于是有人会说，是因为你每个循环中创建了一个TestGC对象，虽然我们加入ArrayList只是两个字符的字符串，但是这个对象中又存储largeString这么大的对象，这样必然会造成OOM的。</p>

<p>然而，其实你说的不对。比如我们看一下这样的代码,我们只修改getString方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestGC</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">largeString</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">100000</span><span class="o">]);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">String</span> <span class="nf">getString</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//return this.largeString.substring(0,2);</span>
</span><span class='line'>      <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="s">&quot;ab&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">ArrayList</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">ArrayList</span><span class="o">();</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">TestGC</span> <span class="n">gc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestGC</span><span class="o">();</span>
</span><span class='line'>            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">gc</span><span class="o">.</span><span class="na">getString</span><span class="o">());</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行上面的方法，<strong>并不会导致OOM异常</strong>，因为我们持有的时1000000个ab字符串对象，而TestGC对象（包括其中的largeString）会在java的垃圾回收中释放掉。所以这里不会存在内存溢出。</p>

<p>那么究竟是什么导致的内存泄露呢？要研究这个问题，我们需要看一下方法的实现，即可。</p>

<h2>深入Java 6实现</h2>

<p>在String类中存在这样三个属性</p>

<ul>
<li>value 字符数组，存储字符串实际的内容</li>
<li>offset 该字符串在字符数组value中的起始位置</li>
<li>count 字符串包含的字符的长度</li>
</ul>


<p>Java 6中substring的实现</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">String</span> <span class="nf">substring</span><span class="o">(</span><span class="kt">int</span> <span class="n">beginIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">endIndex</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">beginIndex</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">throw</span> <span class="k">new</span> <span class="nf">StringIndexOutOfBoundsException</span><span class="o">(</span><span class="n">beginIndex</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">endIndex</span> <span class="o">&gt;</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">throw</span> <span class="k">new</span> <span class="nf">StringIndexOutOfBoundsException</span><span class="o">(</span><span class="n">endIndex</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">beginIndex</span> <span class="o">&gt;</span> <span class="n">endIndex</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">throw</span> <span class="k">new</span> <span class="nf">StringIndexOutOfBoundsException</span><span class="o">(</span><span class="n">endIndex</span> <span class="o">-</span> <span class="n">beginIndex</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">((</span><span class="n">beginIndex</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">endIndex</span> <span class="o">==</span> <span class="n">count</span><span class="o">))</span> <span class="o">?</span> <span class="k">this</span> <span class="o">:</span>
</span><span class='line'>      <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">beginIndex</span><span class="o">,</span> <span class="n">endIndex</span> <span class="o">-</span> <span class="n">beginIndex</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上述方法调用的构造方法</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//Package private constructor which shares value array for speed.</span>
</span><span class='line'><span class="n">String</span><span class="o">(</span><span class="kt">int</span> <span class="n">offset</span><span class="o">,</span> <span class="kt">int</span> <span class="n">count</span><span class="o">,</span> <span class="kt">char</span> <span class="n">value</span><span class="o">[])</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'>  <span class="k">this</span><span class="o">.</span><span class="na">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="o">;</span>
</span><span class='line'>  <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当我们读完上述的代码，我们应该会豁然开朗，原来是这个样子啊！</p>

<p>当我们调用字符串a的substring得到字符串b，其实这个操作，无非就是调整了一下b的offset和count，用到的内容还是a之前的value字符数组，并没有重新创建新的专属于b的内容字符数组。</p>

<p>举个和上面重现代码相关的例子，比如我们有一个1G的字符串a，我们使用substring(0,2)得到了一个只有两个字符的字符串b，如果b的生命周期要长于a或者手动设置a为null，当垃圾回收进行后，a被回收掉，b没有回收掉，那么这1G的内存占用依旧存在，因为b持有这1G大小的字符数组的引用。</p>

<p>看到这里，大家应该可以明白上面的代码为什么出现内存溢出了。</p>

<h3>共享内容字符数组</h3>

<p>其实substring中生成的字符串与原字符串共享内容数组是一个很棒的设计，这样避免了每次进行substring重新进行字符数组复制。正如其文档说明的,共享内容字符数组为了就是速度。但是对于本例中的问题，共享内容字符数组显得有点蹩脚。</p>

<h3>如何解决</h3>

<p>对于之前比较不常见的1G字符串只截取2个字符的情况可以使用下面的代码，这样的话，就不会持有1G字符串的内容数组引用了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="n">littleString</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">largeString</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面的这个构造方法，在源字符串内容数组长度大于字符串长度时，进行数组复制，新的字符串会创建一个只包含源字符串内容的字符数组。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="nf">String</span><span class="o">(</span><span class="n">String</span> <span class="n">original</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="na">count</span><span class="o">;</span>
</span><span class='line'>  <span class="kt">char</span><span class="o">[]</span> <span class="n">originalValue</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
</span><span class='line'>  <span class="kt">char</span><span class="o">[]</span> <span class="n">v</span><span class="o">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">originalValue</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">// The array representing the String is bigger than the new</span>
</span><span class='line'>      <span class="c1">// String itself.  Perhaps this constructor is being called</span>
</span><span class='line'>      <span class="c1">// in order to trim the baggage, so make a copy of the array.</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">off</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="na">offset</span><span class="o">;</span>
</span><span class='line'>      <span class="n">v</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">originalValue</span><span class="o">,</span> <span class="n">off</span><span class="o">,</span> <span class="n">off</span><span class="o">+</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">// The array representing the String is the same</span>
</span><span class='line'>      <span class="c1">// size as the String, so no point in making a copy.</span>
</span><span class='line'>      <span class="n">v</span> <span class="o">=</span> <span class="n">originalValue</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">this</span><span class="o">.</span><span class="na">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>  <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>  <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Java 7 实现</h2>

<p>在Java 7 中substring的实现抛弃了之前的内容字符数组共享的机制，对于子字符串（自身除外）采用了数组复制实现单个字符串持有自己的应该拥有的内容。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">String</span> <span class="nf">substring</span><span class="o">(</span><span class="kt">int</span> <span class="n">beginIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">endIndex</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">beginIndex</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">throw</span> <span class="k">new</span> <span class="nf">StringIndexOutOfBoundsException</span><span class="o">(</span><span class="n">beginIndex</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">endIndex</span> <span class="o">&gt;</span> <span class="n">value</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">throw</span> <span class="k">new</span> <span class="nf">StringIndexOutOfBoundsException</span><span class="o">(</span><span class="n">endIndex</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">subLen</span> <span class="o">=</span> <span class="n">endIndex</span> <span class="o">-</span> <span class="n">beginIndex</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">subLen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">throw</span> <span class="k">new</span> <span class="nf">StringIndexOutOfBoundsException</span><span class="o">(</span><span class="n">subLen</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">((</span><span class="n">beginIndex</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">endIndex</span> <span class="o">==</span> <span class="n">value</span><span class="o">.</span><span class="na">length</span><span class="o">))</span> <span class="o">?</span> <span class="k">this</span>
</span><span class='line'>                <span class="o">:</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">beginIndex</span><span class="o">,</span> <span class="n">subLen</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>substring方法中调用的构造方法，进行内容字符数组复制。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="nf">String</span><span class="o">(</span><span class="kt">char</span> <span class="n">value</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">offset</span><span class="o">,</span> <span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">throw</span> <span class="k">new</span> <span class="nf">StringIndexOutOfBoundsException</span><span class="o">(</span><span class="n">offset</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">throw</span> <span class="k">new</span> <span class="nf">StringIndexOutOfBoundsException</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">value</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">throw</span> <span class="k">new</span> <span class="nf">StringIndexOutOfBoundsException</span><span class="o">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">count</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">offset</span><span class="o">,</span> <span class="n">offset</span><span class="o">+</span><span class="n">count</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>真的是内存泄露么</h2>

<p>我们知道了substring某些情况下可能引起内存问题，但是这个叫做内存泄露么？</p>

<p>其实个人认为这个不应该算为内存泄露，使用substring生成的字符串b固然会持有原有字符串a的内容数组引用，但是当a和b都被回收之后，该字符数组的内容也是可以被垃圾回收掉的。</p>

<h2>哪个版本实现的好</h2>

<p>关于Java 7 对substring做的修改，收到了褒贬不一的反馈。</p>

<p>个人更加倾向于Java 6的实现，当进行substring时，使用共享内容字符数组，速度会更快，不用重新申请内存。虽然有可能出现本文中的内存性能问题，但也是有方法可以解决的。</p>

<p>Java 7的实现不需要程序员特殊操作避免了本文中问题，但是进行每次substring的操作性能总会比java 6 的实现要差一些。这种实现显得有点“糟糕”。</p>

<h2>问题的价值</h2>

<p>虽然这个问题出现在Java 6并且Java 7中已经修复，但并不代表我们就不需要了解，况且Java 7的重新实现被喷的很厉害。</p>

<p>其实这个问题的价值，还是比较宝贵的，尤其是内容字符数组共享这个优化的实现。希望可以为大家以后的设计实现提供帮助和一些想法。</p>

<h2>受影响的方法</h2>

<p>trim和subSequence都存在调用substring的操作。Java 6和Java 7 substring实现的更改也间接影响到了这些方法。</p>

<h2>参考资源</h2>

<p>以下三篇文章写得都比较不错，但是都稍微有一些问题，我都已经标明出来，大家阅读时，需要注意。</p>

<ul>
<li><a href="http://www.programcreek.com/2013/09/the-substring-method-in-jdk-6-and-jdk-7/">The substring() Method in JDK 6 and JDK 7</a> 本文中解决java6中问题提到的字符串拼接<strong>不推荐</strong>，具体原因可以参考<a href="http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/">Java细节：字符串的拼接</a></li>
<li><a href="http://javarevisited.blogspot.com/2011/10/how-substring-in-java-works.html">How SubString method works in Java &ndash; Memory Leak Fixed in JDK 1.7</a> 本文中提到的有一个概念错误，新的字符串不会阻止旧的字符串被回收，而是阻止旧字符串中的内容字符数组。阅读时需要注意。</li>
<li><a href="http://bugs.java.com/view_bug.do?bug_id=4513622">JDK-4513622 : (str) keeping a substring of a field prevents GC for object</a> 本文中提到的有一个测试，使用非new的形式有一点问题，其忽视了字符串常量池的存在，具体查看下面的注意。</li>
</ul>


<h2>注意</h2>

<p>上面的重现问题的代码中</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="nf">getString</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">//return this.largeString.substring(0,2);</span>
</span><span class='line'>      <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="s">&quot;ab&quot;</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里最好不要写成下面这样，因为在JVM中存在字符串常量池，&#8221;ab&#8221;不会重新创建新字符串，所有的变量都会引用一个对象，而使用new String()则每次重新创建对象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="nf">getString</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="s">&quot;ab&quot;</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于字符串常量池，以后的文章会有介绍。</p>

<h3>吐血推荐</h3>

<p>如果你对本文这样的内容感兴趣，可以阅读以下Joshua Bloch大神写得书，虽然有点贵，还是英文的。
<a href="http://www.amazon.cn/gp/product/032133678X/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=032133678X&amp;linkCode=as2&amp;tag=droidyue-23">Java Puzzlers</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的堆和栈的区别]]></title>
    <link href="http://droidyue.com/blog/2014/12/07/differences-between-stack-and-heap-in-java/"/>
    <updated>2014-12-07T16:08:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/12/07/differences-between-stack-and-heap-in-java</id>
    <content type="html"><![CDATA[<p>当一个人开始学习Java或者其他编程语言的时候，会接触到堆和栈，由于一开始没有明确清晰的说明解释，很多人会产生很多疑问，什么是堆，什么是栈，堆和栈有什么区别？更糟糕的是，Java中存在栈这样一个后进先出（Last In First Out）的顺序的数据结构，这就是java.util.Stack。这种情况下，不免让很多人更加费解前面的问题。事实上，堆和栈都是内存中的一部分，有着不同的作用，而且一个程序需要在这片区域上分配内存。众所周知，所有的Java程序都运行在JVM虚拟机内部，我们这里介绍的自然是JVM（虚拟）内存中的堆和栈。</p>

<!--more-->


<h2>区别</h2>

<p>java中堆和栈的区别自然是面试中的常见问题，下面几点就是其具体的区别</p>

<h3>各司其职</h3>

<p>最主要的区别就是栈内存用来存储局部变量和方法调用。<br/>
而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p>

<h3>独有还是共享</h3>

<p>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。<br/>
而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</p>

<h3>异常错误</h3>

<p>如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。<br/>
而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。</p>

<h3>空间大小</h3>

<p>栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。如果递归没有及时跳出，很可能发生StackOverFlowError问题。<br/>
你可以通过-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小，-Xmx选项可以设置堆的最大值。</p>

<p>这就是Java中堆和栈的区别。理解好这个问题的话，可以对你解决开发中的问题，分析堆内存和栈内存使用，甚至性能调优都有帮助。</p>

<h4>查看默认值(Updated)</h4>

<p>查看堆的默认值，使用下面的代码，其中InitialHeapSize为最开始的堆的大小，MaxHeapSize为堆的最大值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>13:17 <span class="nv">$ </span>java -XX:+PrintFlagsFinal -version | grep HeapSize
</span><span class='line'>    uintx <span class="nv">ErgoHeapSizeLimit</span>                         <span class="o">=</span> 0                                   <span class="o">{</span>product<span class="o">}</span>
</span><span class='line'>    uintx <span class="nv">HeapSizePerGCThread</span>                       <span class="o">=</span> 87241520                            <span class="o">{</span>product<span class="o">}</span>
</span><span class='line'>    uintx InitialHeapSize                          :<span class="o">=</span> 134217728                           <span class="o">{</span>product<span class="o">}</span>
</span><span class='line'>    uintx <span class="nv">LargePageHeapSizeThreshold</span>                <span class="o">=</span> 134217728                           <span class="o">{</span>product<span class="o">}</span>
</span><span class='line'>    uintx MaxHeapSize                              :<span class="o">=</span> 2147483648                          <span class="o">{</span>product<span class="o">}</span>
</span><span class='line'>java version <span class="s2">&quot;1.8.0_25&quot;</span>
</span><span class='line'>Java<span class="o">(</span>TM<span class="o">)</span> SE Runtime Environment <span class="o">(</span>build 1.8.0_25-b17<span class="o">)</span>
</span><span class='line'>Java HotSpot<span class="o">(</span>TM<span class="o">)</span> 64-Bit Server VM <span class="o">(</span>build 25.25-b02, mixed mode<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>查看栈的默认值,其中ThreadStackSize为栈内存的大小。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>13:21 <span class="nv">$ </span>java -XX:+PrintFlagsFinal -version | grep ThreadStackSize
</span><span class='line'>     intx <span class="nv">CompilerThreadStackSize</span>                   <span class="o">=</span> 0                                   <span class="o">{</span>pd product<span class="o">}</span>
</span><span class='line'>     intx <span class="nv">ThreadStackSize</span>                           <span class="o">=</span> 1024                                <span class="o">{</span>pd product<span class="o">}</span>
</span><span class='line'>     intx <span class="nv">VMThreadStackSize</span>                         <span class="o">=</span> 1024                                <span class="o">{</span>pd product<span class="o">}</span>
</span><span class='line'>java version <span class="s2">&quot;1.8.0_25&quot;</span>
</span><span class='line'>Java<span class="o">(</span>TM<span class="o">)</span> SE Runtime Environment <span class="o">(</span>build 1.8.0_25-b17<span class="o">)</span>
</span><span class='line'>Java HotSpot<span class="o">(</span>TM<span class="o">)</span> 64-Bit Server VM <span class="o">(</span>build 25.25-b02, mixed mode<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>译文信息</h2>

<p>原汁原味的英文原文：<a href="http://javarevisited.blogspot.com.au/2013/01/difference-between-stack-and-heap-java.html">http://javarevisited.blogspot.com.au/2013/01/difference-between-stack-and-heap-java.html</a>.</p>

<p>译文在原文基础上进行了修改，整理，删减。如有兴趣可以访问原文。P.S.地址已被墙。</p>

<h3>一本书</h3>

<p><a href="http://www.amazon.cn/gp/product/0137142528/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=0137142528&amp;linkCode=as2&amp;tag=droidyue-23">Java Performance</a>这本书会帮你深入JVM，垃圾回收，内存监视和性能调优这些方面。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[9本Java程序员必读的书]]></title>
    <link href="http://droidyue.com/blog/2014/11/30/java-programmer-must-read-these-9-books/"/>
    <updated>2014-11-30T10:38:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/30/java-programmer-must-read-these-9-books</id>
    <content type="html"><![CDATA[<p>本文列出的9本书在Java程序员界都是被认为很棒的书。当一个程序员开始初学Java时，他的第一个问题应该是如何选择一本书来作为指导学习Java。这个问题也就表明，相对于其他的教程和博客，Java书籍还是很重要的参考，主要表现在以下两点</p>

<ul>
<li>通常书籍是由比较权威的程序员来撰写的。</li>
<li>相比其他媒介，书籍对于内容的描述更加详细，解释更加明确。</li>
</ul>


<p>本文列出的九本书是我个人非常喜欢的Java书籍，当我有时间的时候，我就会将它们捧在手里阅读。甚至有些书我反复读过很多遍，每次重新读的时候总会有新的收获。因此这些书也是大部分Java程序员喜欢的书籍。</p>

<!--more-->


<h2>Head First Java</h2>

<p><img class="left" src="http://droidyueimg.qiniudn.com/head_first_java.jpg" title="head first java" ></p>

<p>Head First Java是所有编程或者Java初学者最适合的书籍，我很喜欢轻松和寓教于乐的Head First风格，这应该是最有意思的关于Java的书。无论是初级，中级还是高级都能从中有所收获。学习本书，你可以了解到类，对象，线程，集合等编程知识，还可以了解到泛型，枚举，可变参数和自动装箱等语言特性。本书中还涉及到了Java高级编程中的Swing，网络编程，IO操作等，可以让初学者对Java有比较完整地概念。如果你是一位Java初学者，不要犹豫，这本书最适合你了。<br/>
查看详细: <a href="http://www.amazon.cn/gp/product/B0011ESWGI/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011ESWGI&amp;linkCode=as2&amp;tag=droidyue-23">亚马逊</a></p>

<h2>Head First 设计模式</h2>

<p><img class="left" src="http://droidyueimg.qiniudn.com/head_first_design_patterns.jpg" title="head first design pattern" >
Head First设计模式又是一部Head First系列的书籍。作者为Kathy Sierra及其团队。当我在2006年开始读这本书的时候，我对设计模式并不是很了解。设计模式解决什么问题，怎么解决问题，如何使用设计模式，设计模式有什么好处，这些问题我几乎都无法回答出来。但是当我读完这本书的时候，一切都豁然开朗。在本书介绍继承和组合一章，使用简单有趣的例子，一步一步提出问题并解决问题，最终得出最优解。本书中会有很多要点总结，幽默对话，练习题还有有名的单词接龙等帮助你更好地了解设计模式。如果你想了解Java中的设计模式，请带走这本书。<br/>
查看详细：<a href="http://www.amazon.cn/gp/product/B0011FBU34/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011FBU34&amp;linkCode=as2&amp;tag=droidyue-23">亚马逊</a></p>

<h2>Effective Java</h2>

<p><img class="left" src="http://droidyueimg.qiniudn.com/effective_java.jpg" title="Effective Java" >
Effective Java这本书也是一本我最喜欢的。本书为领导开发Java集合框架和并发API包的 约书亚·布洛克 大神所著。本书适合于有着数年开发经验Java程序员，通过本书我们可以很多编程中的最佳实践，并且可以从JDK贡献者布洛克大神这里汲取经验。Effective Java从质量，内容和问题解答方式上来说都是一本评价很高的书，因此读这本书会是一种感觉很棒的体验。另外本书的章节相对比较轻量，与其他章节耦合度较低，因此在旅行或者闲暇时间阅读也是可以的。在内容方面，Effective Java包含了从静态工厂，序列化，equals和hashcode到泛型，枚举，可变参数以及反射的最佳解决方法。本书对Java各方面知识点的讲解会让你受益匪浅。<br/>
查看详细：<a href="http://www.amazon.cn/gp/product/B001PTGR52/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001PTGR52&amp;linkCode=as2&amp;tag=droidyue-23">亚马逊</a></p>

<h2>Concurrency Practice in Java</h2>

<p><img class="left" src="http://droidyueimg.qiniudn.com/java_concurrency_in_practice.jpg" title="Concurrency Practice in Java" >
又一部 约书亚·布洛克 大神的经典之作，当然本书的另一位主作者为 Doug Lea（影响两次Java历史上的大变革的大神）。这本书几乎就是Java并发和多线程编程方面的权威，同时也是核心Java开发人员必读的一本书。本书的强大主要表现在</p>

<ul>
<li>本书非常详细地描述了多线程和并发中的诸多(小)细节。</li>
<li>本书并非聚焦于核心Java代码的实现，而是关注并发引起的问题，比如死锁，饥饿，线程安全，竞争条件，然后提供可行的方法来解决这些问题。因此这本书可以很好地帮助开发者了解并掌握并发包以及其中的CountDownLatch，CyclicBarrier，BlockingQueue，Semaphore这些类。这也是我一遍一遍阅读这本书的原因。</li>
<li>书中的例子简明扼要清晰，很能描述问题。</li>
<li>解释明确：本书很好地解释了什么是错的，为什么错，怎样改正。这也是本书畅销的原因之一。</li>
</ul>


<p>查看详细：<a href="http://www.amazon.cn/gp/product/0321349601/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=0321349601&amp;linkCode=as2&amp;tag=droidyue-23">亚马逊</a></p>

<h2>Java Generics and Collections</h2>

<p><img class="left" src="http://droidyueimg.qiniudn.com/java_generics_and_collections.jpeg" title="Java Generics and Collections" >
这本书是来自O&#8217;Reilly的一本成功之作，作者为Naftalin和Philip Wadler。正如书名可知，这本书的内容关注于泛型和集合这两个Java语言的核心方面。本书对于那些有编程经验的程序员加强对集合和泛型的理解和掌握有很大的帮助。本书详细介绍了每一个集合的API，Set, List, Map, Queue，以及他们的实现，对比不同场景下它们的性能优劣。每个章节最后的对比图表很不错。<br/>
查看详细:<a href="http://www.amazon.cn/gp/product/0596527756/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=0596527756&amp;linkCode=as2&amp;tag=droidyue-23">亚马逊</a></p>

<h2>Java performance</h2>

<p><img class="left" src="http://droidyueimg.qiniudn.com/java_performance.jpg" title="Java performance" >
本书为我个人的最爱，本书重点关注性能监视，性能剖析以及如何使用工具对性能分析。本书不同于其他的编程书籍，因为本书中涉及到很多Java虚拟机的细节，垃圾回收机制，Java堆内存监视以及对程序性能剖析。其中讲述JVM的章节写的很不错，很值得咀嚼。注意，这本书属于编程高级层次，阅读需要具有足够的Java编程经验。初级和中级Java开发者也可以阅读本书也会学到不同程度的干货。所以，你想进行性能调优，把这本书放到你的书架上吧。<br/>
查看详细:<a href="http://www.amazon.cn/gp/product/0137142528/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=0137142528&amp;linkCode=as2&amp;tag=droidyue-23">亚马逊</a></p>

<h2>Java Puzzlers</h2>

<p><img class="left" src="http://droidyueimg.qiniudn.com/java_puzzlers.jpg" title="Java Puzzlers" >
再介绍一本 约书亚·布洛克 大神写的书。本书的另一位作者为Neal Gafter（已转到微软做Donet Compiler技术Lead）。本书讲述了Java语言中的极端情况和陷阱。相对于C++，Java更加安全低风险，JVM有着垃圾回收机制，让Java程序员不用关心内存分配和释放，大大提高了程序的开发效率。但是有些时候，即便是经验丰富的程序员也会被Java中的极端情况或陷阱给绊倒。本书列举并详细描述了Java中的这些陷阱。如果你喜欢刨根问底，钻牛角尖，这本书就是为你而写。通过本书，你可以了解很多java的核心知识并对自己的Java水平有所知晓。本人更加喜欢上面提到的 约书亚·布洛克 的 Effective Java 和 Concurrency Practice in Java。但是如果你感兴趣，还是可以去尝试的。为了让收获最大化，你可以先尝试解决书中的问题，然后对着书中的解释进行比较。<br/>
查看详细:<a href="http://www.amazon.cn/gp/product/032133678X/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=032133678X&amp;linkCode=as2&amp;tag=droidyue-23">亚马逊</a></p>

<h2>Head First Object Oriented Analysis and Design</h2>

<p><img class="left" src="http://droidyueimg.qiniudn.com/head_first_object_oriented_analysis_design.jpg" title="Head First Object Oriented Analysis and Design" >
这是一本属于Head First系列的关于面向对象编程的书。本书建议和Head First设计模式结合阅读，效果更佳。本书关注于面向对象设计原则，比如多用组合少用继承，针对接口编程而非针对实现编程，不要重复你自己等。这本书可以帮助你写出好代码并且参考最佳实践进行优化改善。当然本书中的内容也适合使用其他面向对象的语言的程序员。想学好面向对象编码和设计规则，现在就开始读这本书哈。<br/>
查看详细:<a href="http://www.amazon.cn/gp/product/0596008678/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=0596008678&amp;linkCode=as2&amp;tag=droidyue-23">亚马逊</a></p>

<h2>Thinking in Java</h2>

<p><img class="left" src="http://droidyueimg.qiniudn.com/thinking_in_java.jpg" title="Thinking in Java" >
Thinking in Java book应该是Java中文界最有名的书籍了，中文又名 Java编程思想。作者为Bruce Eckel，他也是Thinking in C++的作者，他用自己很独特的观点讲述了Java。据我所知，这本书获得了很高的认可，本书是一本介绍齐全的Java学习参考书。如果你不喜欢Head First类似小人书那样的讲解，可以尝试这本书。本书的内容讲解详细，成熟（相对Head First有种教科书的感觉）。<br/>
查看详细:<a href="http://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011F7WU4&amp;linkCode=as2&amp;tag=droidyue-23">亚马逊</a></p>

<p>这就是我的关于Java编程相关的推荐的书，这些都可以说是看成经典中的经典。像Effective Java 和 Head First 系列我已经反复阅读了很多遍。相信看完本文，根据自己的水平和想要提升的知识侧重，你应该能选出最适合自己的书了。</p>

<h2>关于翻译</h2>

<p>本文原文为<a href="http://javarevisited.blogspot.com/2013/01/top-5-java-programming-books-best-good.html">http://javarevisited.blogspot.com/2013/01/top-5-java-programming-books-best-good.html</a></p>

<p>译文再原文基础上采用意译较多，并在某些地方进行了些许修改。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[效率工具：强大的批量删除文件的脚本]]></title>
    <link href="http://droidyue.com/blog/2014/11/29/a-super-tool-to-remove-files/"/>
    <updated>2014-11-29T17:29:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/29/a-super-tool-to-remove-files</id>
    <content type="html"><![CDATA[<p>最近打包服务器上的apk包又增多了，每次手动rm操作过于麻烦，于是花了几分钟写了一个可以对指定目录下根据最后修改时间和通配符匹配进行批量删除的脚本。将这个脚本加入crontab中之后，以后就再也不用担心多余的安装包占用磁盘空间了。</p>

<!--more-->


<h2>简短的代码</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#!/usr/bin/env ruby</span>
</span><span class='line'><span class="c1"># encoding: utf-8</span>
</span><span class='line'><span class="c1">#Usage: ruby removeOldFiles.rb &quot;dest_file_pattern&quot; days_ago</span>
</span><span class='line'><span class="n">destFilePattern</span><span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span><span class='line'><span class="n">daysAgo</span><span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'><span class="n">edenTime</span> <span class="o">=</span> <span class="no">Time</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">to_i</span> <span class="o">-</span> <span class="n">daysAgo</span><span class="o">.</span><span class="n">to_i</span> <span class="o">*</span> <span class="mi">86400</span>
</span><span class='line'><span class="no">Dir</span><span class="o">[</span><span class="n">destFilePattern</span><span class="o">].</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">child</span><span class="o">|</span>
</span><span class='line'>    <span class="nb">system</span> <span class="s2">&quot;rm -rfv </span><span class="si">#{</span><span class="n">child</span><span class="si">}</span><span class="s2">&quot;</span>   <span class="k">if</span> <span class="p">(</span><span class="no">File</span><span class="o">.</span><span class="n">mtime</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="o">.</span><span class="n">to_i</span> <span class="o">&lt;</span> <span class="n">edenTime</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>如何使用</h2>

<p>使用起来很简单，使用规则如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ruby removeOldFiles.rb <span class="s2">&quot;dest_file_pattern&quot;</span> days_ago
</span></code></pre></td></tr></table></div></figure>


<p>举个例子，比如我们想删除/tmp目录下的，所有最后修改时间为3天前的apk文件，我们只需要这样执行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ruby removeOldFiles.rb <span class="s2">&quot;/tmp/*.apk&quot;</span> 3
</span></code></pre></td></tr></table></div></figure>


<h2>为什么第一个参数使用双引号</h2>

<p>第一个参数为包含通配符的路径，在shell中存在一个工具就是glob会将包含通配符的路径匹配到具体的文件，比如这样的一段代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#!/usr/bin/env ruby</span>
</span><span class='line'><span class="c1"># encoding: utf-8</span>
</span><span class='line'><span class="nb">puts</span> <span class="no">ARGV</span><span class="o">.</span><span class="n">length</span>
</span><span class='line'><span class="no">ARGV</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;Argument: </span><span class="si">#{</span><span class="n">a</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们传入含有通配符的路径参数，得到的结果就是glob匹配后的文件名（前提是通配符可以匹配到文件）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>10:41 <span class="nv">$ </span>ruby test.rb *.txt
</span><span class='line'>2
</span><span class='line'>Argument: abc.txt
</span><span class='line'>Argument: def.txt
</span></code></pre></td></tr></table></div></figure>


<p>为了避免进行glob操作,需要对包含通配符的路径参数使用双引号标记。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>10:41 <span class="nv">$ </span>ruby test.rb <span class="s2">&quot;*.txt&quot;</span>
</span><span class='line'>1
</span><span class='line'>Argument: *.txt
</span></code></pre></td></tr></table></div></figure>


<p>所以在使用脚本时第一个参数一定要使用双引号。</p>

<h2>如何遍历文件包含子目录内的</h2>

<p>比如我们想遍历<code>/tmp/abc/def.txt</code> 我们可以使用<code>/tmp/**/.txt</code>即可</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[仿腾讯新闻样式的Toast]]></title>
    <link href="http://droidyue.com/blog/2014/11/29/custom-toast-like-tencent-news-app/"/>
    <updated>2014-11-29T17:21:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/29/custom-toast-like-tencent-news-app</id>
    <content type="html"><![CDATA[<p>厌倦了网易新闻无处不在的喷子，尝试了一下腾讯新闻，果然顿时清净了很多，当然这不是重点。个人感觉腾讯新闻客户端的Toast比较不错，相对于系统默认的Toast，更加能起到提醒的作用。于是反编译了一下，简单分享一下,其实很简单。</p>

<!--more-->


<h2>先看效果</h2>

<p><img src="http://droidyueimg.qiniudn.com/tencent_toast.png">
背景为深灰色，支持设置图片和文字。</p>

<h2>布局文件</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
</span><span class='line'><span class="nt">&lt;RelativeLayout</span>
</span><span class='line'>    <span class="na">android:id=</span><span class="s">&quot;@+id/view_tips_layout&quot;</span>
</span><span class='line'>    <span class="na">android:background=</span><span class="s">&quot;@drawable/tips_bg&quot;</span>
</span><span class='line'>    <span class="na">android:layout_width=</span><span class="s">&quot;wrap_content&quot;</span>
</span><span class='line'>    <span class="na">android:layout_height=</span><span class="s">&quot;wrap_content&quot;</span>
</span><span class='line'>      <span class="na">xmlns:android=</span><span class="s">&quot;http://schemas.android.com/apk/res/android&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;View</span>
</span><span class='line'>        <span class="na">android:layout_width=</span><span class="s">&quot;160.0dip&quot;</span>
</span><span class='line'>        <span class="na">android:layout_height=</span><span class="s">&quot;160.0dip&quot;</span>
</span><span class='line'>        <span class="na">android:layout_centerInParent=</span><span class="s">&quot;true&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;LinearLayout</span>
</span><span class='line'>        <span class="na">android:orientation=</span><span class="s">&quot;vertical&quot;</span>
</span><span class='line'>        <span class="na">android:layout_width=</span><span class="s">&quot;wrap_content&quot;</span>
</span><span class='line'>        <span class="na">android:layout_height=</span><span class="s">&quot;wrap_content&quot;</span>
</span><span class='line'>        <span class="na">android:layout_centerInParent=</span><span class="s">&quot;true&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>
</span><span class='line'>        <span class="nt">&lt;ImageView</span>
</span><span class='line'>            <span class="na">android:gravity=</span><span class="s">&quot;center&quot;</span>
</span><span class='line'>            <span class="na">android:layout_gravity=</span><span class="s">&quot;center&quot;</span>
</span><span class='line'>            <span class="na">android:id=</span><span class="s">&quot;@+id/tips_icon&quot;</span>
</span><span class='line'>            <span class="na">android:layout_width=</span><span class="s">&quot;wrap_content&quot;</span>
</span><span class='line'>            <span class="na">android:layout_height=</span><span class="s">&quot;wrap_content&quot;</span>
</span><span class='line'>            <span class="na">android:layout_marginBottom=</span><span class="s">&quot;10.0dip&quot;</span>
</span><span class='line'>            <span class="na">android:src=</span><span class="s">&quot;@drawable/tips_error&quot;</span>
</span><span class='line'>            <span class="na">android:contentDescription=</span><span class="s">&quot;@null&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>
</span><span class='line'>        <span class="nt">&lt;TextView</span>
</span><span class='line'>            <span class="na">android:textSize=</span><span class="s">&quot;17.0sp&quot;</span>
</span><span class='line'>            <span class="na">android:textColor=</span><span class="s">&quot;#ffffffff&quot;</span>
</span><span class='line'>            <span class="na">android:gravity=</span><span class="s">&quot;center&quot;</span>
</span><span class='line'>            <span class="na">android:layout_gravity=</span><span class="s">&quot;center&quot;</span>
</span><span class='line'>            <span class="na">android:id=</span><span class="s">&quot;@+id/tips_msg&quot;</span>
</span><span class='line'>            <span class="na">android:layout_width=</span><span class="s">&quot;wrap_content&quot;</span>
</span><span class='line'>            <span class="na">android:layout_height=</span><span class="s">&quot;wrap_content&quot;</span>
</span><span class='line'>            <span class="na">android:lineSpacingExtra=</span><span class="s">&quot;3.0dip&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/LinearLayout&gt;</span>
</span><span class='line'><span class="nt">&lt;/RelativeLayout&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>程序代码</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Toast</span> <span class="n">toast</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Toast</span><span class="o">(</span><span class="n">getApplicationContext</span><span class="o">());</span>
</span><span class='line'><span class="n">View</span> <span class="n">toastView</span> <span class="o">=</span> <span class="n">LayoutInflater</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">getApplicationContext</span><span class="o">()).</span><span class="na">inflate</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">view_tips</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span><span class='line'><span class="o">((</span><span class="n">ImageView</span><span class="o">)</span><span class="n">toastView</span><span class="o">.</span><span class="na">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">tips_icon</span><span class="o">)).</span><span class="na">setImageResource</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">drawable</span><span class="o">.</span><span class="na">ic_launcher</span><span class="o">);</span>
</span><span class='line'><span class="o">((</span><span class="n">TextView</span><span class="o">)</span><span class="n">toastView</span><span class="o">.</span><span class="na">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">tips_msg</span><span class="o">)).</span><span class="na">setText</span><span class="o">(</span><span class="s">&quot;Error Occurs&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">toast</span><span class="o">.</span><span class="na">setView</span><span class="o">(</span><span class="n">toastView</span><span class="o">);</span>
</span><span class='line'><span class="n">toast</span><span class="o">.</span><span class="na">setGravity</span><span class="o">(</span><span class="n">Gravity</span><span class="o">.</span><span class="na">NO_GRAVITY</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'><span class="n">toast</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>Toast默认的位置为底部水平居中。我们可以通过设置setGravity(int, int, int)来进行设置位置。该方法接受三个参数，一个Gravity常量，一个x（水平）方向上的偏移量，一个y（竖直）方向上的偏移量。</p>

<p>如果我们想让位置向右我们需要增加x方向上的偏移量，如果想让位置向下，增大y方向上的偏移量。</p>

<h2>多说</h2>

<p>我们可以根据自己的需求去设置图片，文字，背景色等样式来定制想要的Toast。</p>

<p>注意，涉及到长度宽度字体大小相关的建议放到dimens文件，便于我们进行设备适配。</p>

<h2>示例下载</h2>

<p><a href="http://pan.baidu.com/s/1kTLxagZ">百度网盘</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google为何这样设计OnSharedPreferenceChangeListener]]></title>
    <link href="http://droidyue.com/blog/2014/11/29/why-onsharedpreferencechangelistener-was-not-called/"/>
    <updated>2014-11-29T16:41:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/29/why-onsharedpreferencechangelistener-was-not-called</id>
    <content type="html"><![CDATA[<p>之前使用OnSharedPreferenceChangeListener，遇到了点小问题，就是有些时候OnSharedPreferenceChangeListener没有被触发。最近花了点时间研究了一下，小做整理。本文将会介绍监听器不被触发的原因，解决方法，以及其中隐含的一些技术细节。</p>

<!--more-->


<h2>问题再现</h2>

<p>OnSharedPreferenceChangeListener是Android中SharedPreference文件发生变化的监听器。通常我们想要进行监听，会实现如下的代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">PreferenceManager</span><span class="o">.</span><span class="na">getDefaultSharedPreferences</span><span class="o">(</span><span class="n">getApplicationContext</span><span class="o">())</span>
</span><span class='line'>      <span class="o">.</span><span class="na">registerOnSharedPreferenceChangeListener</span><span class="o">(</span><span class="k">new</span> <span class="n">OnSharedPreferenceChangeListener</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="nd">@Override</span>
</span><span class='line'>      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSharedPreferenceChanged</span><span class="o">(</span>
</span><span class='line'>          <span class="n">SharedPreferences</span> <span class="n">sharedPreferences</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">LOGTAG</span><span class="o">,</span> <span class="s">&quot;testOnSharedPreferenceChangedWrong key =&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">});</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种写法看上去没有什么问题，而且很多时候开始几次onSharedPreferenceChanged方法也可以被调用。但是过一段时间（简单demo不容易出现，但是使用DDMS中的gc会立刻导致接下来的问题），你会发现前面的方法突然不再被调用，进而影响到程序的处理。</p>

<h2>原因剖析</h2>

<p>简而言之，就是你注册的监听器被移除掉了。<br/>
首先我们先了解一下registerOnSharedPreferenceChangeListener注册的实现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">final</span> <span class="n">WeakHashMap</span><span class="o">&lt;</span><span class="n">OnSharedPreferenceChangeListener</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">mListeners</span> <span class="o">=</span>
</span><span class='line'>            <span class="k">new</span> <span class="n">WeakHashMap</span><span class="o">&lt;</span><span class="n">OnSharedPreferenceChangeListener</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;();</span>
</span><span class='line'><span class="c1">//some code goes here</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="n">More</span> <span class="o">...</span><span class="na">registerOnSharedPreferenceChangeListener</span><span class="o">(</span><span class="n">OnSharedPreferenceChangeListener</span> <span class="n">listener</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">mListeners</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">listener</span><span class="o">,</span> <span class="n">mContent</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从上面的代码可以得知，一个OnSharedPreferenceChangeListener对象实际上是放到了一个WeakHashMap的容器中，执行完示例中的onCreate方法，这个监听器对象很快就会成为垃圾回收的目标，由于放在WeakHashMap中作为key不会阻止垃圾回收，所以当监听器对象被回收之后，这个监听器也会从mListeners中移除。所以就造成了onSharedPreferenceChanged不会被调用。</p>

<p>关于WeakHashMap相关，请阅读<a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">译文：理解Java中的弱引用</a>进而更多了解。</p>

<h2>如何解决</h2>

<h3>改为对象成员变量（推荐）</h3>

<p>将监听器作为Activity的一个成员变量，在Activity的onResume进行注册，在onPause时进行注销。推荐在这两个Activity生命周期中进行处理，尤其是当SharedPreference值发生变化后，对Activity展示的UI进行处理操作的情况。这种方法是最推荐的解决方案。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="n">OnSharedPreferenceChangeListener</span> <span class="n">mListener</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OnSharedPreferenceChangeListener</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSharedPreferenceChanged</span><span class="o">(</span>
</span><span class='line'>      <span class="n">SharedPreferences</span> <span class="n">sharedPreferences</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">LOGTAG</span><span class="o">,</span> <span class="s">&quot;instance variable key=&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">};</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onResume</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">PreferenceManager</span><span class="o">.</span><span class="na">getDefaultSharedPreferences</span><span class="o">(</span><span class="n">getApplicationContext</span><span class="o">()).</span><span class="na">registerOnSharedPreferenceChangeListener</span><span class="o">(</span><span class="n">mListener</span><span class="o">);</span>
</span><span class='line'>  <span class="kd">super</span><span class="o">.</span><span class="na">onResume</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onPause</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">PreferenceManager</span><span class="o">.</span><span class="na">getDefaultSharedPreferences</span><span class="o">(</span><span class="n">getApplicationContext</span><span class="o">()).</span><span class="na">unregisterOnSharedPreferenceChangeListener</span><span class="o">(</span><span class="n">mListener</span><span class="o">);</span>
</span><span class='line'>  <span class="kd">super</span><span class="o">.</span><span class="na">onPause</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>改为静态变量（不推荐）</h3>

<p>如下，将一个指向匿名的内部类对象的变量sListener使用static修饰，这个内部类对象则不会持有外部类的引用。<br/>
但是这种做法并不推荐，因为一个静态变量和与外部实例不相关，我们很难和外部实例进行一些操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="n">OnSharedPreferenceChangeListener</span> <span class="n">sListener</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OnSharedPreferenceChangeListener</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSharedPreferenceChanged</span><span class="o">(</span>
</span><span class='line'>      <span class="n">SharedPreferences</span> <span class="n">sharedPreferences</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">LOGTAG</span><span class="o">,</span> <span class="s">&quot;static variable key=&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">};</span>
</span></code></pre></td></tr></table></div></figure>


<h2>为什么这样设计</h2>

<p>可能会有人认为这是系统设计的猫腻或者bug，其实不然，这正是Android设计人员的高明之处。</p>

<p>正如我们示例的代码一样，将一个（隐式的）局部变量添加到监听器容器中，如果该容器只是一个普通的HashMap，这样会导致内存泄露，因为该容器还有局部变量指向的对象，该对象又隐式持有外部Activity的对象，导致Activity无法被销毁。关于非静态内部类持有隐式持有外部类引用，请参考<a href="http://droidyue.com/blog/2014/10/02/the-private-modifier-in-java/">细话Java：&#8221;失效&#8221;的private修饰符</a></p>

<p>除此之外，因为局部变量无法在其所在方法外部访问，这样就导致了我们只可以使用方法中使用局部变量就行注册，在合适的时机却无法使用局部变量进行注销。</p>

<h2>三本帮助深入研究Java的书</h2>

<ul>
<li><a href="http://www.amazon.cn/gp/product/0137142528/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=0137142528&amp;linkCode=as2&amp;tag=droidyue-23">Java Performance</a></li>
<li><a href="http://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011F7WU4&amp;linkCode=as2&amp;tag=droidyue-23">Java编程思想(第4版)</a></li>
<li><a href="http://www.amazon.cn/gp/product/B001PTGR52/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001PTGR52&amp;linkCode=as2&amp;tag=droidyue-23">Sun 公司核心技术丛书:Effective Java中文版(第2版)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中WebView拦截替换网络请求数据]]></title>
    <link href="http://droidyue.com/blog/2014/11/23/block-web-resource-in-webview/"/>
    <updated>2014-11-23T21:54:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/23/block-web-resource-in-webview</id>
    <content type="html"><![CDATA[<p>Android中处理网页时我们必然用到WebView,这里我们有这样一个需求，我们想让WebView在处理网络请求的时候将某些请求拦截替换成某些特殊的资源。具体一点儿说，在WebView加载 <code>http://m.sogou.com</code> 时，会加载一个logo图片，我们的需求就是将这个logo图片换成另一张图片。</p>

<!--more-->


<h3>shouldInterceptRequest</h3>

<p>好在Android中的WebView比较强大，从API 11(Android 3.0)开始， shouldInterceptRequest被引入就是为了解决这一类的问题。</p>

<p>shouldInterceptRequest这个回调可以通知主程序WebView处理的资源（css,js,image等）请求，并允许主程序进行处理后返回数据。如果主程序返回的数据为null，WebView会自行请求网络加载资源，否则使用主程序提供的数据。注意这个回调发生在非UI线程中,所以进行UI系统相关的操作是不可以的。</p>

<p>shouldInterceptRequest有两种重载。</p>

<ul>
<li><strong>public WebResourceResponse shouldInterceptRequest (WebView view, String url)</strong> 从API 11开始引入，API 21弃用</li>
<li><strong>public WebResourceResponse shouldInterceptRequest (WebView view, WebResourceRequest request)</strong> 从API 21开始引入</li>
</ul>


<p>本次例子暂时使用第一种，即shouldInterceptRequest (WebView view, String url)。</p>

<h3>示例代码</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">WebView</span> <span class="n">webView</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WebView</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'><span class="n">webView</span><span class="o">.</span><span class="na">setWebViewClient</span><span class="o">(</span><span class="k">new</span> <span class="n">WebViewClient</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">WebResourceResponse</span> <span class="nf">shouldInterceptRequest</span><span class="o">(</span><span class="n">WebView</span> <span class="n">view</span><span class="o">,</span>  <span class="n">String</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">LOGTAG</span><span class="o">,</span> <span class="s">&quot;shouldInterceptRequest url=&quot;</span> <span class="o">+</span> <span class="n">url</span> <span class="o">+</span> <span class="s">&quot;;threadInfo&quot;</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
</span><span class='line'>      <span class="n">WebResourceResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">url</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">&quot;logo&quot;</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">InputStream</span> <span class="n">localCopy</span> <span class="o">=</span> <span class="n">getAssets</span><span class="o">().</span><span class="na">open</span><span class="o">(</span><span class="s">&quot;droidyue.png&quot;</span><span class="o">);</span>
</span><span class='line'>              <span class="n">response</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WebResourceResponse</span><span class="o">(</span><span class="s">&quot;image/png&quot;</span><span class="o">,</span> <span class="s">&quot;UTF-8&quot;</span><span class="o">,</span> <span class="n">localCopy</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>          <span class="o">}</span>        
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">response</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>    
</span><span class='line'><span class="o">});</span>
</span><span class='line'><span class="n">setContentView</span><span class="o">(</span><span class="n">webView</span><span class="o">);</span>
</span><span class='line'><span class="n">webView</span><span class="o">.</span><span class="na">loadUrl</span><span class="o">(</span><span class="s">&quot;http://m.sogou.com&quot;</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中WebResourceResponse需要设定三个属性，MIME类型，数据编码，数据(InputStream流形式)。</p>

<h3>示例下载</h3>

<ul>
<li><a href="http://pan.baidu.com/s/1ntOaHoH">百度云盘</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[点击网页链接调用Android程序]]></title>
    <link href="http://droidyue.com/blog/2014/11/23/start-android-application-when-click-a-link/"/>
    <updated>2014-11-23T15:58:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/23/start-android-application-when-click-a-link</id>
    <content type="html"><![CDATA[<p>最近前端同事问了我一个问题，如何让网页链接实现启动Android的应用，网上有说重写WebView相关的shouldOverrideUrlLoading方法，但是这种理论上能实现，因为你的网页不是仅仅被你自己的webview来浏览，你需要做的是让市面上的浏览器支持才行。</p>

<p>这里利用零碎的时间整理一下。主要涉及到的问题就是关于Intent在字符串形式和Intent对象之间的转换。如果你是一位前端工程师，请让你的Anroid开发小伙伴来看这篇文章，一同解决问题。</p>

<!--more-->


<h2>两种表现形式</h2>

<p>Intent是Android开发中常见的API。在处理Android组件中，有着必不可少的作用。Intent可以以两种方式存在。</p>

<ul>
<li>Intent对象。用于在程序中处理，在处理Android组件时使用。</li>
<li>字符串形式的URI。 用于在非程序代码中，如网页中进行使用等。</li>
</ul>


<p>而这里我们解决我们上面问题的就是后者，字符串形式的Intent。</p>

<h2>Intent对象转成字符串URI</h2>

<p>Intent提供了两种将对象转换成字符串URI，一个是推荐的<code>public String toUri (int flags)</code>，
在API 4加入，将Intent对象转换成字符串形式的URI。字符串形式的URI可以包含Intent的data,action,categories, type, flags, package, component和extras。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Intent</span> <span class="n">intent</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Intent</span><span class="o">();</span>
</span><span class='line'><span class="n">ComponentName</span> <span class="n">comp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ComponentName</span><span class="o">(</span><span class="s">&quot;com.mx.app.mxhaha&quot;</span><span class="o">,</span> <span class="s">&quot;com.mx.app.MxMainActivity&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">intent</span><span class="o">.</span><span class="na">setComponent</span><span class="o">(</span><span class="n">comp</span><span class="o">);</span>
</span><span class='line'><span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">LOGTAG</span><span class="o">,</span> <span class="s">&quot;intent.uri=&quot;</span> <span class="o">+</span> <span class="n">intent</span><span class="o">.</span><span class="na">toUri</span><span class="o">(</span><span class="n">Intent</span><span class="o">.</span><span class="na">URI_INTENT_SCHEME</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>生成的字符串URI为</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nl">intent:</span><span class="err">#</span><span class="n">Intent</span><span class="o">;</span><span class="n">component</span><span class="o">=</span><span class="n">com</span><span class="o">.</span><span class="na">mx</span><span class="o">.</span><span class="na">app</span><span class="o">.</span><span class="na">mxhaha</span><span class="o">/</span><span class="n">com</span><span class="o">.</span><span class="na">mx</span><span class="o">.</span><span class="na">app</span><span class="o">.</span><span class="na">MxMainActivity</span><span class="o">;</span><span class="n">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>另一个方法是<code>public String toURI ()</code>，
这是一个弃用的方法，因为它生成的字符串以<strong>#</strong>开头，<strong>放在链接上会被当成锚点</strong>。不建议使用使用这个方法。</p>

<p>上面的Intent对象使用toUri转换成</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="err">#</span><span class="n">Intent</span><span class="o">;</span><span class="n">component</span><span class="o">=</span><span class="n">com</span><span class="o">.</span><span class="na">mx</span><span class="o">.</span><span class="na">app</span><span class="o">.</span><span class="na">mxhaha</span><span class="o">/</span><span class="n">com</span><span class="o">.</span><span class="na">mx</span><span class="o">.</span><span class="na">app</span><span class="o">.</span><span class="na">MxMainActivity</span><span class="o">;</span><span class="n">end</span>
</span></code></pre></td></tr></table></div></figure>


<h2>字符串URI转成Intent对象</h2>

<h3>getIntent(String uri)</h3>

<p>这个方法只适用于处理以#开头的URI，而且在其方法内部实际上是调用的<code>parseUri(uri, 0)</code>来实现的。这个方法已经被比较为弃用，不推荐使用。</p>

<h3>getIntentOld(String uri)</h3>

<p>getIntentOld既可以支持#开头的URI转换成Intent对象，如果uri不是Intent的字符串形式，那么也会返回一个Intent，只是其data部分为uri，action为android.intent.action.VIEW。</p>

<h3>parseUri(String uri, int flags)</h3>

<p>这个是最完整的转换方法。接收uri和flag作为参数。支持将字符串形式的URI转成Intent对象.</p>

<p>以下为一个既可以解析<strong>intent:</strong>开头的URI也可以解析<strong>#Intent</strong>开头的URI的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="n">Intent</span> <span class="nf">parseIntent</span><span class="o">(</span><span class="n">String</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">Intent</span> <span class="n">intent</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>  <span class="c1">// Parse intent URI into Intent Object</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>  <span class="kt">boolean</span> <span class="n">isIntentUri</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">url</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">&quot;intent:&quot;</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">isIntentUri</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>      <span class="n">flags</span> <span class="o">=</span> <span class="n">Intent</span><span class="o">.</span><span class="na">URI_INTENT_SCHEME</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">url</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">&quot;#Intent;&quot;</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">isIntentUri</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">isIntentUri</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">intent</span> <span class="o">=</span> <span class="n">Intent</span><span class="o">.</span><span class="na">parseUri</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">flags</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">URISyntaxException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">intent</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>多说一下</h2>

<p>对于Intent字符串形式URI在网页链接中的应用，不同的浏览器实现程度不一致。目前<a href="http://www.maxthon.cn/">傲游浏览器Android版</a>由我已经完全实现这一功能。希望其他的浏览器也可以实现一下这个功能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Atom订阅转成RSS2.0]]></title>
    <link href="http://droidyue.com/blog/2014/11/18/convert-atom-to-rss/"/>
    <updated>2014-11-18T21:33:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/18/convert-atom-to-rss</id>
    <content type="html"><![CDATA[<p>Octopress博客自带的只Atom协议的订阅，但是最近提交收录网站时，需要使用RSS协议。于是利用周末简单实现了一下。</p>

<!--more-->


<h2>Atom和RSS</h2>

<p>以下为维基百科对Atom和RSS的解释。</p>

<blockquote><p>RSS（简易信息聚合）是一种消息来源格式规范，用以聚合经常发布更新数据的网站，例如博客文章、新闻、音频或视频的网摘。RSS文件（或称做摘要、网络摘要、或频更新，提供到频道）包含了全文或是节录的文字，再加上发用者所订阅之网摘布数据和授权的元数据。</p>

<p>Atom是一對彼此相關的標準。Atom供稿格式（Atom Syndication Format）是用於網站消息來源，基于XML的文档格式；而Atom出版協定（Atom Publishing Protocol，簡稱AtomPub或APP）是用於新增及修改網路資源，基于HTTP的协议。</p>

<p>Atom借鉴了各种版本RSS的使用经验，被許多的聚合工具广泛使用在发布和使用上。Atom供稿格式設計作為RSS的替代品；而Atom出版協定用來取代現有的多種發布方式（如Blogger API和LiveJournal XML-RPC Client/Server Protocol）。而值得一提的是Google提供的多種服务正在使用Atom。Google Data API（GData）亦基於Atom。</p></blockquote>

<p>可以访问<a href="http://zh.wikipedia.org/zh/Atom_(%E6%A8%99%E6%BA%96)#Atom.E8.88.87RSS_2.0.E7.9A.84.E6.AF.94.E8.BC.83" target="_blank">Atom與RSS 2.0的比較</a>，了解更详细的内容。</p>

<p>由此可知，Atom是现在和未来的主要供稿格式，而RSS是一个已经声明被冻结的格式。</p>

<h2>Atom转换成RSS</h2>

<ul>
<li>clone下这个工程<a href="https://github.com/androidyue/atom2rss">https://github.com/androidyue/atom2rss</a></li>
<li>使用<code>php atom2rss.php input_file output_file</code>即可完成转换。</li>
</ul>


<h3>atom2rss.php</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="o">&lt;?</span><span class="nx">php</span>
</span><span class='line'>    <span class="nv">$source</span> <span class="o">=</span> <span class="nv">$argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>    <span class="nv">$toFile</span> <span class="o">=</span> <span class="nv">$argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'>    <span class="nv">$atom2rssXsl</span> <span class="o">=</span> <span class="nb">dirname</span><span class="p">(</span><span class="k">__FILE__</span><span class="p">)</span><span class="o">.</span><span class="s1">&#39;/atom2rss.xsl&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="nv">$chan</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DOMDocument</span><span class="p">();</span>
</span><span class='line'>    <span class="nv">$chan</span><span class="o">-&gt;</span><span class="na">load</span><span class="p">(</span><span class="nv">$source</span><span class="p">);</span>
</span><span class='line'>    <span class="nv">$sheet</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DOMDocument</span><span class="p">();</span>
</span><span class='line'>    <span class="nv">$sheet</span><span class="o">-&gt;</span><span class="na">load</span><span class="p">(</span><span class="nv">$atom2rssXsl</span><span class="p">);</span>
</span><span class='line'>    <span class="nv">$processor</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XSLTProcessor</span><span class="p">();</span>
</span><span class='line'>    <span class="nv">$processor</span><span class="o">-&gt;</span><span class="na">registerPHPFunctions</span><span class="p">();</span>
</span><span class='line'>    <span class="nv">$processor</span><span class="o">-&gt;</span><span class="na">importStylesheet</span><span class="p">(</span><span class="nv">$sheet</span><span class="p">);</span>
</span><span class='line'>    <span class="nb">date_default_timezone_set</span><span class="p">(</span><span class="s2">&quot;Asia/Shanghai&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="nv">$result</span> <span class="o">=</span> <span class="nv">$processor</span><span class="o">-&gt;</span><span class="na">transformToXML</span><span class="p">(</span><span class="nv">$chan</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">strlen</span><span class="p">(</span><span class="nv">$result</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>      <span class="nb">file_put_contents</span><span class="p">(</span><span class="nv">$toFile</span><span class="p">,</span> <span class="nv">$result</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="cp">?&gt;</span><span class="x"></span>
</span></code></pre></td></tr></table></div></figure>


<p>主要依赖的就是进行转换的atom2rss.xml规则。
上述代码可以根据自己的需要设置时区。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby执行shell命令的六种方法]]></title>
    <link href="http://droidyue.com/blog/2014/11/18/six-ways-to-run-shell-in-ruby/"/>
    <updated>2014-11-18T21:17:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/18/six-ways-to-run-shell-in-ruby</id>
    <content type="html"><![CDATA[<p>在Ruby中，执行shell命令是一件不奇怪的事情，Ruby提供了大概6种方法供开发者进行实现。这些方法都很简单，本文将具体介绍一下如何在Ruby脚本中进行调用终端命令。</p>

<!--more-->


<h2>exec</h2>

<p>exec会将指定的命令替换掉当前进程中的操作,指定命令结束后，进程结束。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">exec</span> <span class="s1">&#39;echo &quot;hello world&quot;&#39;</span>
</span><span class='line'><span class="nb">print</span> <span class="s1">&#39;abc&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行上述的命令，结果如下，我们可以看到没有abc的输出，可以看出来，在执行<code>echo "hello world"</code>命令后进程就结束了。不会继续执行后面的<code>print 'abc'</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">ruby</span> <span class="n">testCommand</span><span class="o">.</span><span class="n">rb</span>
</span><span class='line'><span class="n">hello</span> <span class="n">world</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用exec一个头疼的事情就是没有办法知道shell命令执行成功还是失败。</p>

<h2>system</h2>

<p>system和exec相似，但是system执行的命令不会是在当前进程，而是在一个新创建的进程。system会返回布尔值来表明命令执行结果是成功还是失败。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="err">$</span> <span class="n">irb</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nb">system</span> <span class="s1">&#39;echo &quot;hello $HOSTNAME&quot;&#39;</span>
</span><span class='line'><span class="n">hello</span> <span class="n">androidyue</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="kp">true</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nb">puts</span> <span class="vg">$?</span>
</span><span class='line'><span class="n">pid</span> <span class="mi">11845</span> <span class="nb">exit</span> <span class="mi">0</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="kp">nil</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nb">system</span> <span class="s1">&#39;false&#39;</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="kp">false</span>
</span><span class='line'><span class="o">&gt;</span> <span class="nb">puts</span> <span class="vg">$?</span>
</span><span class='line'><span class="n">pid</span> <span class="mi">11858</span> <span class="nb">exit</span> <span class="mi">1</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="kp">nil</span>
</span><span class='line'><span class="o">&gt;&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>system会将进程的退出的状态码赋值给$?，如果程序正常退出，$?的值为0，否则为非0。通过检测退出的状态码我们可以在ruby脚本中抛出异常或者进行重试操作。</p>

<p>注：在Unix-like系统中进程的退出状态码以0和非0表示，0代表成功，非0代表失败。</p>

<p>system可以告诉我们命令执行是成功还是失败，但是有些时候我们需要得到执行命令的输出，并在脚本中使用。显然system无法直接满足，需要我们使用反引号来实现。</p>

<h2>反引号(`)</h2>

<p>使用反引号是shell中常用的获取命令输出内容的方法，在ruby中也是可以，而且一点都需要做改变。使用反引号执行命令也会将命令在另一个进程中执行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p448</span> <span class="p">:</span><span class="mo">013</span> <span class="o">&gt;</span> <span class="n">today</span> <span class="o">=</span> <span class="sb">`date`</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="s2">&quot;Sat Nov 15 19:28:55 CST 2014</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p448</span> <span class="p">:</span><span class="mo">014</span> <span class="o">&gt;</span> <span class="vg">$?</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="c1">#&lt;Process::Status: pid 11925 exit 0&gt; </span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p448</span> <span class="p">:</span><span class="mo">015</span> <span class="o">&gt;</span> <span class="vg">$?</span><span class="o">.</span><span class="n">to_i</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="mi">0</span>
</span><span class='line'><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p448</span> <span class="p">:</span><span class="mo">016</span> <span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的方法如此简单，我们可以直接对返回的字符串结果进行操作。</p>

<p>注意，$?已经不再是上述的那样单纯的退出状态码了，它实际上是一个Process::Status对象。我们从中不仅可以知道进程的退出状态码也可以知道进程的ID。使用<code>$?.to_i</code>会得到退出的状态码，使用<code>$?.to_s</code>会得到包含了进程id，退出状态码等信息的字符串。</p>

<p>使用反引号的一个结果就是我们只能得到标准的输出（stdout）而不能得到标准的错误信息(stderr),比如下面的例子，我们执行一个输出错误字符串的perl脚本。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="err">$</span> <span class="n">irb</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="n">warning</span> <span class="o">=</span> <span class="sb">`perl -e &quot;warn &#39;dust in the wind&#39;&quot;`</span>
</span><span class='line'>  <span class="n">dust</span> <span class="k">in</span> <span class="n">the</span> <span class="n">wind</span> <span class="n">at</span> <span class="o">-</span><span class="n">e</span> <span class="n">line</span> <span class="mi">1</span><span class="o">.</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="s2">&quot;&quot;</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="nb">puts</span> <span class="n">warning</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="kp">nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出，warning并没有得到出错的信息，这就表明反引号无法得到标准错误的信息。</p>

<h2>IO#popen</h2>

<p>IO#popen也是一种执行命令的方法,其命令也是在另外的进程中执行。使用popen你可以像操作IO对象一样处理标准输入和输出。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="err">$</span> <span class="n">irb</span>
</span><span class='line'><span class="o">&gt;&gt;</span> <span class="no">IO</span><span class="o">.</span><span class="n">popen</span><span class="p">(</span><span class="s2">&quot;date&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="nb">puts</span> <span class="n">f</span><span class="o">.</span><span class="n">gets</span> <span class="p">}</span>
</span><span class='line'><span class="no">Mon</span> <span class="no">Mar</span> <span class="mi">12</span> <span class="mi">18</span><span class="p">:</span><span class="mi">58</span><span class="p">:</span><span class="mi">56</span> <span class="no">PDT</span> <span class="mi">2007</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="kp">nil</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Open3#popen3</h2>

<p>在标准的Ruby库中还提供了一个Open3。使用这个类我们可以很容易的对标准输入，输出，错误进行处理。这里我们使用一个可以交互的工具dc。dc是一种逆波兰表达式（又叫做后缀表达式，每一运算符都置于其运算对象之后）的计算器，支持从标准输入读取数学表达式。在这个例子中，我们将两个数值和一个操作符进行压栈处理。然后使用p来输出结果。比如我们输入5和10，然后输入+，然后会得到15\n的输出。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="err">$</span> <span class="n">irb</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="n">stdin</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="no">Open3</span><span class="o">.</span><span class="n">popen3</span><span class="p">(</span><span class="s1">&#39;dc&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="o">[</span><span class="c1">#&lt;IO:0x6e5474&gt;, #&lt;IO:0x6e5438&gt;, #&lt;IO:0x6e53d4&gt;]</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="n">stdin</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="kp">nil</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="n">stdin</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="kp">nil</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="n">stdin</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="kp">nil</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="n">stdin</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="kp">nil</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="n">stdout</span><span class="o">.</span><span class="n">gets</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="s2">&quot;15</span><span class="se">\n</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用这个方法，我们不仅可以读取到命令的输出还可以对命令进行输入操作。这个方法对于进行交互操作很方便。通过popen3，我们还可以得到标准的错误信息。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="c1"># (irb continued...)</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="n">stdin</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="s2">&quot;asdfasdfasdfasdf&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="kp">nil</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="n">stderr</span><span class="o">.</span><span class="n">gets</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="s2">&quot;dc: stack empty</span><span class="se">\n</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是，在ruby 1.8.5中popen3有一个缺陷，进程的退出状态没有写入到$?中。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="err">$</span> <span class="n">irb</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="nb">require</span> <span class="s2">&quot;open3&quot;</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="kp">true</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="n">stdin</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="no">Open3</span><span class="o">.</span><span class="n">popen3</span><span class="p">(</span><span class="s1">&#39;false&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="o">[</span><span class="c1">#&lt;IO:0x6f39c0&gt;, #&lt;IO:0x6f3984&gt;, #&lt;IO:0x6f3920&gt;]</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="vg">$?</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="c1">#&lt;Process::Status: pid=26285,exited(0)&gt;</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="vg">$?</span><span class="o">.</span><span class="n">to_i</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure>


<p>为什么是0，false命令执行后的退出状态应该是非0才对，由于这个缺陷，我们需要了解一下Open4</p>

<h2>Open4#popen4</h2>

<p>Open4#popen4使用起来和Open3#popen3差不多，而且我们也可以得到程序的退出状态。popen4还可以返回一个子进程ID。你也可以通过Process::waitpid2 加上对应的进程ID获得进程退出状态。但是前提是要安装open4的gem。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="err">$</span> <span class="n">irb</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="nb">require</span> <span class="s2">&quot;open4&quot;</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="kp">true</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="n">pid</span><span class="p">,</span> <span class="n">stdin</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="ss">Open4</span><span class="p">:</span><span class="ss">:popen4</span> <span class="s2">&quot;false&quot;</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">26327</span><span class="p">,</span> <span class="c1">#&lt;IO:0x6dff24&gt;, #&lt;IO:0x6dfee8&gt;, #&lt;IO:0x6dfe84&gt;]</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="vg">$?</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="kp">nil</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="n">pid</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="mi">26327</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="n">ignored</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="ss">Process</span><span class="p">:</span><span class="ss">:waitpid2</span> <span class="n">pid</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">26327</span><span class="p">,</span> <span class="c1">#&lt;Process::Status: pid=26327,exited(1)&gt;]</span>
</span><span class='line'>  <span class="o">&gt;&gt;</span> <span class="n">status</span><span class="o">.</span><span class="n">to_i</span>
</span><span class='line'>  <span class="o">=&gt;</span> <span class="mi">256</span>
</span></code></pre></td></tr></table></div></figure>


<h2>原文</h2>

<ul>
<li><a href="http://tech.natemurray.com/2007/03/ruby-shell-commands.html">http://tech.natemurray.com/2007/03/ruby-shell-commands.html</a></li>
<li>在原文基础上，进行了部分删减。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[译文：理解Android中垃圾回收日志信息]]></title>
    <link href="http://droidyue.com/blog/2014/11/08/understanding-garbage-collection-output-messages-in-android/"/>
    <updated>2014-11-08T18:16:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/08/understanding-garbage-collection-output-messages-in-android</id>
    <content type="html"><![CDATA[<p>如果你是一名Android开发者并且常常看程序日志的话，那么下面的这些信息对你来说可能一点都不陌生。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">GC_CONCURRENT</span> <span class="n">freed</span> <span class="mi">178</span><span class="n">K</span><span class="o">,</span> <span class="mi">41</span><span class="o">%</span> <span class="n">free</span> <span class="mi">3673</span><span class="n">K</span><span class="o">/</span><span class="mi">6151</span><span class="n">K</span><span class="o">,</span> <span class="n">external</span> <span class="mi">0</span><span class="n">K</span><span class="o">/</span><span class="mi">0</span><span class="n">K</span><span class="o">,</span> <span class="n">paused</span> <span class="mi">2</span><span class="n">ms</span><span class="o">+</span><span class="mi">2</span><span class="n">ms</span>
</span><span class='line'><span class="n">GC_EXPLICIT</span> <span class="n">freed</span> <span class="mi">6</span><span class="n">K</span><span class="o">,</span> <span class="mi">41</span><span class="o">%</span> <span class="n">free</span> <span class="mi">3667</span><span class="n">K</span><span class="o">/</span><span class="mi">6151</span><span class="n">K</span><span class="o">,</span> <span class="n">external</span> <span class="mi">0</span><span class="n">K</span><span class="o">/</span><span class="mi">0</span><span class="n">K</span><span class="o">,</span> <span class="n">paused</span> <span class="mi">29</span><span class="n">ms</span>
</span><span class='line'><span class="n">GC_CONCURRENT</span> <span class="n">freed</span> <span class="mi">379</span><span class="n">K</span><span class="o">,</span> <span class="mi">42</span><span class="o">%</span> <span class="n">free</span> <span class="mi">3856</span><span class="n">K</span><span class="o">/</span><span class="mi">6535</span><span class="n">K</span><span class="o">,</span> <span class="n">external</span> <span class="mi">0</span><span class="n">K</span><span class="o">/</span><span class="mi">0</span><span class="n">K</span><span class="o">,</span> <span class="n">paused</span> <span class="mi">2</span><span class="n">ms</span><span class="o">+</span><span class="mi">3</span><span class="n">ms</span>
</span><span class='line'><span class="n">GC_EXPLICIT</span> <span class="n">freed</span> <span class="mi">144</span><span class="n">K</span><span class="o">,</span> <span class="mi">41</span><span class="o">%</span> <span class="n">free</span> <span class="mi">3898</span><span class="n">K</span><span class="o">/</span><span class="mi">6535</span><span class="n">K</span><span class="o">,</span> <span class="n">external</span> <span class="mi">0</span><span class="n">K</span><span class="o">/</span><span class="mi">0</span><span class="n">K</span><span class="o">,</span> <span class="n">paused</span> <span class="mi">32</span><span class="n">ms</span>
</span><span class='line'><span class="n">GC_CONCURRENT</span> <span class="n">freed</span> <span class="mi">334</span><span class="n">K</span><span class="o">,</span> <span class="mi">40</span><span class="o">%</span> <span class="n">free</span> <span class="mi">4091</span><span class="n">K</span><span class="o">/</span><span class="mi">6727</span><span class="n">K</span><span class="o">,</span> <span class="n">external</span> <span class="mi">0</span><span class="n">K</span><span class="o">/</span><span class="mi">0</span><span class="n">K</span><span class="o">,</span> <span class="n">paused</span> <span class="mi">2</span><span class="n">ms</span><span class="o">+</span><span class="mi">3</span><span class="n">ms</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是这些到底是什么，又有什么含义呢？</p>

<!--more-->


<p>上面的这几行就是Android系统垃圾回收的部分输出信息。每当垃圾回收被触发的时候，你就可以通过logcat查看到这样的信息。这样短短的一行的日志有着很大的信息量。比如通过日志我们可以发现程序可能有内存（泄露）问题。本文将具体介绍这些日志信息的每一部分的含义来帮助帮助大家更好地了解垃圾回收的运行情况。</p>

<h2>原因</h2>

<p><font color="red">GC_CONCURRENT</font> freed 178K, 41% free 3673K/6151K, external 0K/0K, paused 2ms+2ms <br/>
<font color="red">GC_EXPLICIT</font> freed 6K, 41% free 3667K/6151K, external 0K/0K, paused 29ms</p>

<p>红颜色标出的部分就是垃圾回收触发的原因。在Android中有五种类型的垃圾回收触发原因。</p>

<ul>
<li><strong>GC_CONCURRENT</strong> 当堆内存增长到一定程度时会触发。此时触发可以对堆中的没有用的对象及时进行回收，腾出空间供新的对象申请，避免进行不必要的增大堆内存的操作。</li>
<li><strong>GC_EXPLICIT</strong>   当程序中调用System.gc()方法触发。这个方法应避免出现在程序中调用。因为JVM有足够的能力来控制垃圾回收。</li>
<li><strong>GC_EXTERNAL_MALLOC</strong> 当Bitmap和NIO Direct ByteBuffer对象分配外部存储（机器内存，非Dalvik堆内存）触发。这个日志只有在2.3之前存在，从2.3系统开始，垃圾回收进行了调整，前面的对象都会存储到Dalivik堆内存中。所以在2.3系统之后，你就再也不会看到这种信息了。</li>
<li><strong>GC_FOR_MALLOC</strong> 当堆内存已满，系统需要更多内存的时候触发。这条日志出现后意味着JVM要暂停你的程序进行垃圾回收操作。</li>
<li><strong>GC_HPROF_DUMP_HEAP</strong> 当创建一个内存分析文件HPROF时触发。</li>
</ul>


<h2>结果</h2>

<p>GC_CONCURRENT <font color="red">freed 178K</font>, 41% free 3673K/6151K, external 0K/0K, paused 2ms+2ms <br/>
GC_EXPLICIT <font color="red">freed 6K</font>, 41% free 3667K/6151K, external 0K/0K, paused 29ms</p>

<p>这部分数据告诉我们JVM进行垃圾回收释放了多少空间。</p>

<h2>堆内存数据</h2>

<p>GC_CONCURRENT freed 178K, <font color="red">41% free 3673K/6151K</font>, external 0K/0K, paused 2ms+2ms <br/>
GC_EXPLICIT freed 6K, <font color="red">41% free 3667K/6151K</font>, external 0K/0K, paused 29ms</p>

<p>这部分告诉我们堆内存中可用内存占的比例，当前活跃的对象总的空间，以及当前堆的总大小。所以这里的数据就是41%的堆内存可用，已经使用了3673K，总的堆内存大小为6151K。</p>

<h2>外部存储数据</h2>

<p>GC_EXTERNAL_ALLOC freed 1125K, 47% free 6310K/11847K,  <font color="red">external 1051K/1103K</font>, paused 46ms<br/>
GC_EXTERNAL_ALLOC freed 295K, 47% free 6335K/11847K,  <font color="red">external 1613K/1651K</font>, paused 41ms</p>

<p>这部分数据告诉我们外部存储（位于机器内存）对象的数据。在2.3之前，bitmap对象存放在机器内存。因此在第一条数据中我们可以看到以有1051K使用，外部存储为1103K。</p>

<p>上面两行数据相差100毫秒，我们可以看到第一条数据表明外部存储快满了，由于GC_EXTERNAL_ALLOC被触发，外部存储空间扩大到了1651K。</p>

<h2>垃圾回收暂停时间</h2>

<p>GC_CONCURRENT freed 178K, 41% free 3673K/6151K, external 0K/0K, <font color="red">paused 2ms+2ms</font> <br/>
GC_EXPLICIT freed 6K, 41% free 3667K/6151K, external 0K/0K, <font color="red">paused 29ms</font></p>

<p>这部分数据表明垃圾回收消耗的时间。在GC_CONCURRENT回收时，你会发现两个暂停时间。一个是在回收开始的暂停时间，另一个时在回收结束的暂停时间。GC_CONCURRENT从2.3开始引入，相比之前的程序全部暂停的垃圾回收机制，它的暂停时间要小的多。一般少于5毫秒。因为GC_CONCURRENT的绝大多数操作在一个单独的线程中进行。</p>

<p>本文中内容摘自 Google I/O 2011: Memory management for Android Apps，如果感兴趣，请访问<a href="http://droidyue.com/blog/2014/11/02/note-for-google-io-memory-management-for-android-chinese-edition/">这里</a>了解更多。</p>

<h2>原文地址</h2>

<p><a href="https://sites.google.com/site/pyximanew/blog/androidunderstandingddmslogcatmemoryoutputmessages">https://sites.google.com/site/pyximanew/blog/androidunderstandingddmslogcatmemoryoutputmessages</a></p>

<h2>其他</h2>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B009VV6EG8/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009VV6EG8&linkCode=as2&tag=droidyue-23">Android应用性能优化</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009VV6EG8" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[啰嗦一下android中的NetworkOnMainThreadException]]></title>
    <link href="http://droidyue.com/blog/2014/11/08/look-into-android-dot-os-dot-networkonmainthreadexception/"/>
    <updated>2014-11-08T15:26:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/08/look-into-android-dot-os-dot-networkonmainthreadexception</id>
    <content type="html"><![CDATA[<p>相信很多Android开发者很多都遇到过android.os.NetworkOnMainThreadException 这个异常，意思就是主线程进行网络操作异常。这个问题比较简单，但是网络上有着鱼龙混杂的答案，这里想花点时间做一个比较完整的描述。</p>

<!--more-->


<h2>严格模式</h2>

<p>在早期的Android版本（2.3之前）中，Google并没有提供一个很严格的程序编写要求，所以在那时我们可以在主线程中执行本地IO操作，网络操作等这些不规范的行为。后来在2.3的姜饼（GINGERBREAD）开始提供了一个开发者工具，这就是StrictMode严格模式。</p>

<p>严格模式可以帮助开发者发现主线程中的磁盘操作和网络操作，开发者根据严格模式的输出信息可以改善程序来更好地响应用户操作，来较少ANR（程序未响应）的问题。</p>

<p>android.os.NetworkOnMainThreadException这个异常从Android 3.0（API 11）引入，出现情况为主线程进行网络操作。</p>

<h3>代码开启StrictMode</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">Build</span><span class="o">.</span><span class="na">VERSION</span><span class="o">.</span><span class="na">SDK_INT</span> <span class="o">&gt;=</span> <span class="n">VERSION_CODES</span><span class="o">.</span><span class="na">GINGERBREAD</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">ThreadPolicy</span><span class="o">.</span><span class="na">Builder</span> <span class="n">threadPolicyBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StrictMode</span><span class="o">.</span><span class="na">ThreadPolicy</span><span class="o">.</span><span class="na">Builder</span><span class="o">();</span>
</span><span class='line'>  <span class="n">threadPolicyBuilder</span><span class="o">.</span><span class="na">detectDiskReads</span><span class="o">().</span><span class="na">detectDiskWrites</span><span class="o">().</span><span class="na">detectNetwork</span><span class="o">().</span><span class="na">penaltyLog</span><span class="o">();</span>
</span><span class='line'>  <span class="n">StrictMode</span><span class="o">.</span><span class="na">setThreadPolicy</span><span class="o">(</span><span class="n">threadPolicyBuilder</span><span class="o">.</span><span class="na">build</span><span class="o">());</span>
</span><span class='line'>  <span class="n">VmPolicy</span><span class="o">.</span><span class="na">Builder</span> <span class="n">vmPolicyBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">VmPolicy</span><span class="o">.</span><span class="na">Builder</span><span class="o">();</span>
</span><span class='line'>  <span class="n">vmPolicyBuilder</span><span class="o">.</span><span class="na">detectLeakedSqlLiteObjects</span><span class="o">().</span><span class="na">penaltyLog</span><span class="o">();</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">Build</span><span class="o">.</span><span class="na">VERSION</span><span class="o">.</span><span class="na">SDK_INT</span> <span class="o">&gt;=</span> <span class="n">VERSION_CODES</span><span class="o">.</span><span class="na">HONEYCOMB</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">vmPolicyBuilder</span><span class="o">.</span><span class="na">detectLeakedClosableObjects</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">StrictMode</span><span class="o">.</span><span class="na">setVmPolicy</span><span class="o">(</span><span class="n">vmPolicyBuilder</span><span class="o">.</span><span class="na">build</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>特别注意</h3>

<ul>
<li>严格模式不应该在发布版本时开启</li>
</ul>


<h2>治标不治本的办法</h2>

<p>下面的这段代码会让严格模式允许所有的磁盘操作和网络操作。但是这并没有改变真正解决问题，主线程中照样还是有网络操作，可能导致程序出现未响应的情况。所以这是一个很糟糕的解决方法，问题的解决思路应该是将网络操作移到非主线程进行，而不是这种掩耳盗铃的做法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">StrictMode</span><span class="o">.</span><span class="na">ThreadPolicy</span> <span class="n">policy</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StrictMode</span><span class="o">.</span><span class="na">ThreadPolicy</span><span class="o">.</span><span class="na">Builder</span><span class="o">().</span><span class="na">permitAll</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
</span><span class='line'><span class="n">StrictMode</span><span class="o">.</span><span class="na">setThreadPolicy</span><span class="o">(</span><span class="n">policy</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>p.s. 这个很笨的方法居然在Stackoverflow上有很多人认为有用，难以理解。</p>

<h2>AsyncTask也不好</h2>

<p>先实现一个我们用来测试的请求网络的方法</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">doGetRequest</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">HttpGet</span> <span class="n">method</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HttpGet</span><span class="o">(</span><span class="s">&quot;http://droidyue.com&quot;</span><span class="o">);</span>
</span><span class='line'>      <span class="n">AbstractHttpClient</span> <span class="n">http</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DefaultHttpClient</span><span class="o">();</span>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">HttpResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
</span><span class='line'>          <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">LOGTAG</span><span class="o">,</span> <span class="s">&quot;doGetRequest responseCode=&quot;</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">getStatusLine</span><span class="o">().</span><span class="na">getStatusCode</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;; ThreadInfo=&quot;</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClientProtocolException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用AsyncTask可以将网络操作移到了AsyncTask的线程，可以避免NetworkOnMainThreadException异常。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">new</span> <span class="n">AsyncTask</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Void</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">protected</span> <span class="n">Void</span> <span class="nf">doInBackground</span><span class="o">(</span><span class="n">Void</span><span class="o">...</span> <span class="n">params</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">doGetRequest</span><span class="o">();</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}.</span><span class="na">execute</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<h3>AsyncTask的弊端</h3>

<ul>
<li>上述AsyncTask为一个匿名内部类的对象,由于Java中非static内部类实例会持有外部类实例的引用,AsyncTask实例持有Activity的引用,这样很容易引起内存泄露</li>
<li>按照Android官方文档支出,AsyncTask被推荐为处理短时间(10秒以内)的操作,即本地的轻量IO操作.不适合使用网络这样时间不定的操作.</li>
</ul>


<p>更详细的关于AsyncTask请参考<a href="http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android/">Android中糟糕的AsyncTask</a></p>

<h2>这样也不好</h2>

<p>既然AsyncTask可能导致内存泄露并且不适用于长时间操作,那么这样呢</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">new</span> <span class="nf">Thread</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="kd">super</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
</span><span class='line'>      <span class="n">doGetRequest</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}.</span><span class="na">start</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样还是不够好,虽然单独线程可以处理长时间的操作,但是问题还是依旧</p>

<ul>
<li>内存泄露问题依旧可能存在</li>
<li>如果多次重复进行这样的操作,每次重新创建新的Thread不好.</li>
</ul>


<h2>解决上述两处内部类可能引起的内存泄露问题</h2>

<ul>
<li>将AsyncTask或者Thread的子类作为单独的文件,不持有Activity的强引用</li>
<li>将AsyncTask或者Thread的子类使用static修饰,则不会隐式持有Activity的强引用</li>
<li>如果是匿名内部类，则需要将其对象设置成成员属性，使用static修饰就不会隐式持有Activity的强引用。</li>
</ul>


<h2>解决问题哪家强</h2>

<p>解决了上述的内存泄露基本可以做到比较完美的实现,或者使用Loaders实现也不错。关于线程重用问题，可以使用Executors.newSingleThreadExecutor()来解决。具体方案因情况而定。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[译文：Android中糟糕的AsyncTask]]></title>
    <link href="http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android/"/>
    <updated>2014-11-08T14:33:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android</id>
    <content type="html"><![CDATA[<p>AsyncTask是一个很常用的API，尤其异步处理数据并将数据应用到视图的操作场合。其实AsyncTask并不是那么好，甚至有些糟糕。本文我会讲AsyncTask会引起哪些问题，如何修复这些问题，并且关于AsyncTask的一些替代方案。</p>

<h2>AsyncTask</h2>

<p>从Android API 3（1.5 Cupcake）开始，AsyncTask被引入用来帮助开发者更简单地管理线程。实际上在Android 1.0和1.1也是有类似的实现，那就是UserTask。UserTask和AsyncTask有着相同的API及实现，但是由于由于1.0和1.1的设备份额微乎其微，这里的概念就不会涉及到UserTask。</p>

<!--more-->


<h2>生命周期</h2>

<p>关于AsyncTask存在一个这样广泛的误解，很多人认为一个在Activity中的AsyncTask会随着Activity的销毁而销毁。然后事实并非如此。AsyncTask会一直执行doInBackground()方法直到方法执行结束。一旦上述方法结束，会依据情况进行不同的操作。</p>

<ul>
<li>如果cancel(boolean)调用了，则执行onCancelled(Result)方法</li>
<li>如果cancel(boolean)没有调用，则执行onPostExecute(Result)方法</li>
</ul>


<p>AsyncTask的cancel方法需要一个布尔值的参数，参数名为mayInterruptIfRunning,意思是<code>如果正在执行是否可以打断</code>,如果这个值设置为true，表示这个任务可以被打断，否则，正在执行的程序会继续执行直到完成。如果在doInBackground()方法中有一个循环操作，我们应该在循环中使用isCancelled()来判断，如果返回为true，我们应该避免执行后续无用的循环操作。</p>

<p>总之，我们使用AsyncTask需要确保AsyncTask正确地取消。</p>

<h2>不好好工作的cancel()</h2>

<p>简而言之的答案，<strong>有时候起作用</strong>。</p>

<p>如果你调用了AsyncTask的cancel(false)，doInBackground()仍然会执行到方法结束，只是不会去调用onPostExecute()方法。但是实际上这是让应用程序执行了没有意义的操作。那么是不是我们调用cancel(true)前面的问题就能解决呢？并非如此。如果mayInterruptIfRunning设置为true，会使任务尽早结束，但是如果的doInBackground()有不可打断的方法会失效，比如这个BitmapFactory.decodeStream() IO操作。但是你可以提前关闭IO流并捕获这样操作抛出的异常。但是这样会使得cancel()方法没有任何意义。</p>

<h2>内存泄露</h2>

<p>还有一种常见的情况就是，在Activity中使用非静态匿名内部AsyncTask类，由于Java内部类的特点，AsyncTask内部类会持有外部类的隐式引用。详细请参考<a href="http://droidyue.com/blog/2014/10/02/the-private-modifier-in-java/">细话Java：&#8221;失效&#8221;的private修饰符</a>,由于AsyncTask的生命周期可能比Activity的长，当Activity进行销毁AsyncTask还在执行时，由于AsyncTask持有Activity的引用，导致Activity对象无法回收，进而产生内存泄露。</p>

<h2>结果丢失</h2>

<p>另一个问题就是在屏幕旋转等造成Activity重新创建时AsyncTask数据丢失的问题。当Activity销毁并创新创建后，还在运行的AsyncTask会持有一个Activity的非法引用即之前的Activity实例。导致onPostExecute()没有任何作用。</p>

<h2>串行还是并行</h2>

<p>关于AsyncTask时串行还是并行有很多疑问，这很正常，因为它经过多次的修改。如果你并不明白什么时串行还是并行，可以通过接下来的例子了解，假设我们在一个方法体里面有如下两行代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">new</span> <span class="nf">AsyncTask1</span><span class="o">().</span><span class="na">execute</span><span class="o">();</span>
</span><span class='line'><span class="k">new</span> <span class="nf">AsyncTask2</span><span class="o">().</span><span class="na">execute</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的两个任务时同时执行呢，还是AsyncTask1执行结束之后，AsyncTask2才能执行呢？实际上是结果依据API不同而不同。</p>

<h3>在1.6(Donut)之前:</h3>

<p>在第一版的AsyncTask，任务是串行调度。一个任务执行完成另一个才能执行。由于串行执行任务，使用多个AsyncTask可能会带来有些问题。所以这并不是一个很好的处理异步（尤其是需要将结果作用于UI试图）操作的方法。</p>

<h3>从1.6到2.3(Gingerbread)</h3>

<p>后来Android团队决定让AsyncTask并行来解决1.6之前引起的问题，这个问题是解决了，新的问题又出现了。很多开发者实际上依赖于顺序执行的行为。于是很多并发的问题蜂拥而至。</p>

<h3>3.0（Honeycomb）到现在</h3>

<p>好吧，开发者可能并不喜欢让AsyncTask并行，于是Android团队又把AsyncTask改成了串行。当然这一次的修改并没有完全禁止AsyncTask并行。你可以通过设置executeOnExecutor(Executor)来实现多个AsyncTask并行。关于API文档的描述如下</p>

<blockquote><p>If we want to make sure we have control over the execution, whether it will run serially or parallel, we can check at runtime with this code to make sure it runs parallel:</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">AsyncTask</span> <span class="n">as</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">Build</span><span class="o">.</span><span class="na">VERSION</span><span class="o">.</span><span class="na">SDK_INT</span> <span class="o">&lt;=</span> <span class="n">Build</span><span class="o">.</span><span class="na">VERSION_CODES</span><span class="o">.</span><span class="na">HONEYCOMB_MR1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">as</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">as</span><span class="o">.</span><span class="na">executeOnExecutor</span><span class="o">(</span><span class="n">AsyncTask</span><span class="o">.</span><span class="na">THREAD_POOL_EXECUTOR</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="c1">//(This code does not work for API lvl 1 to 3)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>真的需要AsyncTask么</h2>

<p>并非如此，使用AsyncTask虽然可以以简短的代码实现异步操作，但是正如本文提到的，你需要让AsyncTask正常工作的话，需要注意很多条条框框。推荐的一种进行异步操作的技术就是使用Loaders。这个方法从Android 3.0 (Honeycomb)开始引入，在android支持包中也有包含。可以通过查看官方的文档来详细了解<a href="http://developer.android.com/guide/components/loaders.html">Loaders</a>。</p>

<p>本次译文对原文有少部分删减修改处理。</p>

<h2>引用推荐</h2>

<ul>
<li><a href="http://bon-app-etit.blogspot.hk/2013/04/the-dark-side-of-asynctask.html">原文地址(墙外的 Orz)</a></li>
<li><a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.4.4_r1/android/os/AsyncTask.java#AsyncTask">Grepcode AsyncTsk 源码参考</a></li>
<li><a href="http://blog.danlew.net/2014/06/21/the-hidden-pitfalls-of-asynctask/">另一篇介绍AsyncTask陷阱的文章</a></li>
<li><a href="http://www.amazon.cn/gp/product/B009OLU8EE/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009OLU8EE&linkCode=as2&tag=droidyue-23">罗升阳的Android系统源代码情景分析</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009OLU8EE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google IO：Android内存管理主题演讲记录]]></title>
    <link href="http://droidyue.com/blog/2014/11/02/note-for-google-io-memory-management-for-android-chinese-edition/"/>
    <updated>2014-11-02T14:44:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/02/note-for-google-io-memory-management-for-android-chinese-edition</id>
    <content type="html"><![CDATA[<p>翻出了3年前的Google IO大会的主题演讲  <strong>Google IO 2011 Memory management for Android Apps</strong>，该演讲介绍了Android系统在垃圾回收上的变化和如何发现并内存泄露以及如何管理Android中的内存。本演讲对开发者还是有很大的帮助。</p>

<p>目前全文内容为英文，但是大部分很容易理解。以下内容在原有基础上，进行了分段整理,更加便于阅读。</p>

<!--more-->


<h2>视频</h2>

<iframe height=498 width=510 src="http://player.youku.com/embed/XMzI3NDA5MzQ4" frameborder=0 allowfullscreen></iframe>


<h2>演讲全文内容</h2>

<p>  Hi everybody,</p>

<p>  My name’s Patrick Dubroy and today I’m going to talk to you about memory management for Android. So I’m really happy to see so
many people here who care about memory management, especially near the end of the day.</p>

<p>  So let’s get started. So I’m sure you all remember this device. This is the T-Mobile G1. Hugo talked about it in the keynote yesterday. It was released about two and a half years ago. So, is there anybody here who actually developed on the G1? All right, impressive. That’s about maybe
40% of the room. So you may remember that the G1 came with 192 megabytes of RAM. And in fact, most of that was used up by the system. There wasn’t a whole lot left over for apps.</p>

<p>  Fast forward a few years later, we have the Motorola Xoom released just a couple of months ago. The Xoom comes with a gigabyte of RAM. Now some people might hear this and think, OK, my troubles are over. I never have to worry about memory management again. And of course, given that we have a whole room here, you guys are all smart people and you realize that that’s not true. And there are a couple of reasons for this. First of all, the Xoom has six and a half times the resolution that the G1 had. So you’ve got six and a half times as many pixels on screen. That means you’re probably
going to need to use more memory. You got more bitmaps for example. The other thing is that on tablets, you really want to create a new kind
of application. You know, the rich, immersive applications, like this YouTube app, for example. These are going to take a lot of memory. There’s tons of bitmaps in here. Those use up a lot of memory. Also, the Xoom we’re talking about a pretty new device. This is basically bleeding edge hardware. Most your customers are not going to be using something that’s only two months old. So of course, you want to support people who are using older hardware as well.</p>

<p>  Finally, maybe you’re all familiar with Parkinson’s Law, which says that work always take as much time as you have. And really, it’s kind of the same for software. So, no matter how much memory you have, you’re going to find a way to use it and wish you had just a little bit more.</p>

<p>  What I want to talk about today are basically two different things. First of all, I want to cover some of the changes that we’ve made in Gingerbread and Honeycomb that affect how your app uses memory. That’s your cameo. All right, so as I was saying, there are two different things I want to cover today. So first of all, I want to talk about some of the changes we’ve made in Gingerbread and Honeycomb that affect how your apps use memory. And basically, memory management in general. In the second half of the talk I want to talk about some tools you can use to better understand how your app is using memory. And if you have memory leaks,how you can figure out where those memory leaks are.</p>

<p>  So just to set expectations for this talk, I’m going to make them some assumptions about the stuff you’ve done and it’ll really help you get the most out of this if you’re familiar with these concepts. So I’m hoping that you’ve all written Android apps before. And it looked like about half the room had developed on the G1, so that’s probably true. I hope that most of you have heard of the Dalvik heap. You have a basic idea of what I’m talking about when I talk about heap memory. I’m sure you’re familiar with the garbage collector. You have a basic idea hopefully of what garbage collection is and how it works. And probably, most of you have seen an OutOfMememoryError before and you have a basic idea of why you get it and what you can do to deal with it.</p>

<p>  So first, let’s talk about heap size. So you may know that in Android, there’s a hard limit on your application’s heap size. And there’s a couple reasons for this. So first of all, one of the great features of Android is that it has full multitasking. So you actually have multiple programs running at once. And so obviously, each one can’t use all of your devices memory. We also don’t want a runaway app to just start getting bigger and bigger and bloating the entire system. You always want your dialer to work, your launcher the work, that sort of thing. So there’s this hard limit
on heap size and if your application needs to allocate more memory and you’ve gone up to that heap size limit already,then you’re basically going to get an out of memory error. So this heap size limit is device dependent. It’s changed a lot over the years. On the G1 it was 16 megabytes. On the Xoom it’s now 48 megabytes. So it’s a little bit bigger.</p>

<p>  If you’re writing an app and you want to know, OK, how much heap space do I have available? You know, maybe you want to decide how much stuff to keep in a cache for example. There’s a method you can use in ActivityManager, getMemoryClass that will return an integer value in megabytes, which is your heap size. Now these limits were designed assuming that you know almost any app that you would want to build on Android should be able to fit under
these limits.</p>

<p>  Of course, there are some apps that are really memory intensive. And as I said, on the tablet, we really want to build almost a new class of application. It’s quite a different than the kind of things you were building on phones. So we thought, if someone wants to build an image editor, for example, on the Xoom, they should be able to do that. But an image editor’s a really memory intensive application. It’s unlikely that you could
build a good one that used less than 48 megabytes of heap.
  So in Honeycomb we’ve added a new option that allows applications like this to get a larger heap size. Basically, , you can put something in your AndroidManifest, largeHeap equals true. And that will allow your application to use more heap. And similarly, there’s a
method you can use to determine how much memory you have available to you. The ActivityManager getLargeMemoryClass method again, will return an integer
value of this large heap size.</p>

<p>  Now before we go any further, I want to give a big warning here. You know, this is not something you should be doing just because you got an out of
memory error, or you think that your app deserves a bigger heap. You’re not going to be doing yourself any favors because your app is going to perform
more poorly because bigger heap means you’re going to spend more time at garbage collection. Also, your users are probably going to notice because all their other apps are getting kicked out of memory. It’s really something you want to reserve for when you really understand OK, I’m using tons of memory and I know exactly why I’m using that memory, and I really need to use that memory. That’s the only time that you
should be using this large heap option. So I mentioned garbage collection. And that it takes longer when
you have a bigger heap.
  Let’s talk a little bit about garbage collection. So I just want to go through a quick explanation here of what garbage collection is doing. So basically, you have a set of objects. First of all, let’s say these blue objects here, these are the objects in your heap. And they form a kind of graph. They’ve got references to each other. Some of those objects are alive, some of them are not used anymore. So what the GC does is it starts from a set of objects that we call the roots. These are the objects that the GC knows is alive.</p>

<p>  For example, variables that are alive on a thread stack, J and I global references, we treat objects in the zygote as heap, or as roots as well. So basically, the GC starts with those objects and starts visiting the other objects. And basically, traversing through the whole graph to find out which objects are
referenced directly or indirectly from the GC roots. At the end of this process, you’ve got some objects left over, which the GC never visited. Those are your garbage. They can be collected. So it’s a pretty simple concept. And you can see why when I said that you have bigger heaps you’re going to have larger pause times. Because the garbage collector
basically has to traverse your entire live set of objects. If you’re using say the large heap option and you’ve got 256 megs of heap, well, that’s a lot of memory for the garbage collector to walk over. You’re going to see longer
pause times with that.</p>

<p>  We have some good news though. In Gingerbread, there have been some great changes to the garbage collector that make
things a lot better. So in Gingerbre– sorry, pre-Gingerbread, the state of the garbage collector was that we had to stop
the world collector. So what this means is that basically, when a garbage collection is in progress, your
application is stopped. All your application threads are completely stopped while the collection is proceeding. This is a pretty standard things. These pauses generally tend to be pretty short. What we found was that pause times as heaps were getting bigger, these were getting to be a little bit too long. So we were seeing stuff up 50 to 100 milliseconds. And if you’re trying to build a really responsive app that kind of pause time is not really acceptable.</p>

<p>  So in Gingerbread, we now have a concurrent garbage collector. It does most of its work concurrently, which means that your application is not stopped for the duration of the garbage collection. Basically, we have another thread that’s running at the same time as your application that can perform garbage collection work. You’ll see basically two short pauses. One at the beginning of a collection and one near the end. But these pause times are going to be much, much lower. Usually you’ll see two, three, four, or five milliseconds for your pause time. So that’s a significant improvement. Pause times about 10% of what they used to be. So that’s a really good change that we have in Gingerbread.</p>

<p>  Now if you’re building memory heavy apps, there’s a good chance you’re using a lot of bitmaps. We found that in a lot of apps you have maybe 50 or 75% of your heap is taken up by bitmaps. And in Honeycomb because you’re going to be developing on tablets, this gets even worse. Because your images are bigger to fill the screen. So before Honeycomb, the way we managed bitmaps was this. So the blue area up here is the Dalvik heap and this yellow object is a bitmap object. Now bitmap objects are always the same size in the heap no matter what their resolution is. The backing memory for the bitmap is actually stored in another object. So the pixel data is stored separately. Now before Honeycomb what we did was this pixel data was actually native memory. It was allocated using malloc outside the Dalvik heap. And this had a few consequences. If you wanted to free this memory you could either call recycle, which would free the memory synchronously. But if you didn’t call recycle and you were waiting for your bitmap to get garbage collected,we had to rely on the finalizer to free the backing memory for the bitmap. And if you’re familiar with finalization, you probably know that it’s an inherently unreliable process. Just by its nature it takes several collections, usually for finalization to complete. So this can cause problems with bitmap heavy app as you had to wait for several garbage
collections before your pixel data was reclaimed. And this could be a lot of memory because bitmap pixel data is quite a significant portion of the heap. This also made things harder to debug. If you were using standard
memory analysis tools like the Eclipse Memory Analyzer, it couldn’t actually see this native memory. You would see this tiny bitmap object. Sure, but that doesn’t tell you very much. You don’t mind if you have a 10 by 10 bitmap. But if you have a 512 by 512 bitmap it’s a big difference. Finally, the other problem that we had with this approach was that it required full stop the world garbage collections in order to reclaim the backing memory, assuming that you didn’t call recycle,that is.</p>

<p>  The good news is in Honeycomb we’ve changed the way this works. And the bitmap pixel data is now allocated inside the Dalvik heap. So this means it can be freed synchronously by the GC on the same cycle that your bitmap
gets collected. It’s also easier to debug because you can see this backing memory in standard analysis tools like Eclipse Memory Analyzer. And I’m going to do a demo in a few minutes and you’ll see really, how much more useful this is when you can see that memory. Finally, this strategy is more amenable to concurrent and partial garbage collections, which means we can generally keep those pause times down. So those are the two biggest changes that we’ve introduced in Gingerbread and Honeycomb that affect how your apps use memory.</p>

<p>  And now I want to dive in to some tools that you can use to better understand how much memory your app’s using. And if you have memory leaks, better understanding where those leaks are and generally, how your app is using memory. The most basic tool you can use for understanding your apps memory usage is to look at your log messages. So these are the log messages that you see in DDMS in the logcat view. You can also see them at the command line using adb logcat. And every time a garbage collection happens in your process, you’re going to see a message that looks something like this one. And I just want to go through the different parts of this message, so you can better understand what it’s telling you.</p>

<p>  The first thing we have is the reason for the garbage collection. Kind of what triggered it and what kind of collection is it. This one here was a concurrent collection. So a concurrent collection is triggered by basically, as your heap starts to fill up, we kick off our concurrent garbage collection so that it can hopefully complete before your heap gets full.</p>

<p>  Other kinds of collections that you’ll see in the log messages. GC for malloc is one of them. That’s what happens when say, we didn’t complete the concurrent collection in time and your application had to allocate more memory. The heap was full, so we had to stop and do a garbage collection.</p>

<p>  You’ll see GC external alloc, which is for externally allocated memory, like the bitmap pixel data which I mentioned. It’s also used for NIO direct byte buffers. Now this external memory as I mentioned, has gone away in Honeycomb. Basically everything is allocated inside the Dalvik heap now. So you won’t see this in your log messages in Honeycomb and later.</p>

<p>  You’ll also see a message if you do an HPROF, if you create an HPROF profile. And finally, the last one I want to mention is GC explicit. You’ll see this generally when you’re calling system.gc, which is something that
you know you really should avoid doing. In general, you should trust in the garbage collector. We’ve got some information
also about the amount of memory that was freed on this collection. There’s some statistics
about the heap. So the heap in this case, was 65% free after the collection completed. There’s about three and a half
megs of live objects and the total heap size here is listed as well. It’s almost 10 megs, 9,991 K. There’s some information about externally allocated memory, which is the bitmap pixel data and also, NIO direct byte buffers. The two numbers here, the first number is the amount of external memory that your app has allocated. The second number is a
sort of soft limit. When you’ve allocated that much memory, we’re going to kick off a GC. Finally, you’ll see the pause
times for that collection. And this is where you’re going to see the effect of your heap size. Larger heaps are going to
have larger pause times.</p>

<p>  The good news is for a concurrent collection, you’re going to see these pause times generally pretty low. Concurrent collections are going to show two pause times. There’s one short pause at the beginning of the collection and one most of the way through. Non-concurrent collections you’ll see a single pause time, and this is generally going to be quite a bit higher. So looking at your log messages is a really basic way to understand how much memory your app is using. But it doesn’t really tell you, where am I using that memory? What objects are using this memory?</p>

<p>  And the best way to do that is using heap dumps. So a heap dump is basically a binary file that contains information about all of the objects in your heap. You can create a heap dump using DDMS by clicking on the icon, this somewhat
cryptic icon. I think that mentioned it in the previous talk. There’s also an API for
creating heap dumps. In general, I find using DDMS is fine. There are times when you want to create a heap dump at a very, very specific point in time. Maybe when you’re trying to track down a memory leak. So it can be helpful
to use that API. You may need to convert the heap dump to the standard HPROF format. You’ll only need to do that if
you’re using the standalone version of DDMS. If you’re using the Eclipse plug-in, the ADT plug-in, it will
automatically convert it. But the conversion is pretty simple. There’s a tool in the Android
SDK, which you can use to do it. And after you’ve converted it to the standard HPROF format, you can analyze it with standard heap analysis tools, like MAT or jhat.</p>

<p>And I’m going to show an example of MAT, which is the shorter way of saying the Eclipse Memory Analyzer. And before I jump into the demo, I want to talk about memory leaks. So there’s kind of a misconception that in a managed run time, you can’t have memory leaks. And I’m sure you guys know that’s not true. Having a garbage collector does not prevent memory leaks. A memory leak in a managed runtime is a little bit different though, than a memory leak in C or C++. Basically, a leak is when you have a reference to an unused object that’s preventing that object from being garbage collected. And sometimes you can have a reference to a single object, but that object points to a bunch of other objects. And basically, that single reference is preventing a large group of objects
from being collected.</p>

<p>One thing to watch out for in Android. I see people sometimes and I’ve done this myself, accidentally create a memory
leak by holding a long lived reference to an activity. So you need to be really careful with that and maybe it’s you’re holding a reference to the context and that’s what happens. You can also do it by keeping a long lived reference to a view or to a drawable, because these will also hold a reference to the activity that
they were originally in. And the reason that this is a problem, the reason this causes a memory leak is this. So you’ve got your activity, it contains a viewgroup, a linearlayout or something, and it contains some views. And we’ve got a reference from the framework to the currently visible activity.</p>

<p>  But in Android, when you have a rotation event, so you rotate your device, what we do is actually build up a new view hierarchy because you need to load new resources, you may have a brand new layout for landscape or portrait, you may
have differently sized icons or bitmaps. And then we basically remove the reference to the old view hierarchy and point
to the new one. And the idea is that this old view hierarchy sure get garbage collected. But if you’re holding a reference to that, you’re going to prevent it from getting garbage collected. And that’s why it’s a problem to hold the long lived reference to an activity or even to a view because in fact, the arrows connecting these objects should be going in both directions. Because you’ve got pointers all the way up. So if you do have a memory leak, a really good way to figure out where it is using the Eclipse Memory Analyzer.</p>

<p>  I’m going to do a demo of that, but I want to first cover some of the concepts behind the Memory Analyzer, so that when I do the demo you’ll better understand what I’m showing you. So the Eclipse Memory Analyzer can be downloaded from the eclipse.org site. It comes in a couple of flavors. There’s an Eclipse plug-in version, there’s also a standalone version. I’m going to be demonstrating the standalone version. I just personally prefer not to have Eclipse have all these different plug-ins. I kind of like to keep things a little bit separate. But they’re basically the same. Now, Memory Analyzer has some important concepts that you’ll see a lot.</p>

<p>  It talks about shallow heap and retained heap. So the shallow heap of an object is just how large is this object, it’s
size and bytes. It’s really simple. So let’s say that all of these objects are 100 bytes. So they’re shallow heap
is 100 bytes. It’s easy. The retained heap is something different. Basically, the retained heap says, if I have an object here and I were to free this object, what other objects is it pointing to? And could those be freed at the same time? And so you calculate the retained heap in terms of, what is the total size of objects that could be freed by freeing this one object? So maybe it’s best to understand with an example. So this object down on the right-hand side in yellow, this guy doesn’t point to any other objects. So his retained size is pretty easy to calculate. His retained heap is 100. This guy on top, he has a pointer to one other object. But he’s not holding that object alive. There are other pointers to that same object. So this guy’s retained heap is also just 100 bytes. Because if we were to remove
this object, it’s not going to free up any other objects. The object down at the end however, it’s basically keeping all the other objects alive. So its retained heap is 400 because if we could free that object, we could free all the other objects well, on this slide anyway. So you might be wondering, how do you go about calculating the retain heap?</p>

<p>So you’re going to see this in Memory Analyzer. And actually, knowing how it calculates the retained heap is quite useful. So the Memory Analyzer uses a concept called the denominator tree. This is a concept from graph theory. Basically, if you have a node A and a node B, A is said to be the dominator of B if every path to B goes through A. And so you might see how that could help us figure out what the retained heap of an object is. So another example here. So let’s start with A. It’s kind of the root. B and C are only accessible through A. So it’s pretty straightforward. They’re children of A and the dominator tree. E is also only accessible through C. So it’s a child of C in the dominator tree. D is a little bit interesting here. D can be accessed through B or C, but A is on every path to D. So that means that A is
the parent of D and the dominator tree. And now you’re going to see this dominator tree concept also pop up in Memory
Analyzer in its UI. And it can be really helpful for tracking down memory leaks.</p>

<p>  So let’s jump in and do a demo of debugging and memory leak with MAT. So what I’m going to use for this demo is the Honeycomb gallery’s sample application. It’s a simple application that comes with the Android SDK the basically just demonstrates some of the features of Honeycomb. And really, all it is is a little app the lets you page through some photos. Pretty simple. Now I’ve done something kind of naughty here. I’ve introduced a memory leak into this application. And I’ll show you how I’ve done that. Sorry, I better switch to the slides again.</p>

<p>  So you’ll see here I have the
source code, an excerpt of the source code from the activity. And so what I’ve done here is I’ve introduced this inner class called leaky. And this is not a static inner class. So you may know that if you create a non-static inner class, it actually keeps a reference to the enclosing object. And this is because from a non-static inner class, you can actually refer to the instance variables of the enclosing object. So it’s going to retain a reference to the activity here. That’s fine as long as this object doesn’t live longer than the activity. But I’ve got this static field and statics live longer than any particular instance. And in my on create method, what I’ve done is instantiated the leaky object and stored it into the static field. So if you want to be able to visualize this, I basically got my view hierarchy that starts with the main activity. I’ve instantiated this leaky object and he has a reference to the main activity because that was its enclosing class. Finally, I have the main activity class, which is conceptually a different area of memory than any particular instance. And there’s a static variable pointing to the leaky object. So maybe you can see how this is going to cause a memory leak when I rotate the screen. So let’s jump in and take a look at this memory leak. So if you want to figure out whether you have a memory leak, one of the easiest ways is to just kind of look at your log messages. So I’m just going to do that. I’m going to do it at the command line. I can just type logcat. And I want to restrict it to the particular process that I’ve got running here. I don’t want to see all of the log messages on the system. So I’m just going to grab on the process ID. There we see a bunch a log messages, including some garbage collection messages. And the number you want to look
at is basically the first number here in the 9805K. The first number in your heap size. This is the amount of live objects in the system. And if you’re looking for a memory leak, that’s what you want to look at. So I’m going to flip through some of the photos here. And you’ll see that that number stays pretty constant. We’re up to 9872. But basically, the heap usage is pretty constant. Now when I rotate this device, we’re going to be a bunch of garbage collections happen. That heap usage goes up and it doesn’t go down again. So we’re now up to 12 megs of heap. So we leaked about two and a half megs. So whenever you see your memory go up in kind of a step function like that, it steps up and just never goes back down, that’s a good sign you have a memory leak.</p>

<p>  So once you know that you have a leak, what you’ll want to do is create a heap dump, so you can go about debugging it. So I’m going to do that right now. I’ll open up DDMS. You just need to select the process that you care about and click on this icon up in the toolbar that says dump HPROF file. That’ll create a heap dump. It takes a few seconds because
it’s dumping basically a huge binary file out to disk. And then I can just save it in a file called dump.hprof. And then, because I’m using this standalone version of DDMS here, I need to convert this file. As I mentioned, if you’re using
the ADT plug-in for Eclipse and using DDMS in there, you don’t need to go through this conversion step. But it’s really simple. Now that I’ve converted it, I can open up the Eclipse Memory Analyzer and take a look at this heap dump. So there’s not much to see in the Memory Analyzer until you’ve opened up a heap dump, which we can do just from the file menu. Open heap dump. And I’ll open up this converted heap dump, which I just created. Doesn’t take very long for it to load up.</p>

<p>  And the first thing you’ll see is this pie chart. This is showing the biggest objects in the system by retained size. Now this alone doesn’t really tell us too much. You can see that down in the bottom left here, when I mouse over the various slices of the pie, it’s telling me what kind of object I’ve got. But that doesn’t really tell us too much. If we want to get some more information, you want to look down here. There are two views. The histogram view and the dominator tree. And these are the ones that I find most useful and I’m going to show to you. Let’s take a look at
the dominator tree. You remember the concept I explained. This is how it can be useful in tracking down a memory leak. So what we’ve got here is basically a list of instances or a list of objects in this system organized. There’s a column here. Organized by the amount of retained heap. So when you’ve got a memory leak, looking at the amount of retained heap is often a good way to look at things because that’s going to have the biggest effect on how much memory you’re using. And chances are, if you’ve noticed that you’ve got a leak, you’re leaking a significant amount. So let me just Xoom in here. Hopefully you guys can see this a bit better. So at the very top of the list
we have the resources class. That’s not too surprising because our resources we have to load lots of bitmaps. That’s going to hold lots of memory alive. That’s fine. These two bitmap objects are interesting. I’ve got these two large
bitmaps, more than two and a half megs each. It’s funny because that sounds about like the amount of memory that I was leaking. So if I want to investigate a bit further, I can right click on one of these objects and choose path to GC roots. And I’ll chose excluding weak references because I want to see what’s keeping that object alive. And a weak reference is not going to keep it alive. So this opened up a new tab and what do you know? It actually points right to my leak. So when you’re creating leaks in your application, make sure you name it something really
helpful like this so you can find it easily.</p>

<p>AUDIENCE: [LAUGHTER]</p>

<p>PATRICK DUBROY: So some of you might have noticed this, that if there’s only a single path to this object, because that’s all I can see here, why didn’t this leak object show up in the dominator tree? I mentioned that the dominator tree should show you the largest objects by their amount of retained heap. And well this is a single object that’s responsible for retaining the bitmap. So the reason for that is that the Eclipse Memory Analyzer, when it calculates the dominator
tree, it actually doesn’t treat weak references separately. It basically just treats them like a normal reference. So you’ll see that if I actually right click on this guy again and say path to GC roots, and say with all references, then there’s actually another path to this object. But it’s a weak reference. Generally you don’t need to be too concerned about weak references because they’re not going to prevent your object from being garbage collected. But that’s why the leak object didn’t show up in the dominator tree. So the dominator tree is one really, really useful way of tracking down a memory leak. Another thing I like to use is the histogram view. So I mentioned that in Android, it’s common to leak memory by keeping long lived references to an activity. So you may want to actually go and look at the number instances of your main activity class that you have.</p>

<p>And the histogram view lets you do that. So the histogram view just shows a list of all the classes in its system and right now it’s sorted based on the amount of shallow heap occupied by classes in the system. So at the very top there, we
see we have byte arrays. And the reason for this is that byte arrays are now the backing memory for pixel data. And you know, this is a perfect example of why it’s really useful that we now have the pixel data inside the heap. Because if you’re using this on Gingerbread or earlier, you’re not going to see byte arrays at the top. Because that memory with allocated in native memory. So we could also, if we were concerned about these byte array objects, we might want to right click on it and say list objects with incoming references. And we’ve got our two large byte array objects here. We can right click on one and say, path to GC roots, excluding weak references. So this guy looks to have several paths, which keep it alive. Nothing looks out of the ordinary to me. And when you’re trying to find a memory leak, there’s not really a magic answer for how you find a leak. You really have to understand your system and understand what objects are alive, why they’re alive, during the various parts of your application. But you’ll see if I look at this other byte array object, and again, do path to GC roots excluding weak references, well, I’ve found my leak again. So this was another way that I might have found this if it weren’t so obvious from the dominator tree.</p>

<p>  The histogram view can also help us look for our activity instances. So there’s a lot of classes obviously in the system. Our activity is not here. There’s 2,200 classes. But luckily, Eclipse Memory Analyzer has this handy little filter view at the top. You can just start typing a regular expression. And it’ll return you all the classes that match that. So here we’ve got our main activity. And it tells us that there are actually two instances of this main activity. And that should kind of be a red flag. Normally you should expect to see only a single instance of your main activity alive.Now I mentioned during the screen rotation, we build up a new view hierarchy, there’s going to be a brief time where there’s two instances alive. But for the most part, you should expect to see one here. So I might think, OK, this is a red flag.</p>

<p>  Let’s take a look. So I can right click on this object and list objects with incoming references. So I want to look at what instances do I have and what’s pointing to them? And so I’ve got two instances here. If I right click on one of them and choose path to GC roots, excluding weak references, I’ve again, found my memory leak. And in looking at this, I might realize that, oh, I really didn’t intend to do this. I didn’t mean to keep this reference there. So that’s another way that you could have found the leak. So now that we’ve discovered where our memory leak is, why don’t we actually go ahead and fix it. So in this case, the problem was that we had a non-static inner class. So we could fix this by making it a static inner class. And then it wouldn’t actually keep a reference to the enclosing activity. The other thing we could do is actually just not store it in a static variable. So it’s fine if this leaky
object has a reference to the activity, as long as it doesn’t live longer than the activity. So let’s do that. Let’s just make this a regular instance variable and not a static. So then I can go in here recompile this and push it to the device.
  And hopefully, we should see that our memory leak has been eliminated. Sorry, what we actually want to do is look at our log output in order to see how much memory we’re using. So I’m just going to fire up the process here, take a look at the process ID. And again, just do adb logcat just on that process. So as I page through the photos again, we see lots of GC messages. When I rotate, we’re going to see the memory usage goes up for a minute there. But after a few collections, it does go back down to its previous value. So we’ve successfully eliminated the leak there. And this is great. You always want to eliminate memory leaks.</p>

<p>   So that’s an example of using the Eclipse Memory Analyzer to debug a memory leak. Eclipse Memory Analyzer is a really powerful tool. It’s a little bit complex. It actually took me quite a while to figure out that these were the two best tools for the job. So you really want to watch out for these memory leaks. So I gave an example here of retaining a long lived reference to an activity. If you’ve got our context, a view, a drawable, all of these things you need to
watch out for. Don’t hold long lived references to those. It can also happen with non-static inner classes, which is what I demonstrated there as well. Runnable is actually one that can bite you sometimes. You know, you create a new runnable. You have a deferred event that’s going to run in like five minutes. If user rotates the screen that deferred runnable is going to hold your previous activity instance alive for five minutes. So that’s not good.</p>

<p>  You also want to watch out for caches. Sometimes you have a cache and you want to keep memory alive, so that you can load images faster let’s say. But you may inadvertently hold things alive too long. So that covers basically, the core parts of the Eclipse Memory Analyzer, and gives you a basic understanding of memory leaks. If you’d like to get more information about Memory Analyzer, the download link you can find on the eclipse.org/mat site. Markus Kohler who’s one of the original team members of Eclipse Memory Analyzer, he has a blog called the Java Performance Blog. This is really great. He’s got tons of great articles on there about MAT and different ways you can use it to understand your applications memory usage.</p>

<p>  I’ve also got an article that I wrote on the Android Developer Blog called memory analysis for Android applications. It covers a lot of the same stuff that I did in my demo here. And Romain Guy also has a good article on avoiding memory leaks in Android. So I hope that’s been helpful, I hope you guys have a better understanding now of how you
can figure out your apps memory usage.</p>

<p>  And I’ve talked about two of the biggest changes that we’ve made in Gingerbread and
Honeycomb that affect how your apps use memory. Thanks.</p>

<p>[APPLAUSE]</p>

<p>So I can take questions from the floor if anyone has any. Or you all want to get out and get to a pub and have a beer?</p>

<p>AUDIENCE: Hi, you mentioned that if you use NIO in Honeycomb your objects are going to be not in native memory and now they’re going to be managed memory. How does that affect performance if you’re doing a NIO, is that going to be any slower, like very intense on network?</p>

<p>PATRICK DUBROY: No, I mean it shouldn’t affect. So I should say that there is still a way to allocate native memory for your NIO byte buffers. I’m not that familiar with the NIO APIs, but I believe there’s a way in JNI you can
allocate your own memory. So in that case, you’ll still be using native memory. But either way, it’s
just memory. It’s just allocated in a different place. So there’s nothing that makes
the Dalvik heap memory slower than other memory.</p>

<p>AUDIENCE: So you’re saying how in Honeycomb the bitmaps are stored in the Dalvik heap, but in previous versions to that it was stored on native memory. Does that mean that bitmaps had a different amount of heap size? Or is that still all counted in the 16 or 24 megabytes that previous versions had?</p>

<p>PATRICK DUBROY: Yeah, good question. The accounting limits are still the same. That was accounted for previously. You might have noticed if you ever ran into your heap limit, you would be looking at your heap size and like, I haven’t hit the limit yet, why am I’m getting out of memory? That was actually accounted for, so it was your total heap size plus the amount of externally allocated memory that was your limit. So that hasn’t changed.</p>

<p>AUDIENCE: Hello. I have a question on when does the garbage collector kicks in. Is is when a number of
objects in memory or the size of the heap?</p>

<p>PATRICK DUBROY: Well, it depends on what kind of garbage collection you’re talking about. The concurrent garbage collector–</p>

<p>AUDIENCE: Yeah, the concurrent. Yes.</p>

<p>PATRICK DUBROY: Yeah, so that I believe is the amount of basically, how full your heap is getting.</p>

<p>AUDIENCE: Because I noticed that when you do a lot of [INAUDIBLE] provide operations, so you have like [INAUDIBLE] list of operations, the garbage collector kicks in. But actually don’t collect any objects because you’re just filling in the array of objects that you want to insert into a database. And that’s grow quite quickly. And that tends to slow down a
bit, the application without actually solving any heap size.</p>

<p>PATRICK DUBROY: Yeah, I’m not sure if the GC looks at– so you’re basically saying, I guess, that the collector is kicking in. It’s not actually able to collect anything, so it shouldn’t–</p>

<p>AUDIENCE: But it keeps trying.</p>

<p>PATRICK DUBROY: Yeah, it should be smart enough. Yeah, I don’t believe we actually look at those kind of statistics yet. But I mean it seems reasonable. Yeah.</p>

<p>AUDIENCE: I was wondering if you guys have some plans for making a profiler for applications or more tools for analyzing memory and all that stuff?</p>

<p>PATRICK DUBROY: No plans that I know of. Is there anything in particular that you need? I mean I think the Eclipse
Memory Analyzer is a really powerful tool and I use it in my day-to-day work quite a bit. So I’ve certainly never found
that it it was missing certain features that I needed.</p>

<p>AUDIENCE: Yeah, probably because there are some old versions from Android that show memory leaks or something. But for example, on Eclair, there were some stuff with the– something there.</p>

<p>PATRICK DUBROY: Yeah, I mean we don’t have any immediate plans I don’t think to running specific tools.</p>

<p>AUDIENCE: OK, thank you.</p>

<p>PATRICK DUBROY: Oh, sorry I’ve been– yeah.</p>

<p>AUDIENCE: To my understanding, the native part of a bitmap memory before was actually an instance of the SKIA library, of one of the SKIA library bitmap classes. So is this still there or is it gone now that there is no more native memory allocated?</p>

<p>PATRICK DUBROY: No, SKIA is still part of this stack there. Basically at the point where SKIA calls out to allocate memory, we actually just call back into the VM and allocate the memory there rather than calling malloc. So it’s still basically the same mechanism, but the memory’s just coming from a different place.</p>

<p>AUDIENCE: OK. AUDIENCE: I thought that when I was using my application, I checked the heap size. While using the application the heap size was not significantly going up. But the amount of memory used by the application, which is listed in the applications tab under the running applications is going up significantly. Sometimes even doubling. I know that this is a different heap that is shown there. It’s actually the process heap, right? Can you tell me what the
background of that is that this is shown there because might like– I don’t have a memory leak and users complain about my application leaking memory. Because for the user it looks like it’s leaking memory.</p>

<p>PATRICK DUBROY: Right. Because you’re saying there’s stuff that’s attributed to your process that are showing up in the– basically, in system memory?</p>

<p>AUDIENCE: Yeah. So it’s showing the system memory in the applications tab, which is not really linked to my heap memory. So that is going up, but I can only control the heap memory. If I don’t have a native application I cannot control everything else.</p>

<p>PATRICK DUBROY: I mean there are going to be various things in the system that are going to get larger. For example, like your JIT code caches. As the JIT kicks in and is allocating memory, like it needs to store the compiled
code somewhere. So there’s definitely other parts of this system that allocate memory that’s going to kind of get charged to your application. But I can’t think of why. I can’t think of anything that would be out of the ordinary really that should cause problems.</p>

<p>AUDIENCE: But do you know if this will be changed maybe in the future? That this number is not shown there because for me, it doesn’t make sense to show this number to the end user because he doesn’t understand what it means.</p>

<p>PATRICK DUBROY: I see. Where is he seeing the number?</p>

<p>AUDIENCE: In the running applications tab. If he goes to settings, running applications, he can see the memory usage per
application and that’s actually the system memory.</p>

<p>PATRICK DUBROY: I see. Yeah, I’m not sure what our plans are with that. Sorry. I can take a look and I’m not
actually sure where it’s getting that number from.</p>

<p>AUDIENCE: OK, thanks.</p>

<p>AUDIENCE: My question’s about reasonable expectations of out of memory errors. Is it possible to completely
eliminate them? We’ve been working for a while in getting rid of all the out of memory errors and down to one in about every 17,000 sessions. Should we keep troubleshooting. I mean, I’d like to get it down to zero, but is that reasonable or?</p>

<p>PATRICK DUBROY: So there are certain scenarios where if you’re really close to your memory limit, so if your applications live memory size is really close to that limit, the garbage collector’s fundamentally kind of asynchronous. So if you’re really close to the limit, there can be times where you’re just trying to allocate so fast that the garbage collector
can’t keep up. So you can be actually sort of out running the garbage collector. So certainly it’s possible to
build applications that never see an out of memory error.
  But on the other hand, there are certain types of applications that are going to be running really, really close to the limits. One thing you can use if you have caches or things that you can free up, there are several ways to figure out that you’re getting close to the heap memory limit. I believe there’s a callback you can get notification that we’re getting low on memory. Although, the name escapes me. But you can also look at that, the Activity Manager, get memory class to get a sense of how much memory you have available on the system. And you know, maybe you can keep like smaller caches or leave the initialize objects rather than initializing them all in the constructor or something like that. It really depends on the application whether you expect to be running close to that heap limit or not.</p>

<p>AUDIENCE: You recommended not to call system.gc manually if you can help it. Is there any way to reliably
free bitmap memory pre-Honeycomb?</p>

<p>PATRICK DUBROY: Yes. Pre-Honeycomb?</p>

<p>AUDIENCE: Yes.</p>

<p>PATRICK DUBROY: You can call recycle on the bitmap.</p>

<p>AUDIENCE: Yeah, but it can still take several passes apparently.</p>

<p>PATRICK DUBROY: No. If you call recycle that will immediately free the backing memory. The bitmap itself, that’s like
80 bytes or something.</p>

<p>AUDIENCE: There are also bitmaps like drawables that you can’t manually recycle the bitmaps that the drawable object creates.</p>

<p>PATRICK DUBROY: OK.</p>

<p>AUDIENCE: The backing bitmaps for those.</p>

<p>PATRICK DUBROY: I see. No, I mean there are still some cases I guess where system.gc is the
right approach.</p>

<p>[UNINTELLIGIBLE PHRASE]</p>

<p>PATRICK DUBROY: OK, which objects are you talking about in–</p>

<p>AUDIENCE: My experience is when I have image drawables that are used some where in my layout and I know they’re no longer needed. Some of them are fairly large and it seems like–</p>

<p>PATRICK DUBROY: You can call recycle on those I believe.</p>

<p>AUDIENCE: OK. My experience is that it will cause other problems when I do that.</p>

<p>PATRICK DUBROY: If you’re still using them, then you can’t– I mean, you can only recycle
that when you’re not using it.</p>

<p>AUDIENCE: Sure. OK.</p>

<p>AUDIENCE: For native code that uses a lot of mallocs, what’s the best way to manage that memory?</p>

<p>PATRICK DUBROY: That’s a very good question. When you’ve got native code, I mean mostly what I was covering here was managing memory from the Dalvik side of things. I don’t know that I have any real pointers. I mean that’s one of the reasons why programming in a managed runtime is very nice. Is that you don’t have to deal with manually managing your memory. I don’t have any great advice for that.</p>

<p>AUDIENCE: Does the app that calls into the native libraries, is it aware of, at least on an aggravate level, how much memory is being used or is it completely a separate–</p>

<p>PATRICK DUBROY: I don’t believe there’s any way to account for if you’re calling into the library and it’s calling malloc. I don’t know that there’s any way to account for that memory from your application side.</p>

<p>AUDIENCE: But that garbage collector will run when you start allocating memory, will it not?</p>

<p>PATRICK DUBROY: It’ll run when you start allocating like objects in Dalvik. It doesn’t have any knowledge of calls to malloc.</p>

<p>AUDIENCE: You’ll just get an out of memory or a failed malloc if you–</p>

<p>PATRICK DUBROY: Yeah. Sure. It’s going to be the same mechanisms as any C or C++ program. Malloc is going to return
a null pointer. Yes?</p>

<p>AUDIENCE:
[UNINTELLIGIBLE PHRASE]</p>

<p>PATRICK DUBROY: Pardon me?</p>

<p>AUDIENCE:
[UNINTELLIGIBLE PHRASE]
PATRICK DUBROY: Oh, OK. That’s news to me. Malloc can’t fail on Android.</p>

<p>AUDIENCE:
[UNINTELLIGIBLE PHRASE]</p>

<p> PATRICK DUBROY: I see. OK.</p>

<p>AUDIENCE: Can you repeat that?</p>

<p>PATRICK DUBROY: Romain tells me that malloc can’t fail on Android.</p>

<p>AUDIENCE:
[UNINTELLIGIBLE PHRASE]</p>

<p>PATRICK DUBROY: I see. So I think this is the old Linux lazy– yeah. It’ll successfully allocate the
virtual memory, but Linux can actually hand out more virtual memory than it can actually commit. So you can get problems. Like when your system is totally, totally out of native memory, you’re going to see crashes.</p>

<p>AUDIENCE: So native memory is completely separate from anything Dalvik?</p>

<p>PATRICK DUBROY: Yes. Well, I mean, sorry, I should say, like Dalvik is still allocating its own memory like
for the heap through the native mechanisms. So it’s reserving the same virtual memory pages that other applications are using.</p>

<p>AUDIENCE: But if your system memory is–</p>

<p>PATRICK DUBROY: Yeah, if your system memory is out, you’re in trouble.</p>

<p>AUDIENCE: But Dalvik won’t get a notice say, hey, better start garbage collecting?</p>

<p>PATRICK DUBROY: Well, no.</p>

<p>AUDIENCE: The flag for using larger heap, does that require a permission, like users permission or something like that?</p>

<p>PATRICK DUBROY: I can’t remember whether we added that or not. I don’t think that it does.</p>

<p>AUDIENCE: Like the whole– could it been like a permission thing? But if it’s not then–</p>

<p>PATRICK DUBROY: Yeah, I mean the idea I think is that– yeah, you’re right. I mean it can affect the system as a whole because you’re going to have apps that are using a lot more memory, which is why I gave that big
warning, that this is not something that you should be using unless you know that you really need it.</p>

<p>AUDIENCE: Yeah. But [INAUDIBLE]. OK.</p>

<p>PATRICK DUBROY: I don’t think there’s a permission for it, though.</p>

<p>AUDIENCE: What if the app kind of runs in the background for weeks at a time? So I do everything I can to
simulate a leak, click everywhere I can, but I see the leaks if the app runs two or three days and then
I get [INAUDIBLE].</p>

<p>PATRICK DUBROY: One thing you could try is if you can use the APIs to determine how much
free memory you have. I don’t know if there’s any way you can actually kind of notice in your application that
it started leaking. But you could write out an HPROF file when you notice that you’ve gotten to a certain
point, your heap is getting smaller and smaller. So there is some debug information there that you could use. So if you have like some beta testers, who could actually send you these dumps, then you could do that. So write out the HPROF file
to SD card or something.</p>

<p>AUDIENCE: So maybe I can just write an HPROF file every–</p>

<p>PATRICK DUBROY: I wouldn’t do that. I mean they’re quite large. You don’t want to be doing that on a regular basis. But if you detect that things have gone really, really wrong and you’re about to die, in an alpha version or something for testing that’s one way you could do it. But I definitely wouldn’t recommend putting an app in the market that’s dumping like very large files to the SD card for no reason.</p>

<p>AUDIENCE: OK.</p>

<p>PATRICK DUBROY: OK, Thanks a lot.</p>

<h2>下载</h2>

<p><a href="http://pan.baidu.com/s/1i3zLPjf">http://pan.baidu.com/s/1i3zLPjf</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Note for Google IO Memory Management For Android]]></title>
    <link href="http://droidyue.com/blog/2014/11/02/note-for-google-io-memory-management-for-android/"/>
    <updated>2014-11-02T14:12:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/02/note-for-google-io-memory-management-for-android</id>
    <content type="html"><![CDATA[<p>This is the subtitle for Google I/O 2011: Memory management for Android Apps.</p>

<h2>The Video</h2>

<iframe width="640" height="360" src="http://droidyue.com//www.youtube.com/embed/_CruQY55HOk" frameborder="0" allowfullscreen></iframe>


<h2>The Subtitles</h2>

<p>  Hi everybody,</p>

<p>  My name’s Patrick Dubroy and today I’m going to talk to you about memory management for Android. So I’m really happy to see so
many people here who care about memory management, especially near the end of the day.</p>

<p>  So let’s get started. So I’m sure you all remember this device. This is the T-Mobile G1. Hugo talked about it in the keynote yesterday. It was released about two and a half years ago. So, is there anybody here who actually developed on the G1? All right, impressive. That’s about maybe
40% of the room. So you may remember that the G1 came with 192 megabytes of RAM. And in fact, most of that was used up by the system. There wasn’t a whole lot left over for apps.</p>

<p>  <!--more-->
  Fast forward a few years later, we have the Motorola Xoom released just a couple of months ago. The Xoom comes with a gigabyte of RAM. Now some people might hear this and think, OK, my troubles are over. I never have to worry about memory management again. And of course, given that we have a whole room here, you guys are all smart people and you realize that that’s not true. And there are a couple of reasons for this. First of all, the Xoom has six and a half times the resolution that the G1 had. So you’ve got six and a half times as many pixels on screen. That means you’re probably
going to need to use more memory. You got more bitmaps for example. The other thing is that on tablets, you really want to create a new kind
of application. You know, the rich, immersive applications, like this YouTube app, for example. These are going to take a lot of memory. There’s tons of bitmaps in here. Those use up a lot of memory. Also, the Xoom we’re talking about a pretty new device. This is basically bleeding edge hardware. Most your customers are not going to be using something that’s only two months old. So of course, you want to support people who are using older hardware as well.</p>

<p>  Finally, maybe you’re all familiar with Parkinson’s Law, which says that work always take as much time as you have. And really, it’s kind of the same for software. So, no matter how much memory you have, you’re going to find a way to use it and wish you had just a little bit more.</p>

<p>  What I want to talk about today are basically two different things. First of all, I want to cover some of the changes that we’ve made in Gingerbread and Honeycomb that affect how your app uses memory. That’s your cameo. All right, so as I was saying, there are two different things I want to cover today. So first of all, I want to talk about some of the changes we’ve made in Gingerbread and Honeycomb that affect how your apps use memory. And basically, memory management in general. In the second half of the talk I want to talk about some tools you can use to better understand how your app is using memory. And if you have memory leaks,how you can figure out where those memory leaks are.</p>

<p>  So just to set expectations for this talk, I’m going to make them some assumptions about the stuff you’ve done and it’ll really help you get the most out of this if you’re familiar with these concepts. So I’m hoping that you’ve all written Android apps before. And it looked like about half the room had developed on the G1, so that’s probably true. I hope that most of you have heard of the Dalvik heap. You have a basic idea of what I’m talking about when I talk about heap memory. I’m sure you’re familiar with the garbage collector. You have a basic idea hopefully of what garbage collection is and how it works. And probably, most of you have seen an OutOfMememoryError before and you have a basic idea of why you get it and what you can do to deal with it.</p>

<p>  So first, let’s talk about heap size. So you may know that in Android, there’s a hard limit on your application’s heap size. And there’s a couple reasons for this. So first of all, one of the great features of Android is that it has full multitasking. So you actually have multiple programs running at once. And so obviously, each one can’t use all of your devices memory. We also don’t want a runaway app to just start getting bigger and bigger and bloating the entire system. You always want your dialer to work, your launcher the work, that sort of thing. So there’s this hard limit
on heap size and if your application needs to allocate more memory and you’ve gone up to that heap size limit already,then you’re basically going to get an out of memory error. So this heap size limit is device dependent. It’s changed a lot over the years. On the G1 it was 16 megabytes. On the Xoom it’s now 48 megabytes. So it’s a little bit bigger.</p>

<p>  If you’re writing an app and you want to know, OK, how much heap space do I have available? You know, maybe you want to decide how much stuff to keep in a cache for example. There’s a method you can use in ActivityManager, getMemoryClass that will return an integer value in megabytes, which is your heap size. Now these limits were designed assuming that you know almost any app that you would want to build on Android should be able to fit under
these limits.</p>

<p>  Of course, there are some apps that are really memory intensive. And as I said, on the tablet, we really want to build almost a new class of application. It’s quite a different than the kind of things you were building on phones. So we thought, if someone wants to build an image editor, for example, on the Xoom, they should be able to do that. But an image editor’s a really memory intensive application. It’s unlikely that you could
build a good one that used less than 48 megabytes of heap.
  So in Honeycomb we’ve added a new option that allows applications like this to get a larger heap size. Basically, , you can put something in your AndroidManifest, largeHeap equals true. And that will allow your application to use more heap. And similarly, there’s a
method you can use to determine how much memory you have available to you. The ActivityManager getLargeMemoryClass method again, will return an integer
value of this large heap size.</p>

<p>  Now before we go any further, I want to give a big warning here. You know, this is not something you should be doing just because you got an out of
memory error, or you think that your app deserves a bigger heap. You’re not going to be doing yourself any favors because your app is going to perform
more poorly because bigger heap means you’re going to spend more time at garbage collection. Also, your users are probably going to notice because all their other apps are getting kicked out of memory. It’s really something you want to reserve for when you really understand OK, I’m using tons of memory and I know exactly why I’m using that memory, and I really need to use that memory. That’s the only time that you
should be using this large heap option. So I mentioned garbage collection. And that it takes longer when
you have a bigger heap.
  Let’s talk a little bit about garbage collection. So I just want to go through a quick explanation here of what garbage collection is doing. So basically, you have a set of objects. First of all, let’s say these blue objects here, these are the objects in your heap. And they form a kind of graph. They’ve got references to each other. Some of those objects are alive, some of them are not used anymore. So what the GC does is it starts from a set of objects that we call the roots. These are the objects that the GC knows is alive.</p>

<p>  For example, variables that are alive on a thread stack, J and I global references, we treat objects in the zygote as heap, or as roots as well. So basically, the GC starts with those objects and starts visiting the other objects. And basically, traversing through the whole graph to find out which objects are
referenced directly or indirectly from the GC roots. At the end of this process, you’ve got some objects left over, which the GC never visited. Those are your garbage. They can be collected. So it’s a pretty simple concept. And you can see why when I said that you have bigger heaps you’re going to have larger pause times. Because the garbage collector
basically has to traverse your entire live set of objects. If you’re using say the large heap option and you’ve got 256 megs of heap, well, that’s a lot of memory for the garbage collector to walk over. You’re going to see longer
pause times with that.</p>

<p>  We have some good news though. In Gingerbread, there have been some great changes to the garbage collector that make
things a lot better. So in Gingerbre– sorry, pre-Gingerbread, the state of the garbage collector was that we had to stop
the world collector. So what this means is that basically, when a garbage collection is in progress, your
application is stopped. All your application threads are completely stopped while the collection is proceeding. This is a pretty standard things. These pauses generally tend to be pretty short. What we found was that pause times as heaps were getting bigger, these were getting to be a little bit too long. So we were seeing stuff up 50 to 100 milliseconds. And if you’re trying to build a really responsive app that kind of pause time is not really acceptable.</p>

<p>  So in Gingerbread, we now have a concurrent garbage collector. It does most of its work concurrently, which means that your application is not stopped for the duration of the garbage collection. Basically, we have another thread that’s running at the same time as your application that can perform garbage collection work. You’ll see basically two short pauses. One at the beginning of a collection and one near the end. But these pause times are going to be much, much lower. Usually you’ll see two, three, four, or five milliseconds for your pause time. So that’s a significant improvement. Pause times about 10% of what they used to be. So that’s a really good change that we have in Gingerbread.</p>

<p>  Now if you’re building memory heavy apps, there’s a good chance you’re using a lot of bitmaps. We found that in a lot of apps you have maybe 50 or 75% of your heap is taken up by bitmaps. And in Honeycomb because you’re going to be developing on tablets, this gets even worse. Because your images are bigger to fill the screen. So before Honeycomb, the way we managed bitmaps was this. So the blue area up here is the Dalvik heap and this yellow object is a bitmap object. Now bitmap objects are always the same size in the heap no matter what their resolution is. The backing memory for the bitmap is actually stored in another object. So the pixel data is stored separately. Now before Honeycomb what we did was this pixel data was actually native memory. It was allocated using malloc outside the Dalvik heap. And this had a few consequences. If you wanted to free this memory you could either call recycle, which would free the memory synchronously. But if you didn’t call recycle and you were waiting for your bitmap to get garbage collected,we had to rely on the finalizer to free the backing memory for the bitmap. And if you’re familiar with finalization, you probably know that it’s an inherently unreliable process. Just by its nature it takes several collections, usually for finalization to complete. So this can cause problems with bitmap heavy app as you had to wait for several garbage
collections before your pixel data was reclaimed. And this could be a lot of memory because bitmap pixel data is quite a significant portion of the heap. This also made things harder to debug. If you were using standard
memory analysis tools like the Eclipse Memory Analyzer, it couldn’t actually see this native memory. You would see this tiny bitmap object. Sure, but that doesn’t tell you very much. You don’t mind if you have a 10 by 10 bitmap. But if you have a 512 by 512 bitmap it’s a big difference. Finally, the other problem that we had with this approach was that it required full stop the world garbage collections in order to reclaim the backing memory, assuming that you didn’t call recycle,that is.</p>

<p>  The good news is in Honeycomb we’ve changed the way this works. And the bitmap pixel data is now allocated inside the Dalvik heap. So this means it can be freed synchronously by the GC on the same cycle that your bitmap
gets collected. It’s also easier to debug because you can see this backing memory in standard analysis tools like Eclipse Memory Analyzer. And I’m going to do a demo in a few minutes and you’ll see really, how much more useful this is when you can see that memory. Finally, this strategy is more amenable to concurrent and partial garbage collections, which means we can generally keep those pause times down. So those are the two biggest changes that we’ve introduced in Gingerbread and Honeycomb that affect how your apps use memory.</p>

<p>  And now I want to dive in to some tools that you can use to better understand how much memory your app’s using. And if you have memory leaks, better understanding where those leaks are and generally, how your app is using memory. The most basic tool you can use for understanding your apps memory usage is to look at your log messages. So these are the log messages that you see in DDMS in the logcat view. You can also see them at the command line using adb logcat. And every time a garbage collection happens in your process, you’re going to see a message that looks something like this one. And I just want to go through the different parts of this message, so you can better understand what it’s telling you.</p>

<p>  The first thing we have is the reason for the garbage collection. Kind of what triggered it and what kind of collection is it. This one here was a concurrent collection. So a concurrent collection is triggered by basically, as your heap starts to fill up, we kick off our concurrent garbage collection so that it can hopefully complete before your heap gets full.</p>

<p>  Other kinds of collections that you’ll see in the log messages. GC for malloc is one of them. That’s what happens when say, we didn’t complete the concurrent collection in time and your application had to allocate more memory. The heap was full, so we had to stop and do a garbage collection.</p>

<p>  You’ll see GC external alloc, which is for externally allocated memory, like the bitmap pixel data which I mentioned. It’s also used for NIO direct byte buffers. Now this external memory as I mentioned, has gone away in Honeycomb. Basically everything is allocated inside the Dalvik heap now. So you won’t see this in your log messages in Honeycomb and later.</p>

<p>  You’ll also see a message if you do an HPROF, if you create an HPROF profile. And finally, the last one I want to mention is GC explicit. You’ll see this generally when you’re calling system.gc, which is something that
you know you really should avoid doing. In general, you should trust in the garbage collector. We’ve got some information
also about the amount of memory that was freed on this collection. There’s some statistics
about the heap. So the heap in this case, was 65% free after the collection completed. There’s about three and a half
megs of live objects and the total heap size here is listed as well. It’s almost 10 megs, 9,991 K. There’s some information about externally allocated memory, which is the bitmap pixel data and also, NIO direct byte buffers. The two numbers here, the first number is the amount of external memory that your app has allocated. The second number is a
sort of soft limit. When you’ve allocated that much memory, we’re going to kick off a GC. Finally, you’ll see the pause
times for that collection. And this is where you’re going to see the effect of your heap size. Larger heaps are going to
have larger pause times.</p>

<p>  The good news is for a concurrent collection, you’re going to see these pause times generally pretty low. Concurrent collections are going to show two pause times. There’s one short pause at the beginning of the collection and one most of the way through. Non-concurrent collections you’ll see a single pause time, and this is generally going to be quite a bit higher. So looking at your log messages is a really basic way to understand how much memory your app is using. But it doesn’t really tell you, where am I using that memory? What objects are using this memory?</p>

<p>  And the best way to do that is using heap dumps. So a heap dump is basically a binary file that contains information about all of the objects in your heap. You can create a heap dump using DDMS by clicking on the icon, this somewhat
cryptic icon. I think that mentioned it in the previous talk. There’s also an API for
creating heap dumps. In general, I find using DDMS is fine. There are times when you want to create a heap dump at a very, very specific point in time. Maybe when you’re trying to track down a memory leak. So it can be helpful
to use that API. You may need to convert the heap dump to the standard HPROF format. You’ll only need to do that if
you’re using the standalone version of DDMS. If you’re using the Eclipse plug-in, the ADT plug-in, it will
automatically convert it. But the conversion is pretty simple. There’s a tool in the Android
SDK, which you can use to do it. And after you’ve converted it to the standard HPROF format, you can analyze it with standard heap analysis tools, like MAT or jhat.</p>

<p>And I’m going to show an example of MAT, which is the shorter way of saying the Eclipse Memory Analyzer. And before I jump into the demo, I want to talk about memory leaks. So there’s kind of a misconception that in a managed run time, you can’t have memory leaks. And I’m sure you guys know that’s not true. Having a garbage collector does not prevent memory leaks. A memory leak in a managed runtime is a little bit different though, than a memory leak in C or C++. Basically, a leak is when you have a reference to an unused object that’s preventing that object from being garbage collected. And sometimes you can have a reference to a single object, but that object points to a bunch of other objects. And basically, that single reference is preventing a large group of objects
from being collected.</p>

<p>One thing to watch out for in Android. I see people sometimes and I’ve done this myself, accidentally create a memory
leak by holding a long lived reference to an activity. So you need to be really careful with that and maybe it’s you’re holding a reference to the context and that’s what happens. You can also do it by keeping a long lived reference to a view or to a drawable, because these will also hold a reference to the activity that
they were originally in. And the reason that this is a problem, the reason this causes a memory leak is this. So you’ve got your activity, it contains a viewgroup, a linearlayout or something, and it contains some views. And we’ve got a reference from the framework to the currently visible activity.</p>

<p>  But in Android, when you have a rotation event, so you rotate your device, what we do is actually build up a new view hierarchy because you need to load new resources, you may have a brand new layout for landscape or portrait, you may
have differently sized icons or bitmaps. And then we basically remove the reference to the old view hierarchy and point
to the new one. And the idea is that this old view hierarchy sure get garbage collected. But if you’re holding a reference to that, you’re going to prevent it from getting garbage collected. And that’s why it’s a problem to hold the long lived reference to an activity or even to a view because in fact, the arrows connecting these objects should be going in both directions. Because you’ve got pointers all the way up. So if you do have a memory leak, a really good way to figure out where it is using the Eclipse Memory Analyzer.</p>

<p>  I’m going to do a demo of that, but I want to first cover some of the concepts behind the Memory Analyzer, so that when I do the demo you’ll better understand what I’m showing you. So the Eclipse Memory Analyzer can be downloaded from the eclipse.org site. It comes in a couple of flavors. There’s an Eclipse plug-in version, there’s also a standalone version. I’m going to be demonstrating the standalone version. I just personally prefer not to have Eclipse have all these different plug-ins. I kind of like to keep things a little bit separate. But they’re basically the same. Now, Memory Analyzer has some important concepts that you’ll see a lot.</p>

<p>  It talks about shallow heap and retained heap. So the shallow heap of an object is just how large is this object, it’s
size and bytes. It’s really simple. So let’s say that all of these objects are 100 bytes. So they’re shallow heap
is 100 bytes. It’s easy. The retained heap is something different. Basically, the retained heap says, if I have an object here and I were to free this object, what other objects is it pointing to? And could those be freed at the same time? And so you calculate the retained heap in terms of, what is the total size of objects that could be freed by freeing this one object? So maybe it’s best to understand with an example. So this object down on the right-hand side in yellow, this guy doesn’t point to any other objects. So his retained size is pretty easy to calculate. His retained heap is 100. This guy on top, he has a pointer to one other object. But he’s not holding that object alive. There are other pointers to that same object. So this guy’s retained heap is also just 100 bytes. Because if we were to remove
this object, it’s not going to free up any other objects. The object down at the end however, it’s basically keeping all the other objects alive. So its retained heap is 400 because if we could free that object, we could free all the other objects well, on this slide anyway. So you might be wondering, how do you go about calculating the retain heap?</p>

<p>So you’re going to see this in Memory Analyzer. And actually, knowing how it calculates the retained heap is quite useful. So the Memory Analyzer uses a concept called the denominator tree. This is a concept from graph theory. Basically, if you have a node A and a node B, A is said to be the dominator of B if every path to B goes through A. And so you might see how that could help us figure out what the retained heap of an object is. So another example here. So let’s start with A. It’s kind of the root. B and C are only accessible through A. So it’s pretty straightforward. They’re children of A and the dominator tree. E is also only accessible through C. So it’s a child of C in the dominator tree. D is a little bit interesting here. D can be accessed through B or C, but A is on every path to D. So that means that A is
the parent of D and the dominator tree. And now you’re going to see this dominator tree concept also pop up in Memory
Analyzer in its UI. And it can be really helpful for tracking down memory leaks.</p>

<p>  So let’s jump in and do a demo of debugging and memory leak with MAT. So what I’m going to use for this demo is the Honeycomb gallery’s sample application. It’s a simple application that comes with the Android SDK the basically just demonstrates some of the features of Honeycomb. And really, all it is is a little app the lets you page through some photos. Pretty simple. Now I’ve done something kind of naughty here. I’ve introduced a memory leak into this application. And I’ll show you how I’ve done that. Sorry, I better switch to the slides again.</p>

<p>  So you’ll see here I have the
source code, an excerpt of the source code from the activity. And so what I’ve done here is I’ve introduced this inner class called leaky. And this is not a static inner class. So you may know that if you create a non-static inner class, it actually keeps a reference to the enclosing object. And this is because from a non-static inner class, you can actually refer to the instance variables of the enclosing object. So it’s going to retain a reference to the activity here. That’s fine as long as this object doesn’t live longer than the activity. But I’ve got this static field and statics live longer than any particular instance. And in my on create method, what I’ve done is instantiated the leaky object and stored it into the static field. So if you want to be able to visualize this, I basically got my view hierarchy that starts with the main activity. I’ve instantiated this leaky object and he has a reference to the main activity because that was its enclosing class. Finally, I have the main activity class, which is conceptually a different area of memory than any particular instance. And there’s a static variable pointing to the leaky object. So maybe you can see how this is going to cause a memory leak when I rotate the screen. So let’s jump in and take a look at this memory leak. So if you want to figure out whether you have a memory leak, one of the easiest ways is to just kind of look at your log messages. So I’m just going to do that. I’m going to do it at the command line. I can just type logcat. And I want to restrict it to the particular process that I’ve got running here. I don’t want to see all of the log messages on the system. So I’m just going to grab on the process ID. There we see a bunch a log messages, including some garbage collection messages. And the number you want to look
at is basically the first number here in the 9805K. The first number in your heap size. This is the amount of live objects in the system. And if you’re looking for a memory leak, that’s what you want to look at. So I’m going to flip through some of the photos here. And you’ll see that that number stays pretty constant. We’re up to 9872. But basically, the heap usage is pretty constant. Now when I rotate this device, we’re going to be a bunch of garbage collections happen. That heap usage goes up and it doesn’t go down again. So we’re now up to 12 megs of heap. So we leaked about two and a half megs. So whenever you see your memory go up in kind of a step function like that, it steps up and just never goes back down, that’s a good sign you have a memory leak.</p>

<p>  So once you know that you have a leak, what you’ll want to do is create a heap dump, so you can go about debugging it. So I’m going to do that right now. I’ll open up DDMS. You just need to select the process that you care about and click on this icon up in the toolbar that says dump HPROF file. That’ll create a heap dump. It takes a few seconds because
it’s dumping basically a huge binary file out to disk. And then I can just save it in a file called dump.hprof. And then, because I’m using this standalone version of DDMS here, I need to convert this file. As I mentioned, if you’re using
the ADT plug-in for Eclipse and using DDMS in there, you don’t need to go through this conversion step. But it’s really simple. Now that I’ve converted it, I can open up the Eclipse Memory Analyzer and take a look at this heap dump. So there’s not much to see in the Memory Analyzer until you’ve opened up a heap dump, which we can do just from the file menu. Open heap dump. And I’ll open up this converted heap dump, which I just created. Doesn’t take very long for it to load up.</p>

<p>  And the first thing you’ll see is this pie chart. This is showing the biggest objects in the system by retained size. Now this alone doesn’t really tell us too much. You can see that down in the bottom left here, when I mouse over the various slices of the pie, it’s telling me what kind of object I’ve got. But that doesn’t really tell us too much. If we want to get some more information, you want to look down here. There are two views. The histogram view and the dominator tree. And these are the ones that I find most useful and I’m going to show to you. Let’s take a look at
the dominator tree. You remember the concept I explained. This is how it can be useful in tracking down a memory leak. So what we’ve got here is basically a list of instances or a list of objects in this system organized. There’s a column here. Organized by the amount of retained heap. So when you’ve got a memory leak, looking at the amount of retained heap is often a good way to look at things because that’s going to have the biggest effect on how much memory you’re using. And chances are, if you’ve noticed that you’ve got a leak, you’re leaking a significant amount. So let me just Xoom in here. Hopefully you guys can see this a bit better. So at the very top of the list
we have the resources class. That’s not too surprising because our resources we have to load lots of bitmaps. That’s going to hold lots of memory alive. That’s fine. These two bitmap objects are interesting. I’ve got these two large
bitmaps, more than two and a half megs each. It’s funny because that sounds about like the amount of memory that I was leaking. So if I want to investigate a bit further, I can right click on one of these objects and choose path to GC roots. And I’ll chose excluding weak references because I want to see what’s keeping that object alive. And a weak reference is not going to keep it alive. So this opened up a new tab and what do you know? It actually points right to my leak. So when you’re creating leaks in your application, make sure you name it something really
helpful like this so you can find it easily.</p>

<p>AUDIENCE: [LAUGHTER]</p>

<p>PATRICK DUBROY: So some of you might have noticed this, that if there’s only a single path to this object, because that’s all I can see here, why didn’t this leak object show up in the dominator tree? I mentioned that the dominator tree should show you the largest objects by their amount of retained heap. And well this is a single object that’s responsible for retaining the bitmap. So the reason for that is that the Eclipse Memory Analyzer, when it calculates the dominator
tree, it actually doesn’t treat weak references separately. It basically just treats them like a normal reference. So you’ll see that if I actually right click on this guy again and say path to GC roots, and say with all references, then there’s actually another path to this object. But it’s a weak reference. Generally you don’t need to be too concerned about weak references because they’re not going to prevent your object from being garbage collected. But that’s why the leak object didn’t show up in the dominator tree. So the dominator tree is one really, really useful way of tracking down a memory leak. Another thing I like to use is the histogram view. So I mentioned that in Android, it’s common to leak memory by keeping long lived references to an activity. So you may want to actually go and look at the number instances of your main activity class that you have.</p>

<p>And the histogram view lets you do that. So the histogram view just shows a list of all the classes in its system and right now it’s sorted based on the amount of shallow heap occupied by classes in the system. So at the very top there, we
see we have byte arrays. And the reason for this is that byte arrays are now the backing memory for pixel data. And you know, this is a perfect example of why it’s really useful that we now have the pixel data inside the heap. Because if you’re using this on Gingerbread or earlier, you’re not going to see byte arrays at the top. Because that memory with allocated in native memory. So we could also, if we were concerned about these byte array objects, we might want to right click on it and say list objects with incoming references. And we’ve got our two large byte array objects here. We can right click on one and say, path to GC roots, excluding weak references. So this guy looks to have several paths, which keep it alive. Nothing looks out of the ordinary to me. And when you’re trying to find a memory leak, there’s not really a magic answer for how you find a leak. You really have to understand your system and understand what objects are alive, why they’re alive, during the various parts of your application. But you’ll see if I look at this other byte array object, and again, do path to GC roots excluding weak references, well, I’ve found my leak again. So this was another way that I might have found this if it weren’t so obvious from the dominator tree.</p>

<p>  The histogram view can also help us look for our activity instances. So there’s a lot of classes obviously in the system. Our activity is not here. There’s 2,200 classes. But luckily, Eclipse Memory Analyzer has this handy little filter view at the top. You can just start typing a regular expression. And it’ll return you all the classes that match that. So here we’ve got our main activity. And it tells us that there are actually two instances of this main activity. And that should kind of be a red flag. Normally you should expect to see only a single instance of your main activity alive.Now I mentioned during the screen rotation, we build up a new view hierarchy, there’s going to be a brief time where there’s two instances alive. But for the most part, you should expect to see one here. So I might think, OK, this is a red flag.</p>

<p>  Let’s take a look. So I can right click on this object and list objects with incoming references. So I want to look at what instances do I have and what’s pointing to them? And so I’ve got two instances here. If I right click on one of them and choose path to GC roots, excluding weak references, I’ve again, found my memory leak. And in looking at this, I might realize that, oh, I really didn’t intend to do this. I didn’t mean to keep this reference there. So that’s another way that you could have found the leak. So now that we’ve discovered where our memory leak is, why don’t we actually go ahead and fix it. So in this case, the problem was that we had a non-static inner class. So we could fix this by making it a static inner class. And then it wouldn’t actually keep a reference to the enclosing activity. The other thing we could do is actually just not store it in a static variable. So it’s fine if this leaky
object has a reference to the activity, as long as it doesn’t live longer than the activity. So let’s do that. Let’s just make this a regular instance variable and not a static. So then I can go in here recompile this and push it to the device.
  And hopefully, we should see that our memory leak has been eliminated. Sorry, what we actually want to do is look at our log output in order to see how much memory we’re using. So I’m just going to fire up the process here, take a look at the process ID. And again, just do adb logcat just on that process. So as I page through the photos again, we see lots of GC messages. When I rotate, we’re going to see the memory usage goes up for a minute there. But after a few collections, it does go back down to its previous value. So we’ve successfully eliminated the leak there. And this is great. You always want to eliminate memory leaks.</p>

<p>   So that’s an example of using the Eclipse Memory Analyzer to debug a memory leak. Eclipse Memory Analyzer is a really powerful tool. It’s a little bit complex. It actually took me quite a while to figure out that these were the two best tools for the job. So you really want to watch out for these memory leaks. So I gave an example here of retaining a long lived reference to an activity. If you’ve got our context, a view, a drawable, all of these things you need to
watch out for. Don’t hold long lived references to those. It can also happen with non-static inner classes, which is what I demonstrated there as well. Runnable is actually one that can bite you sometimes. You know, you create a new runnable. You have a deferred event that’s going to run in like five minutes. If user rotates the screen that deferred runnable is going to hold your previous activity instance alive for five minutes. So that’s not good.</p>

<p>  You also want to watch out for caches. Sometimes you have a cache and you want to keep memory alive, so that you can load images faster let’s say. But you may inadvertently hold things alive too long. So that covers basically, the core parts of the Eclipse Memory Analyzer, and gives you a basic understanding of memory leaks. If you’d like to get more information about Memory Analyzer, the download link you can find on the eclipse.org/mat site. Markus Kohler who’s one of the original team members of Eclipse Memory Analyzer, he has a blog called the Java Performance Blog. This is really great. He’s got tons of great articles on there about MAT and different ways you can use it to understand your applications memory usage.</p>

<p>  I’ve also got an article that I wrote on the Android Developer Blog called memory analysis for Android applications. It covers a lot of the same stuff that I did in my demo here. And Romain Guy also has a good article on avoiding memory leaks in Android. So I hope that’s been helpful, I hope you guys have a better understanding now of how you
can figure out your apps memory usage.</p>

<p>  And I’ve talked about two of the biggest changes that we’ve made in Gingerbread and
Honeycomb that affect how your apps use memory. Thanks.</p>

<p>[APPLAUSE]</p>

<p>So I can take questions from the floor if anyone has any. Or you all want to get out and get to a pub and have a beer?</p>

<p>AUDIENCE: Hi, you mentioned that if you use NIO in Honeycomb your objects are going to be not in native memory and now they’re going to be managed memory. How does that affect performance if you’re doing a NIO, is that going to be any slower, like very intense on network?</p>

<p>PATRICK DUBROY: No, I mean it shouldn’t affect. So I should say that there is still a way to allocate native memory for your NIO byte buffers. I’m not that familiar with the NIO APIs, but I believe there’s a way in JNI you can
allocate your own memory. So in that case, you’ll still be using native memory. But either way, it’s
just memory. It’s just allocated in a different place. So there’s nothing that makes
the Dalvik heap memory slower than other memory.</p>

<p>AUDIENCE: So you’re saying how in Honeycomb the bitmaps are stored in the Dalvik heap, but in previous versions to that it was stored on native memory. Does that mean that bitmaps had a different amount of heap size? Or is that still all counted in the 16 or 24 megabytes that previous versions had?</p>

<p>PATRICK DUBROY: Yeah, good question. The accounting limits are still the same. That was accounted for previously. You might have noticed if you ever ran into your heap limit, you would be looking at your heap size and like, I haven’t hit the limit yet, why am I’m getting out of memory? That was actually accounted for, so it was your total heap size plus the amount of externally allocated memory that was your limit. So that hasn’t changed.</p>

<p>AUDIENCE: Hello. I have a question on when does the garbage collector kicks in. Is is when a number of
objects in memory or the size of the heap?</p>

<p>PATRICK DUBROY: Well, it depends on what kind of garbage collection you’re talking about. The concurrent garbage collector–</p>

<p>AUDIENCE: Yeah, the concurrent. Yes.</p>

<p>PATRICK DUBROY: Yeah, so that I believe is the amount of basically, how full your heap is getting.</p>

<p>AUDIENCE: Because I noticed that when you do a lot of [INAUDIBLE] provide operations, so you have like [INAUDIBLE] list of operations, the garbage collector kicks in. But actually don’t collect any objects because you’re just filling in the array of objects that you want to insert into a database. And that’s grow quite quickly. And that tends to slow down a
bit, the application without actually solving any heap size.</p>

<p>PATRICK DUBROY: Yeah, I’m not sure if the GC looks at– so you’re basically saying, I guess, that the collector is kicking in. It’s not actually able to collect anything, so it shouldn’t–</p>

<p>AUDIENCE: But it keeps trying.</p>

<p>PATRICK DUBROY: Yeah, it should be smart enough. Yeah, I don’t believe we actually look at those kind of statistics yet. But I mean it seems reasonable. Yeah.</p>

<p>AUDIENCE: I was wondering if you guys have some plans for making a profiler for applications or more tools for analyzing memory and all that stuff?</p>

<p>PATRICK DUBROY: No plans that I know of. Is there anything in particular that you need? I mean I think the Eclipse
Memory Analyzer is a really powerful tool and I use it in my day-to-day work quite a bit. So I’ve certainly never found
that it it was missing certain features that I needed.</p>

<p>AUDIENCE: Yeah, probably because there are some old versions from Android that show memory leaks or something. But for example, on Eclair, there were some stuff with the– something there.</p>

<p>PATRICK DUBROY: Yeah, I mean we don’t have any immediate plans I don’t think to running specific tools.</p>

<p>AUDIENCE: OK, thank you.</p>

<p>PATRICK DUBROY: Oh, sorry I’ve been– yeah.</p>

<p>AUDIENCE: To my understanding, the native part of a bitmap memory before was actually an instance of the SKIA library, of one of the SKIA library bitmap classes. So is this still there or is it gone now that there is no more native memory allocated?</p>

<p>PATRICK DUBROY: No, SKIA is still part of this stack there. Basically at the point where SKIA calls out to allocate memory, we actually just call back into the VM and allocate the memory there rather than calling malloc. So it’s still basically the same mechanism, but the memory’s just coming from a different place.</p>

<p>AUDIENCE: OK. AUDIENCE: I thought that when I was using my application, I checked the heap size. While using the application the heap size was not significantly going up. But the amount of memory used by the application, which is listed in the applications tab under the running applications is going up significantly. Sometimes even doubling. I know that this is a different heap that is shown there. It’s actually the process heap, right? Can you tell me what the
background of that is that this is shown there because might like– I don’t have a memory leak and users complain about my application leaking memory. Because for the user it looks like it’s leaking memory.</p>

<p>PATRICK DUBROY: Right. Because you’re saying there’s stuff that’s attributed to your process that are showing up in the– basically, in system memory?</p>

<p>AUDIENCE: Yeah. So it’s showing the system memory in the applications tab, which is not really linked to my heap memory. So that is going up, but I can only control the heap memory. If I don’t have a native application I cannot control everything else.</p>

<p>PATRICK DUBROY: I mean there are going to be various things in the system that are going to get larger. For example, like your JIT code caches. As the JIT kicks in and is allocating memory, like it needs to store the compiled
code somewhere. So there’s definitely other parts of this system that allocate memory that’s going to kind of get charged to your application. But I can’t think of why. I can’t think of anything that would be out of the ordinary really that should cause problems.</p>

<p>AUDIENCE: But do you know if this will be changed maybe in the future? That this number is not shown there because for me, it doesn’t make sense to show this number to the end user because he doesn’t understand what it means.</p>

<p>PATRICK DUBROY: I see. Where is he seeing the number?</p>

<p>AUDIENCE: In the running applications tab. If he goes to settings, running applications, he can see the memory usage per
application and that’s actually the system memory.</p>

<p>PATRICK DUBROY: I see. Yeah, I’m not sure what our plans are with that. Sorry. I can take a look and I’m not
actually sure where it’s getting that number from.</p>

<p>AUDIENCE: OK, thanks.</p>

<p>AUDIENCE: My question’s about reasonable expectations of out of memory errors. Is it possible to completely
eliminate them? We’ve been working for a while in getting rid of all the out of memory errors and down to one in about every 17,000 sessions. Should we keep troubleshooting. I mean, I’d like to get it down to zero, but is that reasonable or?</p>

<p>PATRICK DUBROY: So there are certain scenarios where if you’re really close to your memory limit, so if your applications live memory size is really close to that limit, the garbage collector’s fundamentally kind of asynchronous. So if you’re really close to the limit, there can be times where you’re just trying to allocate so fast that the garbage collector
can’t keep up. So you can be actually sort of out running the garbage collector. So certainly it’s possible to
build applications that never see an out of memory error.
  But on the other hand, there are certain types of applications that are going to be running really, really close to the limits. One thing you can use if you have caches or things that you can free up, there are several ways to figure out that you’re getting close to the heap memory limit. I believe there’s a callback you can get notification that we’re getting low on memory. Although, the name escapes me. But you can also look at that, the Activity Manager, get memory class to get a sense of how much memory you have available on the system. And you know, maybe you can keep like smaller caches or leave the initialize objects rather than initializing them all in the constructor or something like that. It really depends on the application whether you expect to be running close to that heap limit or not.</p>

<p>AUDIENCE: You recommended not to call system.gc manually if you can help it. Is there any way to reliably
free bitmap memory pre-Honeycomb?</p>

<p>PATRICK DUBROY: Yes. Pre-Honeycomb?</p>

<p>AUDIENCE: Yes.</p>

<p>PATRICK DUBROY: You can call recycle on the bitmap.</p>

<p>AUDIENCE: Yeah, but it can still take several passes apparently.</p>

<p>PATRICK DUBROY: No. If you call recycle that will immediately free the backing memory. The bitmap itself, that’s like
80 bytes or something.</p>

<p>AUDIENCE: There are also bitmaps like drawables that you can’t manually recycle the bitmaps that the drawable object creates.</p>

<p>PATRICK DUBROY: OK.</p>

<p>AUDIENCE: The backing bitmaps for those.</p>

<p>PATRICK DUBROY: I see. No, I mean there are still some cases I guess where system.gc is the
right approach.</p>

<p>[UNINTELLIGIBLE PHRASE]</p>

<p>PATRICK DUBROY: OK, which objects are you talking about in–</p>

<p>AUDIENCE: My experience is when I have image drawables that are used some where in my layout and I know they’re no longer needed. Some of them are fairly large and it seems like–</p>

<p>PATRICK DUBROY: You can call recycle on those I believe.</p>

<p>AUDIENCE: OK. My experience is that it will cause other problems when I do that.</p>

<p>PATRICK DUBROY: If you’re still using them, then you can’t– I mean, you can only recycle
that when you’re not using it.</p>

<p>AUDIENCE: Sure. OK.</p>

<p>AUDIENCE: For native code that uses a lot of mallocs, what’s the best way to manage that memory?</p>

<p>PATRICK DUBROY: That’s a very good question. When you’ve got native code, I mean mostly what I was covering here was managing memory from the Dalvik side of things. I don’t know that I have any real pointers. I mean that’s one of the reasons why programming in a managed runtime is very nice. Is that you don’t have to deal with manually managing your memory. I don’t have any great advice for that.</p>

<p>AUDIENCE: Does the app that calls into the native libraries, is it aware of, at least on an aggravate level, how much memory is being used or is it completely a separate–</p>

<p>PATRICK DUBROY: I don’t believe there’s any way to account for if you’re calling into the library and it’s calling malloc. I don’t know that there’s any way to account for that memory from your application side.</p>

<p>AUDIENCE: But that garbage collector will run when you start allocating memory, will it not?</p>

<p>PATRICK DUBROY: It’ll run when you start allocating like objects in Dalvik. It doesn’t have any knowledge of calls to malloc.</p>

<p>AUDIENCE: You’ll just get an out of memory or a failed malloc if you–</p>

<p>PATRICK DUBROY: Yeah. Sure. It’s going to be the same mechanisms as any C or C++ program. Malloc is going to return
a null pointer. Yes?</p>

<p>AUDIENCE:
[UNINTELLIGIBLE PHRASE]</p>

<p>PATRICK DUBROY: Pardon me?</p>

<p>AUDIENCE:
[UNINTELLIGIBLE PHRASE]
PATRICK DUBROY: Oh, OK. That’s news to me. Malloc can’t fail on Android.</p>

<p>AUDIENCE:
[UNINTELLIGIBLE PHRASE]</p>

<p> PATRICK DUBROY: I see. OK.</p>

<p>AUDIENCE: Can you repeat that?</p>

<p>PATRICK DUBROY: Romain tells me that malloc can’t fail on Android.</p>

<p>AUDIENCE:
[UNINTELLIGIBLE PHRASE]</p>

<p>PATRICK DUBROY: I see. So I think this is the old Linux lazy– yeah. It’ll successfully allocate the
virtual memory, but Linux can actually hand out more virtual memory than it can actually commit. So you can get problems. Like when your system is totally, totally out of native memory, you’re going to see crashes.</p>

<p>AUDIENCE: So native memory is completely separate from anything Dalvik?</p>

<p>PATRICK DUBROY: Yes. Well, I mean, sorry, I should say, like Dalvik is still allocating its own memory like
for the heap through the native mechanisms. So it’s reserving the same virtual memory pages that other applications are using.</p>

<p>AUDIENCE: But if your system memory is–</p>

<p>PATRICK DUBROY: Yeah, if your system memory is out, you’re in trouble.</p>

<p>AUDIENCE: But Dalvik won’t get a notice say, hey, better start garbage collecting?</p>

<p>PATRICK DUBROY: Well, no.</p>

<p>AUDIENCE: The flag for using larger heap, does that require a permission, like users permission or something like that?</p>

<p>PATRICK DUBROY: I can’t remember whether we added that or not. I don’t think that it does.</p>

<p>AUDIENCE: Like the whole– could it been like a permission thing? But if it’s not then–</p>

<p>PATRICK DUBROY: Yeah, I mean the idea I think is that– yeah, you’re right. I mean it can affect the system as a whole because you’re going to have apps that are using a lot more memory, which is why I gave that big
warning, that this is not something that you should be using unless you know that you really need it.</p>

<p>AUDIENCE: Yeah. But [INAUDIBLE]. OK.</p>

<p>PATRICK DUBROY: I don’t think there’s a permission for it, though.</p>

<p>AUDIENCE: What if the app kind of runs in the background for weeks at a time? So I do everything I can to
simulate a leak, click everywhere I can, but I see the leaks if the app runs two or three days and then
I get [INAUDIBLE].</p>

<p>PATRICK DUBROY: One thing you could try is if you can use the APIs to determine how much
free memory you have. I don’t know if there’s any way you can actually kind of notice in your application that
it started leaking. But you could write out an HPROF file when you notice that you’ve gotten to a certain
point, your heap is getting smaller and smaller. So there is some debug information there that you could use. So if you have like some beta testers, who could actually send you these dumps, then you could do that. So write out the HPROF file
to SD card or something.</p>

<p>AUDIENCE: So maybe I can just write an HPROF file every–</p>

<p>PATRICK DUBROY: I wouldn’t do that. I mean they’re quite large. You don’t want to be doing that on a regular basis. But if you detect that things have gone really, really wrong and you’re about to die, in an alpha version or something for testing that’s one way you could do it. But I definitely wouldn’t recommend putting an app in the market that’s dumping like very large files to the SD card for no reason.</p>

<p>AUDIENCE: OK.</p>

<p>PATRICK DUBROY: OK, Thanks a lot.</p>

<h2>Extra Download</h2>

<p><a href="https://drive.google.com/file/d/0B_t9aqMaOHIJbnNObXBjZWVuTTg/view?usp=sharing">https://drive.google.com/file/d/0B_t9aqMaOHIJbnNObXBjZWVuTTg/view?usp=sharing</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[效率脚本：删除已经合并的git分支]]></title>
    <link href="http://droidyue.com/blog/2014/10/24/auto-delete-merged-branches/"/>
    <updated>2014-10-24T22:45:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/10/24/auto-delete-merged-branches</id>
    <content type="html"><![CDATA[<p>使用Git管理代码工程，着实方便了很多，但是当做完feature分支或者完成hotfix之后，总是忘记删除这些无用的分支，一个一个地删除着实麻烦，重复手工劳动不符合程序员的风格，于是写了一个简单的脚本。一键删除那些不需要的分支，让多余的干扰信息离开视线。</p>

<!--more-->


<h2>删除哪些分支？</h2>

<p>删除的为Merge（合并）操作的源分支。如果工程正在处于分支A(HEAD为A分支),分支B已经合并到了分支A，即A分支包含了B分支的内容，则会删除B分支。</p>

<h2>代码</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#!/usr/bin/env ruby</span>
</span><span class='line'><span class="c1"># encoding: utf-8</span>
</span><span class='line'><span class="n">exceptBranches</span> <span class="o">=</span> <span class="o">[</span><span class="s1">&#39;master&#39;</span><span class="p">,</span> <span class="s1">&#39;pre&#39;</span><span class="p">,</span> <span class="s1">&#39;develop&#39;</span><span class="o">]</span>
</span><span class='line'><span class="k">for</span> <span class="n">branch</span> <span class="k">in</span> <span class="sb">`cd </span><span class="si">#{</span><span class="no">ARGV</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="si">}</span><span class="sb"> &amp;&amp; git branch -l`</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="o">-</span> <span class="o">[</span><span class="s1">&#39;*&#39;</span><span class="o">]</span>
</span><span class='line'>    <span class="k">next</span> <span class="k">if</span> <span class="n">exceptBranches</span><span class="o">.</span><span class="n">include?</span> <span class="n">branch</span>
</span><span class='line'>    <span class="nb">system</span><span class="p">(</span><span class="s2">&quot;git branch -d </span><span class="si">#{</span><span class="n">branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h2>使用方法</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ruby removeMergedBranches.rb your_git_project
</span></code></pre></td></tr></table></div></figure>


<h2>执行结果</h2>

<p>执行结果类似如下，注意如果没有进行合并，则会提示警告或者错误，这些可以忽略。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>warning: deleting branch <span class="s1">&#39;custom&#39;</span> that has been merged to
</span><span class='line'>         <span class="s1">&#39;refs/remotes/origin/custom&#39;</span>, but not yet merged to HEAD.
</span><span class='line'>Deleted branch custom <span class="o">(</span>was b63ab7d<span class="o">)</span>.
</span><span class='line'>Deleted branch hotfix <span class="o">(</span>was 340cca0<span class="o">)</span>.
</span><span class='line'>Deleted branch mgit <span class="o">(</span>was 86b4004<span class="o">)</span>.
</span><span class='line'>error: The branch <span class="s1">&#39;develop_rtl&#39;</span> is not fully merged.
</span><span class='line'>If you are sure you want to delete it, run <span class="s1">&#39;git branch -D develop_rtl&#39;</span>.
</span></code></pre></td></tr></table></div></figure>


<h2>链接</h2>

<p><a href="https://github.com/androidyue/weekly-scripts/blob/master/ruby/removeMergedBranches.rb">在Github上的脚本</a></p>

<h3>学习书籍</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B0058FLC40/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0058FLC40&linkCode=as2&tag=droidyue-23">Git权威指南</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B0058FLC40" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B008041DUY/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B008041DUY&linkCode=as2&tag=droidyue-23">七周七语言:理解多种编程范型</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B008041DUY" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[人生苦短，让你的Git飞起来吧]]></title>
    <link href="http://droidyue.com/blog/2014/10/15/speed-up-your-git/"/>
    <updated>2014-10-15T21:37:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/10/15/speed-up-your-git</id>
    <content type="html"><![CDATA[<p>git是一款超极优秀的版本控制工具，包括Linus大神的linux项目在内的千千万万的项目在使用。你可以使用Eclipse插件管理，亦可以使用终端工具。</p>

<p>git虽然有着svn不能匹及的本地仓库，但是和svn一样，和远程服务器通信也相当常用。常用的pull和push就是比较常见的命令。</p>

<p>然后，你是不是觉得从远程拉取（pull）到本地是不是很慢，从本地推到服务器端（push）又是不是很耗时呢，是吧，正所谓人生苦短，赶紧加速你的git吧。</p>

<!--more-->


<h2>修改ssh配置</h2>

<p>按照下面的内容修改这个文件<code>vim ~/.ssh/config</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">ControlMaster</span> <span class="n">auto</span>
</span><span class='line'><span class="c1">##ControlPath /tmp/%r@%h:%p</span>
</span><span class='line'><span class="no">ControlPath</span> <span class="sr">/tmp/</span><span class="n">git</span><span class="vi">@github</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="mi">22</span>
</span><span class='line'><span class="no">ControlPersist</span> <span class="n">yes</span>
</span></code></pre></td></tr></table></div></figure>


<h2>一些注解</h2>

<ul>
<li><strong>ControlMaster auto</strong>可以使多个ssh会话共享一个已经存在的连接，如果没有，则自动创建一个连接。</li>
<li><strong>ControlPath /tmp/%r@%h:%p</strong>可以指定想要共享的连接。%r代表远程登录用户名，一般都为git，%h表示目标主机，%p表示端口。</li>
<li><strong>ControlPersist yes</strong> 则可以让共享的连接持有处于连接状态。</li>
</ul>


<h2>常用的ControlPath</h2>

<p>下面包含开源中国，github，gitcafe等代码托管。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">ControlPath</span> <span class="sr">/tmp/</span><span class="n">git</span><span class="vi">@git</span><span class="o">.</span><span class="n">oschina</span><span class="o">.</span><span class="n">net</span><span class="p">:</span><span class="mi">22</span>
</span><span class='line'><span class="no">ControlPath</span> <span class="sr">/tmp/</span><span class="n">git</span><span class="vi">@github</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="mi">22</span>
</span><span class='line'><span class="no">ControlPath</span> <span class="sr">/tmp/</span><span class="n">git</span><span class="vi">@gitcafe</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="mi">22</span>
</span></code></pre></td></tr></table></div></figure>


<p>快来试一试吧，是不是提高了5倍！</p>

<p>注：由于网络的情况，结果可能略有不同。已经很快的但没有感觉改善的同学，可以继续读下去。</p>

<h2>还能更快</h2>

<p>还有一个能提高50倍的方法，不过对于一般开发者不是很常用，如需了解可以参考<a href="http://interrobeng.com/2013/08/25/speed-up-git-5x-to-50x/">Speed Up Git (5x to 50x)</a></p>

<h3>其他</h3>

<ul>
<li> <a href="http://www.amazon.cn/gp/product/1430218339/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=1430218339&linkCode=as2&tag=droidyue-23">成为Git大神很简单，读完这本书</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=1430218339" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[译文：理解Java中的弱引用]]></title>
    <link href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/"/>
    <updated>2014-10-12T09:56:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java</id>
    <content type="html"><![CDATA[<p>不久之前，我面试了一些求职Java高级开发工程师的应聘者。我常常会面试他们说，“你能给我介绍一些Java中得弱引用吗？”，如果面试者这样说，“嗯，是不是垃圾回收有关的？”，我就会基本满意了，我并不期待回答是一篇诘究本末的论文描述。</p>

<p>然而事与愿违，我很吃惊的发现，在将近20多个有着平均5年开发经验和高学历背景的应聘者中，居然只有两个人知道弱引用的存在，但是在这两个人之中只有一个人真正了解这方面的知识。在面试过程中，我还尝试提示一些东西，来看看有没有人突然说一声“原来是这个啊”，结果很是让我失望。我开始困惑，为什么这块的知识如此不被重视，毕竟弱引用是一个很有用途的特性，况且这个特性已经在7年前 Java 1.2发布时便引入了。</p>

<!--more-->


<p>好吧，这里我不期待你看完本文之后成为一个弱引用方面的专家，但是我认为至少你应该了解什么是弱引用，如何使用它们，并且什么场景使用。既然它们是一些不知名的概念，我简单就着前面的三个问题来说明一下。</p>

<h2>强引用(Strong Reference)</h2>

<p>强引用就是我们经常使用的引用，其写法如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">StringBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuffer</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面创建了一个StringBuffer对象，并将这个对象的（强）引用存到变量buffer中。是的，就是这个小儿科的操作（请原谅我这样的说法）。强引用最重要的就是它能够让引用变得强（Strong），这就决定了它和垃圾回收器的交互。具体来说，如果一个对象通过一串强引用链接可到达(Strongly reachable)，它是不会被回收的。如果你不想让你正在使用的对象被回收，这就正是你所需要的。</p>

<h3>但是强引用如此之强</h3>

<p>在一个程序里，将一个类设置成不可被扩展是有点不太常见的，当然这个完全可以通过类标记成final实现。或者也可以更加复杂一些，就是通过内部包含了未知数量具体实现的工厂方法返回一个接口(Interface)。举个例子，我们想要使用一个叫做Widget的类，但是这个类不能被继承，所以无法增加新的功能。</p>

<p>但是我们如果想追踪Widget对象的额外信息，我们该怎么办？ 假设我们需要记录每个对象的序列号，但是由于Widget类并不包含这个属性，而且也不能扩展导致我们也不能增加这个属性。其实一点问题也没有，HashMap完全可以解决上述的问题。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">serialNumberMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">widget</span><span class="o">,</span> <span class="n">widgetSerialNumber</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这表面看上去没有问题，但是widget对象的强引用很有可能会引发问题。我们可以确信当一个widget序列号不需要时，我们应该将这个条目从map中移除。如果我们没有移除的话，可能会导致内存泄露，亦或者我们手动移除时删除了我们正在使用的widgets，会导致有效数据的丢失。其实这些问题很类似，这就是没有垃圾回收机制的语言管理内存时常遇到的问题。但是我们不用去担心这个问题，因为我们使用的时具有垃圾回收机制的Java语言。</p>

<p>另一个强引用可能带来的问题就是缓存,尤其是像图片这样的大文件的缓存。假设你有一个程序需要处理用户提供的图片，通常的做法就是做图片数据缓存，因为从磁盘加载图片代价很大，并且同时我们也想避免在内存中同时存在两份一样的图片数据。</p>

<p>缓存被设计的目的就是避免我们去再次加载哪些不需要的文件。你会很快发现在缓存中会一直包含一个到已经指向内存中图片数据的引用。使用强引用会强制图片数据留在内存，这就需要你来决定什么时候图片数据不需要并且手动从缓存中移除，进而可以让垃圾回收器回收。因此你再一次被强制做垃圾回收器该做的工作，并且人为决定是该清理到哪一个对象。</p>

<h2>弱引用(Weak Reference)</h2>

<p>弱引用简单来说就是将对象留在内存的能力不是那么强的引用。使用WeakReference，垃圾回收器会帮你来决定引用的对象何时回收并且将对象从内存移除。创建弱引用如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">weakWidget</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;(</span><span class="n">widget</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用weakWidget.get()就可以得到真实的Widget对象，因为弱引用不能阻挡垃圾回收器对其回收，你会发现（当没有任何强引用到widget对象时）使用get时突然返回null。</p>

<p>解决上述的widget序列数记录的问题，最简单的办法就是使用Java内置的WeakHashMap类。WeakHashMap和HashMap几乎一样，唯一的区别就是它的键（不是值!!!）使用WeakReference引用。当WeakHashMap的键标记为垃圾的时候，这个键对应的条目就会自动被移除。这就避免了上面不需要的Widget对象手动删除的问题。使用WeakHashMap可以很便捷地转为HashMap或者Map。</p>

<h3>引用队列(Reference Queue)</h3>

<p>一旦弱引用对象开始返回null，该弱引用指向的对象就被标记成了垃圾。而这个弱引用对象（非其指向的对象）就没有什么用了。通常这时候需要进行一些清理工作。比如WeakHashMap会在这时候移除没用的条目来避免保存无限制增长的没有意义的弱引用。</p>

<p>引用队列可以很容易地实现跟踪不需要的引用。当你在构造WeakReference时传入一个ReferenceQueue对象，当该引用指向的对象被标记为垃圾的时候，这个引用对象会自动地加入到引用队列里面。接下来，你就可以在固定的周期，处理传入的引用队列，比如做一些清理工作来处理这些没有用的引用对象。</p>

<h2>四种引用</h2>

<p>Java中实际上有四种强度不同的引用，从强到弱它们分别是，强引用，软引用，弱引用和虚引用。上面部分介绍了强引用和弱引用，下面介绍剩下的两个，软引用和虚引用。</p>

<h2>软引用（Soft Reference）</h2>

<p>软引用基本上和弱引用差不多，只是相比弱引用，它阻止垃圾回收期回收其指向的对象的能力强一些。如果一个对象是弱引用可到达，那么这个对象会被垃圾回收器接下来的回收周期销毁。但是如果是软引用可以到达，那么这个对象会停留在内存更时间上长一些。当内存不足时垃圾回收器才会回收这些软引用可到达的对象。</p>

<p>由于软引用可到达的对象比弱引用可达到的对象滞留内存时间会长一些，我们可以利用这个特性来做缓存。这样的话，你就可以节省了很多事情，垃圾回收器会关心当前哪种可到达类型以及内存的消耗程度来进行处理。</p>

<h2>虚引用 （Phantom Reference）</h2>

<p>与软引用，弱引用不同，虚引用指向的对象十分脆弱，我们不可以通过get方法来得到其指向的对象。它的唯一作用就是当其指向的对象被回收之后，自己被加入到引用队列，用作记录该引用指向的对象已被销毁。</p>

<p>当弱引用的指向对象变得弱引用可到达，该弱引用就会加入到引用队列。这一操作发生在对象析构或者垃圾回收真正发生之前。理论上，这个即将被回收的对象是可以在一个不符合规范的析构方法里面重新复活。但是这个弱引用会销毁。虚引用只有在其指向的对象从内存中移除掉之后才会加入到引用队列中。其get方法一直返回null就是为了阻止其指向的几乎被销毁的对象重新复活。</p>

<p>虚引用使用场景主要由两个。它允许你知道具体何时其引用的对象从内存中移除。而实际上这是Java中唯一的方式。这一点尤其表现在处理类似图片的大文件的情况。当你确定一个图片数据对象应该被回收，你可以利用虚引用来判断这个对象回收之后在继续加载下一张图片。这样可以尽可能地避免可怕的内存溢出错误。</p>

<p>第二点，虚引用可以避免很多析构时的问题。finalize方法可以通过创建强引用指向快被销毁的对象来让这些对象重新复活。然而，一个重写了finalize方法的对象如果想要被回收掉，需要经历两个单独的垃圾收集周期。在第一个周期中，某个对象被标记为可回收，进而才能进行析构。但是因为在析构过程中仍有微弱的可能这个对象会重新复活。这种情况下，在这个对象真实销毁之前，垃圾回收器需要再次运行。因为析构可能并不是很及时，所以在调用对象的析构之前，需要经历数量不确定的垃圾收集周期。这就意味着在真正清理掉这个对象的时候可能发生很大的延迟。这就是为什么当大部分堆被标记成垃圾时还是会出现烦人的内存溢出错误。</p>

<p>使用虚引用，上述情况将引刃而解，当一个虚引用加入到引用队列时，你绝对没有办法得到一个销毁了的对象。因为这时候，对象已经从内存中销毁了。因为虚引用不能被用作让其指向的对象重生，所以其对象会在垃圾回收的第一个周期就将被清理掉。</p>

<p>显而易见，finalize方法不建议被重写。因为虚引用明显地安全高效，去掉finalize方法可以虚拟机变得明显简单。当然你也可以去重写这个方法来实现更多。这完全看个人选择。</p>

<h2>总结</h2>

<p>我想看到这里，很多人开始发牢骚了，为什么你要讲一个过去十年的老古董API呢，好吧，以我的经验看，很多的Java程序员并不是很了解这个知识，我认为有一些深入的理解是很必要的，同时我希望大家能从本文中收获一些东西。</p>

<h2>原文信息</h2>

<ul>
<li>文章出自  <a href="https://weblogs.java.net/blog/enicholas/archive/2006/05/understanding_w.html">Understanding Weak References</a></li>
<li>作者为<a href="https://www.java.net/blogs/enicholas">Ethan Nicholas</a>，Yahoo! Publishing Tools team Leader，Yahoo! SiteBuilder Web程序的早期作者。</li>
</ul>


<h2>附注信息</h2>

<p>本文涉及到很多概念对于初次接触的人相对比较难以理解，建议结合英文原文进行研究。</p>

<h3>Java高阶推荐</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00H1FXTNM/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00H1FXTNM&linkCode=as2&tag=droidyue-23">Java虚拟机规范(Java SE 7版)</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00H1FXTNM" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B00IOB0K1Q/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00IOB0K1Q&linkCode=as2&tag=droidyue-23">图灵程序设计丛书:Java性能优化权威指南</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00IOB0K1Q" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B00D2ID4PK/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00D2ID4PK&linkCode=as2&tag=droidyue-23">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00D2ID4PK" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[腾讯云分析问题]]></title>
    <link href="http://droidyue.com/blog/2014/10/12/tencent-analytics-issues/"/>
    <updated>2014-10-12T09:47:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/10/12/tencent-analytics-issues</id>
    <content type="html"><![CDATA[<p>今天使用腾讯云分析按照给出的文档开始集成，遇到了一个问题。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>E/AndroidRuntime<span class="o">(</span> 4606<span class="o">)</span>: FATAL EXCEPTION: pool-1-thread-1
</span><span class='line'>E/AndroidRuntime<span class="o">(</span> 4606<span class="o">)</span>: java.lang.NoClassDefFoundError: com.tencent.mid.api.MidService
</span><span class='line'>E/AndroidRuntime<span class="o">(</span> 4606<span class="o">)</span>:    at com.tencent.stat.j.run<span class="o">(</span>Unknown Source<span class="o">)</span>
</span><span class='line'>E/AndroidRuntime<span class="o">(</span> 4606<span class="o">)</span>:    at java.util.concurrent.ThreadPoolExecutor.runWorker<span class="o">(</span>ThreadPoolExecutor.java:1076<span class="o">)</span>
</span><span class='line'>E/AndroidRuntime<span class="o">(</span> 4606<span class="o">)</span>:    at java.util.concurrent.ThreadPoolExecutor<span class="nv">$Worker</span>.run<span class="o">(</span>ThreadPoolExecutor.java:569<span class="o">)</span>
</span><span class='line'>E/AndroidRuntime<span class="o">(</span> 4606<span class="o">)</span>:    at java.lang.Thread.run<span class="o">(</span>Thread.java:864<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<!--more-->


<h2>原因</h2>

<p>其实原因就是腾讯云分析的文档严重过时了，解决方法就是<strong>在Build Path 除了加入mta-sdk-x.x.x.jar,还要加入mid-sdk-x.x.jar</strong>。</p>

<p>但是腾讯的文档只介绍说集成mta-sdk-x.x.x.jar，我想可能那是大概0.x版本SDK的教程吧。</p>

<h2>吐个槽吧</h2>

<h3>霸王条款</h3>

<p>据说想要知道应用宝的下载数据（下载次数）必须集成腾讯云分析。这是在扛KPI，还是一贯的本性呢？</p>

<h3>过时冗余的文档</h3>

<p>前面提到了文档的严重过时失效，而且其文档存在严重的冗余，据我所知有三处文档，SDK下载包中一份，帮助中心一份，应用管理页面一份。如此这样，一旦修改，成本还是比较大的。</p>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00BSXRLR8/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00BSXRLR8&linkCode=as2&tag=droidyue-23">Android讲义哪家强</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00BSXRLR8" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B00LVHTI9U/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00LVHTI9U&linkCode=as2&tag=droidyue-23">每个人的第一行代码</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00LVHTI9U" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B0052VL2WC/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0052VL2WC&linkCode=as2&tag=droidyue-23">谁说菜鸟不会数据分析</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B0052VL2WC" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
</feed>
