<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/she-ji-mo-shi/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2015-12-24T23:10:05+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[这就是观察者模式]]></title>
    <link href="http://droidyue.com/blog/2015/06/27/desgign-pattern-observer/"/>
    <updated>2015-06-27T10:40:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/06/27/desgign-pattern-observer</id>
    <content type="html"><![CDATA[<p>观察者模式是软件设计模式中的一种，使用也比较普遍，尤其是在GUI编程中。关于设计模式的文章，网络上写的都比较多，而且很多文章写的也不错，虽然说有一种重复早轮子的嫌疑，但此轮子非彼轮子，侧重点不同，思路也不同，讲述方式也不近相同。</p>

<!--more-->


<h2>定义</h2>

<p>关于定义，最准确的莫过于<a href="http://www.amazon.cn/gp/product/B0011FBU34/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011FBU34&amp;linkCode=as2&amp;tag=droidyue-23">Head First设计模式</a>中写到的。</p>

<blockquote><p>观察者模式定义了一个一对多的依赖关系，让一个或多个观察者对象监听一个主题对象。这样一来，当被观察者状态发生改变时，需要通知相应的观察者，使这些观察者对象能够自动更新。</p></blockquote>

<h2>关键要素</h2>

<h3>主题</h3>

<p>主题是观察者观察的对象，一个主题必须具备下面三个特征。</p>

<ul>
<li>持有监听的观察者的引用</li>
<li>支持增加和删除观察者</li>
<li>主题状态改变，通知观察者</li>
</ul>


<h3>观察者</h3>

<p>当主题发生变化，收到通知进行具体的处理是观察者必须具备的特征。</p>

<h2>为什么要用这种模式</h2>

<p>这里举一个例子来说明，牛奶送奶站就是主题，订奶客户为监听者，客户从送奶站订阅牛奶后，会每天收到牛奶。如果客户不想订阅了，可以取消，以后就不会收到牛奶。</p>

<h3>松耦合</h3>

<ul>
<li>观察者增加或删除无需修改主题的代码，只需调用主题对应的增加或者删除的方法即可。</li>
<li>主题只负责通知观察者，但无需了解观察者如何处理通知。举个例子，送奶站只负责送递牛奶，不关心客户是喝掉还是洗脸。</li>
<li>观察者只需等待主题通知，无需观察主题相关的细节。还是那个例子，客户只需关心送奶站送到牛奶，不关心牛奶由哪个快递人员，使用何种交通工具送达。</li>
</ul>


<h3>通知不错过</h3>

<p>由于被动接受，正常情况下不会错过主题的改变通知。而主动获取的话，由于时机选取问题，可能导致错过某些状态。</p>

<h2>Java实现</h2>

<p>Java中有观察者模式使用的API</p>

<ul>
<li>java.util.Observable 这是一个类，而非接口，主题需要继承这个类。</li>
<li>java.util.Observer   这是一个接口，监听者需要实现这个接口。</li>
</ul>


<h3>示例代码</h3>

<p>```java
import java.util.Observable;
import java.util.Observer;
public class MainRoot {</p>

<pre><code>public static void main(String[] args) {
    Observer consumer = new Consumer();
    MilkProvider provider = new MilkProvider();
    provider.addObserver(consumer);
    provider.milkProduced();
}

static class MilkProvider extends Observable {
    public void milkProduced() {
        setChanged();//状态改变，必须调用
        notifyObservers();
    }
}

static class Consumer implements Observer {
    @Override
    public void update(Observable arg0, Object arg1) {
        System.out.println("Consumer update..." + arg0 + ";arg1=" + arg1);
    }
}
</code></pre>

<p>}
```
上述代码完成了</p>

<ul>
<li>将consumer加入主题provider的观察者行列</li>
<li>provider设置状态变化，通知持有的观察者</li>
<li>观察者consumer收到通知，打印日志处理</li>
</ul>


<h3>setChanged为何物</h3>

<p>其实上述代码中存在这样一处代码<code>setChanged();</code>，如果在通知之前没有调用这个方法，观察者是收不到通知的，这是为什么呢</p>

<p>这里我们看一下setChanged的源码
```java
protected synchronized void setChanged() {</p>

<pre><code>changed = true;
</code></pre>

<p>}
<code>
很简单，然后找一下谁使用changed这个值
</code>java
public synchronized boolean hasChanged() {</p>

<pre><code>return changed;
</code></pre>

<p>}
<code>
notifyObservers的代码
</code>java
public void notifyObservers(Object data) {</p>

<pre><code>int size = 0;
Observer[] arrays = null;
synchronized (this) {
    if (hasChanged()) {
        clearChanged();
        size = observers.size();
        arrays = new Observer[size];
        observers.toArray(arrays);
    }
}
if (arrays != null) {
    for (Observer observer : arrays) {
        observer.update(this, data);
    }
}
</code></pre>

<p>}
```
但是为什么要加入这样一个开关呢？可能原因大致有三点</p>

<p>  1.筛选有效通知，只有有效通知可以调用setChanged。比如，我的微信朋友圈一条状态，好友A点赞，后续该状态的点赞和评论并不是每条都通知A，只有A的好友触发的操作才会通知A。</p>

<p>  2.便于撤销通知操作，在主题中，我们可以设置很多次setChanged，但是在最后由于某种原因需要取消通知，我们可以使用clearChanged轻松解决问题。</p>

<p>  3.主动权控制，由于setChanged为protected,而notifyObservers方法为public，这就导致存在外部随意调用notifyObservers的可能，但是外部无法调用setChanged，因此真正的控制权应该在主题这里。</p>

<h3>主动获取</h3>

<p>观察者模式即所谓的推送方式，然而推送并非完美无缺。比如主题变化会推送大量的数据，而其中的一些观察者只需要某项数据，此时观察者就需要在具体实现中花费时间筛选数据。</p>

<p>这确实是个问题，想要解决也不难，需要主题为某些数据提供getter方法，观察者只需调用getter取数据处理即可。
```java
  static class MilkProvider extends Observable {</p>

<pre><code>public void milkProduced() {
  setChanged();//状态改变，必须调用
  notifyObservers();
}

public float getPrice() {
  return 2.5f;
}
</code></pre>

<p>  }</p>

<p>  static class Consumer implements Observer {</p>

<pre><code>@Override
public void update(Observable arg0, Object arg1) {
    MilkProvider provider = (MilkProvider)arg0;
    System.out.println("milk price =" + provider.getPrice());
}
</code></pre>

<p>  }
```</p>

<h2>不足与隐患</h2>

<p>主要的问题表现在内存管理上，主要由以下两点</p>

<ul>
<li>主题持有观察者的引用，如果未正常处理从主题中删除观察者，会导致观察者无法被回收。</li>
<li>如果观察者具体实现代码有问题，会导致主题和观察者对象形成循环引用，在某些采用引用计数的垃圾回收器可能导致无法回收。</li>
</ul>


<h2>书山有路</h2>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00INI842W/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00INI842W&amp;linkCode=as2&amp;tag=droidyue-23">设计模式之禅</a></li>
<li><a href="http://www.amazon.cn/gp/product/B0011FBU34/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011FBU34&amp;linkCode=as2&amp;tag=droidyue-23">Head First设计模式</a></li>
<li><a href="http://www.amazon.cn/gp/product/B001130JN8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001130JN8&amp;linkCode=as2&amp;tag=droidyue-23">设计模式 可复用面向对象软件的基础 </a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[说说依赖注入]]></title>
    <link href="http://droidyue.com/blog/2015/06/13/talk-show-about-dependency-injection/"/>
    <updated>2015-06-13T22:59:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/06/13/talk-show-about-dependency-injection</id>
    <content type="html"><![CDATA[<p>在面向对象编程中，我们经常处理处理的问题就是解耦，程序的耦合性越低表明这个程序的可读性以及可维护性越高。控制反转(Inversion of Control或IoC)就是常用的面向对象编程的设计原则，使用这个原则我们可以降低耦合性。其中依赖注入是控制反转最常用的实现。</p>

<!--more-->


<h2>什么是依赖</h2>

<p>依赖是程序中常见的现象，比如类Car中用到了GasEnergy类的实例energy，通常的做法就是在Car类中显式地创建GasEnergy类的实例，并赋值给energy。如下面的代码
```java
interface Energy {</p>

<p>}</p>

<p>class GasEnergy implements Energy {</p>

<p>}</p>

<p>class Car {</p>

<pre><code>Energy energy = new GasEnergy();
</code></pre>

<p>}
```</p>

<h2>存在问题</h2>

<ul>
<li>类Car承担了多余的责任，负责energy对象的创建，这必然存在了严重的耦合性。举一个现实中的例子，一辆汽车使用哪种能源不是由汽车来决定，而是由汽车制造商（CarMaker）来决定，这是汽车制造商的责任。</li>
<li>可扩展性，假设我们想修改能源为电动力，那么我们必然要修改Car这个类，明显不符合开放闭合原则。</li>
<li>不利于单元测试。</li>
</ul>


<h2>依赖注入</h2>

<p>依赖注入是这样的一种行为，在类Car中不主动创建GasEnergy的对象，而是通过外部传入GasEnergy对象形式来设置依赖。
常用的依赖注入有如下三种方式</p>

<h3>构造器注入</h3>

<p>将需要的依赖作为构造方法的参数传递完成依赖注入。
```java
class Car {</p>

<pre><code>Energy mEnergy;
public Car(Energy energy) {
    mEnergy = energy;
}
</code></pre>

<p>}
```</p>

<h3>Setter方法注入</h3>

<p>增加setter方法，参数为需要注入的依赖亦可完成依赖注入。
```java
class Car {</p>

<pre><code>Energy mEnergy;

public void setEnergy(Energy energy) {
    mEnergy  = energy;
}
</code></pre>

<p>}
```</p>

<h3>接口注入</h3>

<p>接口注入，闻其名不言而喻，就是为依赖注入创建一套接口，依赖作为参数传入，通过调用统一的接口完成对具体实现的依赖注入。
```java
interface EnergyConsumerInterface {</p>

<pre><code>public void setEnergy(Energy energy);
</code></pre>

<p>}</p>

<p>class Car implements EnergyConsumerInterface {</p>

<pre><code>Energy mEnergy;

public void setEnergy(Energy energy) {
    mEnergy  = energy;
}
</code></pre>

<p>}
```
接口注入和setter方法注入类似，不同的是接口注入使用了统一的方法来完成注入，而setter方法注入的方法名称相对比较随意。</p>

<h2>框架取舍</h2>

<p>依赖注入有很多框架，最有名的就是Guice，当然Spring也支持依赖注入。Guice采用的是运行时读取注解，通过反射的形式生成依赖并进行注入。这种形式不太适合Android移动设备，毕竟这些操作都在运行时处理，对性能要求较高。</p>

<p>Dagger则是Android开发适合的依赖注入库，其同样采用类注解的形式，不同的是它是在编译时生成辅助类，等到在运行时使用生成的辅助类完成依赖注入。</p>

<h3>用还是不用</h3>

<p>其实注入框架用还是不用，是一个问题，如若使用框架，则要求团队每一个人都要遵守说明来编写代码解决依赖注入。而这些框架其实也并非很容易就能上手，学习系数相对复杂，难以掌握，这也是需要考虑的问题。</p>

<p>个人观点为不推荐也不反对使用这些框架，但是觉得有些时候我们寄希望于一个框架，不如平时注意这些问题，人为避免何尝不是对自己的一种基本要求呢？</p>

<h2>依赖查找</h2>

<p>依赖查找和依赖注入一样属于控制反转原则的具体实现，不同于依赖注入的被动接受，依赖查找这是主动请求，在需要的时候通过调用框架提供的方法来获取对象，获取时需要提供相关的配置文件路径、key等信息来确定获取对象的状态。</p>

<h2>书籍推荐</h2>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B004G8P90S/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B004G8P90S&amp;linkCode=as2&amp;tag=droidyue-23">研磨设计模式</a></li>
<li><a href="http://www.amazon.cn/gp/product/B00INI842W/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00INI842W&amp;linkCode=as2&amp;tag=droidyue-23">设计模式之禅</a></li>
<li><a href="http://www.amazon.cn/gp/product/B0011FBU34/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011FBU34&amp;linkCode=as2&amp;tag=droidyue-23">Head First设计模式</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单例这种设计模式]]></title>
    <link href="http://droidyue.com/blog/2015/01/11/looking-into-singleton/"/>
    <updated>2015-01-11T22:15:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/01/11/looking-into-singleton</id>
    <content type="html"><![CDATA[<p>随着我们编写代码的深入，我们或多或少都会接触到设计模式，其中单例(Singleton)模式应该是我们耳熟能详的一种模式。本文将比较特别的介绍一下Java设计模式中的单例模式。</p>

<!--more-->


<h2>概念</h2>

<p>单例模式，又称单件模式或者单子模式，指的是一个类只有一个实例，并且提供一个全局访问点。</p>

<h2>实现思路</h2>

<ul>
<li>在单例的类中设置一个private静态变量sInstance，sInstance类型为当前类，用来持有单例唯一的实例。</li>
<li>将（无参数）构造器设置为private，避免外部使用new构造多个实例。</li>
<li>提供一个public的静态方法，如getInstance，用来返回该类的唯一实例sInstance。</li>
</ul>


<p>其中上面的单例的实例可以有以下几种创建形式，每一种实现都需要保证实例的唯一性。</p>

<h3>饿汉式</h3>

<p>饿汉式指的是单例的实例在类装载时进行创建。如果单例类的构造方法中没有包含过多的操作处理，饿汉式其实是可以接受的。</p>

<p>饿汉式的常见代码如下,当SingleInstance类加载时会执行<code>private static SingleInstance sInstance = new SingleInstance();</code>初始化了唯一的实例，然后<code>getInstance()</code>直接返回sInstance即可。</p>

<p>```java
public class SingleInstance {</p>

<pre><code>private static SingleInstance sInstance = new SingleInstance();

private SingleInstance() {
}

public static SingleInstance getInstance() {
    return sInstance;
}
</code></pre>

<p>}
```</p>

<p>饿汉式的问题</p>

<ul>
<li>如果构造方法中存在过多的处理，会导致加载这个类时比较慢，可能引起性能问题。</li>
<li>如果使用饿汉式的话，只进行了类的装载，并没有实质的调用，会造成资源的浪费。</li>
</ul>


<h3>懒汉式</h3>

<p>懒汉式指的是单例实例在第一次使用时进行创建。这种情况下避免了上面饿汉式可能遇到的问题。</p>

<p>但是考虑到多线程的并发操作，我们<strong>不能</strong>简简单单得像下面代码实现。
```java
public class SingleInstance {</p>

<pre><code>private static SingleInstance sInstance;
private SingleInstance() {
}

public static SingleInstance getInstance() {
    if (null == sInstance) {
        sInstance = new SingleInstance();
    }
    return sInstance;
}
</code></pre>

<p>}
<code>``
上述的代码在多个线程密集调用getInstance时，存在创建多个实例的可能。比如线程A进入</code>null == sInstance`这段代码块，而在A线程未创建完成实例时，如果线程B也进入了该代码块，必然会造成两个实例的产生。</p>

<h3>synchronized修饰方法</h3>

<p>使用synchrnozed修饰getInstance方法可能是最简单的一个保证多线程保证单例唯一性的方法。<br/>
synchronized修饰的方法后，当某个线程进入调用这个方法，该线程只有当其他线程离开当前方法后才会进入该方法。所以可以保证getInstance在任何时候只有一个线程进入。
```java
public class SingleInstance {</p>

<pre><code>private static SingleInstance sInstance;
private SingleInstance() {
}

public static synchronized SingleInstance getInstance() {
    if (null == sInstance) {
        sInstance = new SingleInstance();
    }
    return sInstance;
}
</code></pre>

<p>}
```
但是使用synchronized修饰getInstance方法后必然会导致性能下降，而且getInstance是一个被频繁调用的方法。虽然这种方法能解决问题，但是不推荐。</p>

<h4>双重检查加锁</h4>

<p>使用双重检查加锁，首先进入该方法时进行<code>null == sInstance</code>检查，如果第一次检查通过，即没有实例创建，则进入synchronized控制的同步块,并再次检查实例是否创建，如果仍未创建，则创建该实例。</p>

<p>双重检查加锁保证了多线程下只创建一个实例，并且加锁代码块只在实例创建的之前进行同步。如果实例已经创建后，进入该方法，则不会执行到同步块的代码。
```java
public class SingleInstance {</p>

<pre><code>private static volatile SingleInstance sInstance;
private SingleInstance() {
}

public static SingleInstance getInstance() {
    if (null == sInstance) {
        synchronized (SingleInstance.class) {
            if (null == sInstance) {
                sInstance = new SingleInstance();
            }
        }
    }
    return sInstance;
}
</code></pre>

<p>}
```
<strong>volatile是什么</strong></p>

<p>Volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。使用volatile修饰sInstance变量之后，可以确保多个线程之间正确处理sInstance变量。<br/>
关于volatile，可以访问<a href="http://www.infoq.com/cn/articles/ftf-java-volatile">深入分析Volatile的实现原理</a>了解更多。</p>

<h3>利用static机制</h3>

<p>在Java中，类的静态初始化会在类被加载时触发，我们利用这个原理，可以实现利用这一特性，结合内部类，可以实现如下的代码，进行懒汉式创建实例。
```java
public class SingleInstance {</p>

<pre><code>private SingleInstance() {
}

public static SingleInstance getInstance() {
    return SingleInstanceHolder.sInstance;
}

private static class SingleInstanceHolder {
    private static SingleInstance sInstance = new SingleInstance();
}
</code></pre>

<p>}
```
关于这种机制，可以具体了解<a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization">双重检查锁定与延迟初始化</a></p>

<h2>好奇问题</h2>

<h3>真的只有一个对象么</h3>

<p>其实，单例模式并不能保证实例的唯一性，只要我们想办法的话，还是可以打破这种唯一性的。以下几种方法都能实现。</p>

<ul>
<li>使用反射，虽然构造器为非公开，但是在反射面前就不起作用了。</li>
<li>如果单例的类实现了cloneable，那么还是可以拷贝出多个实例的。</li>
<li>Java中的对象序列化也有可能导致创建多个实例。避免使用readObject方法。</li>
<li>使用多个类加载器加载单例类，也会导致创建多个实例并存的问题。</li>
</ul>


<h3>单例可以继承么</h3>

<p>单例类能否被继承需要分情况而定。</p>

<h4>可以继承的情况</h4>

<p>当子类是父类单例类的内部类时，继承是可以的。
```java
public class BaseSingleton {</p>

<pre><code>private static volatile BaseSingleton sInstance;

private BaseSingleton() {

}

public static BaseSingleton getInstance() {
    if (null == sInstance) {
        synchronized(BaseSingleton.class) {
            if (null == sInstance) {
                sInstance = new BaseSingleton();
            }
        }
    }
    return sInstance;
}

public static class  MySingleton extends BaseSingleton {

}
</code></pre>

<p>}
```
但是上面仅仅是编译和执行上允许的，但是继承单例没有实际的意义，反而会变得更加事倍功半，其代价要大于新写一个单例类。感兴趣的童鞋可以尝试折腾一下。</p>

<h4>不可以继承的情况</h4>

<p>如果子类为单独的类，非单例类的内部类的话，那么在编译时就会出错<code>Implicit super constructor BaseSingleton() is not visible for default constructor. Must define an explicit constructor</code>，主要原因是单例类的构造器是private，解决方法是讲构造器设置为可见，但是这样做就无法保证单例的唯一性。所以这种方式不可以继承。</p>

<p>总的来说，单例类不要继承。</p>

<h3>单例 vs static变量</h3>

<p>全局静态变量也可以实现单例的效果，但是使用全局变量无法保证只创建一个实例，而且使用全局变量的形式，需要团队的约束，执行起来可能会出现问题。</p>

<h3>关于GC</h3>

<p>因为单例类中又一个静态的变量持有单例的实例，所以相比普通的对象，单例的对象更不容易被GC回收掉。单例对象的回收应该发生在其类加载器被GC回收掉之后，一般不容易出现。</p>

<h2>相关阅读</h2>

<ul>
<li><a href="http://javarevisited.blogspot.sg/2011/03/10-interview-questions-on-singleton.html">10 Singleton Pattern Interview Questions in Java</a></li>
</ul>


<h2>一本书</h2>

<p><a href="http://www.amazon.cn/gp/product/B0011FBU34/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011FBU34&amp;linkCode=as2&amp;tag=droidyue-23">Head First设计模式</a>,本书荣获2005年第十五届Jolt通用类图书震撼大奖。本书英文影印版被《程序员》等机构评选为2006年最受读者喜爱的十大IT图书之一 。本书趋近完美，因为它在提供专业知识的同时，仍然具有相当高的可读性。叙述权威、文笔优美。</p>
]]></content>
  </entry>
  
</feed>
