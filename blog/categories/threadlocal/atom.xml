<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ThreadLocal | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/threadlocal/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2016-03-13T20:39:34+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[理解Java中ThreadLocal]]></title>
    <link href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/"/>
    <updated>2016-03-13T20:21:00+08:00</updated>
    <id>http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java</id>
    <content type="html"><![CDATA[<p>提到ThreadLocal，有些Android或者Java程序员可能有所陌生，可能会提出种种问题，它是做什么的，是不是和线程有关，怎么使用呢？等等问题，本文将总结一下我对ThreadLocal的理解和认识，希望让大家理解ThreadLocal更加透彻一些。</p>

<!--more-->


<h2>ThreadLocal是什么</h2>

<p>ThreadLocal是一个关于创建线程局部变量的类。</p>

<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。</p>

<h2>Global &amp;&amp; Local</h2>

<p>上面的两个修饰看似矛盾，实则不然。</p>

<ul>
<li>Global 意思是在当前线程中，任何一个点都可以访问到ThreadLocal的值。</li>
<li>Local 意思是该线程的ThreadLocal只能被该线程访问，一般情况下其他线程访问不到。</li>
</ul>


<h2>用法简介</h2>

<h3>创建，支持泛型</h3>

<p><code>java
ThreadLocal&lt;String&gt; mStringThreadLocal = new ThreadLocal&lt;&gt;();
</code></p>

<h3>set方法</h3>

<p><code>java
mStringThreadLocal.set("droidyue.com");
</code></p>

<h3>get方法</h3>

<p><code>java
mStringThreadLocal.get();
</code></p>

<p>完整的使用示例
```java
private void testThreadLocal() {</p>

<pre><code>Thread t = new Thread() {
    ThreadLocal&lt;String&gt; mStringThreadLocal = new ThreadLocal&lt;&gt;();

    @Override
    public void run() {
        super.run();
        mStringThreadLocal.set("droidyue.com");
        mStringThreadLocal.get();
    }
};

t.start();
</code></pre>

<p>}
```</p>

<h3>ThreadLocal初始值</h3>

<p>为ThreadLocal设置默认的get初始值，需要重写<code>initialValue</code>方法，下面是一段代码，我们将默认值修改成了线程的名字
```java
ThreadLocal<String> mThreadLocal = new ThreadLocal<String>() {</p>

<pre><code>@Override
protected String initialValue() {
    return Thread.currentThread().getName();
}
</code></pre>

<p>};
```</p>

<h2>Android中的应用</h2>

<p>在Android中，Looper类就是利用了ThreadLocal的特性，保证每个线程只存在一个Looper对象。
```java
static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();
private static void prepare(boolean quitAllowed) {</p>

<pre><code>if (sThreadLocal.get() != null) {
    throw new RuntimeException("Only one Looper may be created per thread");
}
sThreadLocal.set(new Looper(quitAllowed));
</code></pre>

<p>}
```</p>

<h2>如何实现</h2>

<p>为了更好的掌握ThreadLocal，我认为了解其内部实现是很有必要的，这里我们以set方法从起始看一看ThreadLocal的实现原理。</p>

<p>下面是ThreadLocal的set方法，大致意思为</p>

<ul>
<li>首先获取当前线程</li>
<li>利用当前线程作为句柄获取一个ThreadLocalMap的对象</li>
<li>如果上述ThreadLocalMap对象不为空，则设置值，否则创建这个ThreadLocalMap对象并设置值</li>
</ul>


<p>源码如下
```java
public void set(T value) {</p>

<pre><code>Thread t = Thread.currentThread();
ThreadLocalMap map = getMap(t);
if (map != null)
    map.set(this, value);
else
    createMap(t, value);
</code></pre>

<p>}
```</p>

<p>下面是一个利用Thread对象作为句柄获取ThreadLocalMap对象的代码</p>

<p>```java
ThreadLocalMap getMap(Thread t) {</p>

<pre><code>return t.threadLocals;
</code></pre>

<p>}
```</p>

<p>上面的代码获取的实际上是Thread对象的threadLocals变量，可参考下面代码
```java
class Thread implements Runnable {</p>

<pre><code>/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */

ThreadLocal.ThreadLocalMap threadLocals = null;
</code></pre>

<p>}
```</p>

<p>而如果一开始设置，即ThreadLocalMap对象未创建，则新建ThreadLocalMap对象，并设置初始值。
```java
void createMap(Thread t, T firstValue) {</p>

<pre><code>t.threadLocals = new ThreadLocalMap(this, firstValue);
</code></pre>

<p>}
```</p>

<p>总结：实际上ThreadLocal的值是放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问，其他线程无法访问。</p>

<h2>对象存放在哪里</h2>

<p>在Java中，栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</p>

<h3>问：那么是不是说ThreadLocal的实例以及其值存放在栈上呢？</h3>

<p>其实不是，因为ThreadLocal实例实际上也是被其创建的类持有（更顶端应该是被线程持有）。而ThreadLocal的值其实也是被线程实例持有。</p>

<p><strong>它们都是位于堆上，只是通过一些技巧将可见性修改成了线程可见。</strong></p>

<p>关于堆和栈的比较，请参考<a href="http://droidyue.com/blog/2014/12/07/differences-between-stack-and-heap-in-java/">Java中的堆和栈的区别</a></p>

<h2>真的只能被一个线程访问么</h2>

<p>既然上面提到了ThreadLocal只对当前线程可见，是不是说ThreadLocal的值只能被一个线程访问呢？</p>

<p>使用InheritableThreadLocal可以实现多个线程访问ThreadLocal的值。</p>

<p>如下，我们在主线程中创建一个InheritableThreadLocal的实例，然后在子线程中得到这个InheritableThreadLocal实例设置的值。</p>

<p>```java
private void testInheritableThreadLocal() {</p>

<pre><code>final ThreadLocal threadLocal = new InheritableThreadLocal();
threadLocal.set("droidyue.com");
Thread t = new Thread() {
    @Override
    public void run() {
        super.run();
        Log.i(LOGTAG, "testInheritableThreadLocal =" + threadLocal.get());
    }
};

t.start();
</code></pre>

<p>}
<code>
上面的代码输出的日志信息为
</code>
I/MainActivity( 5046): testInheritableThreadLocal =droidyue.com
<code>
使用InheritableThreadLocal可以将某个线程的ThreadLocal值在其子线程创建时传递过去。因为在线程创建过程中，有相关的处理逻辑。
</code>java
//Thread.java
 private void init(ThreadGroup g, Runnable target, String name,</p>

<pre><code>                  long stackSize, AccessControlContext acc) {
    //code goes here
    if (parent.inheritableThreadLocals != null)
        this.inheritableThreadLocals =
            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
    /* Stash the specified stack size in case the VM cares */
    this.stackSize = stackSize;

    /* Set thread ID */
    tid = nextThreadID();
</code></pre>

<p>}
```
上面代码就是在线程创建的时候，复制父线程的inheritableThreadLocals的数据。</p>

<h2>会导致内存泄露么</h2>

<p>有网上讨论说ThreadLocal会导致内存泄露，原因如下</p>

<ul>
<li>首先ThreadLocal实例被线程的ThreadLocalMap实例持有，也可以看成被线程持有。</li>
<li>如果应用使用了线程池，那么之前的线程实例处理完之后出于复用的目的依然存活</li>
<li>所以，ThreadLocal设定的值被持有，导致内存泄露。</li>
</ul>


<p>上面的逻辑是清晰的，可是ThreadLocal并不会产生内存泄露，因为ThreadLocalMap做选择key的时候，并不是直接选择ThreadLocal实例，而是ThreadLocalMap实例的弱引用。
```java
static class ThreadLocalMap {</p>

<p>/<em>*
* The entries in this hash map extend WeakReference, using
* its main ref field as the key (which is always a
* ThreadLocal object).  Note that null keys (i.e. entry.get()
* == null) mean that the key is no longer referenced, so the
* entry can be expunged from table.  Such entries are referred to
* as &ldquo;stale entries&rdquo; in the code that follows.
</em>/</p>

<pre><code>static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
    /** The value associated with this ThreadLocal. */
    Object value;

    Entry(ThreadLocal&lt;?&gt; k, Object v) {
        super(k);
        value = v;
    }
}
</code></pre>

<p>}
```
所以实际上从ThreadLocal设计角度来说是不会导致内存泄露的。关于弱引用，了解更多，请访问<a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">译文：理解Java中的弱引用
</a></p>

<h2>使用场景</h2>

<ul>
<li>实现单个线程单例以及单个线程上下文信息存储，比如交易id等</li>
<li>实现线程安全，非线程安全的对象使用ThreadLocal之后就会变得线程安全，因为每个线程都会有一个对应的实例</li>
<li>承载一些线程相关的数据，避免在方法中来回传递参数</li>
</ul>


<h2>参考文章</h2>

<ul>
<li><a href="http://tutorials.jenkov.com/java-concurrency/threadlocal.html">Java ThreadLocal</a></li>
<li><a href="http://cs.oswego.edu/pipermail/concurrency-interest/2007-October/004456.html">Threadlocals and memory leaks in J2EE</a></li>
<li><a href="http://veerasundar.com/blog/2010/11/java-thread-local-how-to-use-and-code-sample/">Java Thread Local – How to use and code sample</a></li>
<li><a href="http://javarevisited.blogspot.hk/2012/05/how-to-use-threadlocal-in-java-benefits.html">ThreadLocal in Java &ndash; Example Program and Tutorial</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
