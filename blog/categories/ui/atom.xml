<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: UI | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/ui/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2014-10-21T21:10:54+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android UI之自定义Window Title样式]]></title>
    <link href="http://droidyue.com/blog/2014/08/14/style-android-window-title/"/>
    <updated>2014-08-14T20:07:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/08/14/style-android-window-title</id>
    <content type="html"><![CDATA[<p>Android提供了很多控件便于开发者进行UI相关的程序设计。但是很多时候，默认的一些UI设置不足以满足我们的需求，要么不好看，要么高度不够，亦或者是与应用界面不协调。于是这时候需要通过自定义样式或者自定义控件来实现。</p>

<p>当然，在空间足以满足需求的情况下，通常需要定义样式就可以搞定。本文将简单介绍如何通过自定义样式来实现定义Window Title。</p>

<!--more-->


<h2>先看一下效果图</h2>

<p><img class="<a" src="href="http://droidyueimg.qiniudn.com/style_window_title.png">http://droidyueimg.qiniudn.com/style_window_title.png</a>" title="Custom Window Title Using Style" ></p>

<h2>逐步实现</h2>

<p>在<strong>res/values/styles.xml</strong>文件中加入下列代码
```xml lineos:false res/values/styles.xml</p>

<p> <style name="MyActivityTheme" parent="android:Theme.Light" ></p>

<pre><code>    &lt;item name="android:windowTitleBackgroundStyle"&gt;@style/windowTitleBackgroundStyle&lt;/item&gt;
    &lt;item name="android:windowTitleStyle"&gt;@style/windowTitleStyle&lt;/item&gt;
    &lt;!-- Window Header Height --&gt;
    &lt;item name="android:windowTitleSize"&gt;54dp&lt;/item&gt;
&lt;/style&gt;

&lt;!-- Preference Settings Window Title --&gt;
&lt;style name="windowTitleBackgroundStyle"&gt;  
    &lt;item name="android:background"&gt;#CCE8CF&lt;/item&gt;                
&lt;/style&gt;

&lt;style name="windowTitleStyle"&gt;
    &lt;item name="android:textColor"&gt;#FF0000&lt;/item&gt;
    &lt;item name="android:paddingLeft"&gt;25dp&lt;/item&gt;
    &lt;item name="android:textSize"&gt;20sp&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p><code>
在Manifest中指定Activity或者Application的主题为上面定义的MyActivityTheme，下面以设置Activity为例。
</code>xml lineos:false
&lt;activity</p>

<pre><code>android:name="com.example.stylewindowtitle.MainActivity"
android:label="@string/app_name"
android:theme="@style/MyActivityTheme"
</code></pre>

<blockquote></blockquote>

<!--code goes here-->


<p>```</p>

<h2>延伸阅读</h2>

<p><a href="http://developer.android.com/reference/android/R.attr.html" target="_blank">Android中的属性</a></p>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00D73BJWK/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00D73BJWK&linkCode=as2&tag=droidyue-23">浪潮之巅</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00D73BJWK" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B004Y4QWMS/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004Y4QWMS&linkCode=as2&tag=droidyue-23">启示录:打造用户喜爱的产品</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B004Y4QWMS" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/0307463745/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=0307463745&linkCode=as2&tag=droidyue-23">Rework</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=0307463745" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义支持读取XML属性的View]]></title>
    <link href="http://droidyue.com/blog/2014/08/05/create-your-view-with-supporting-xml-attribute/"/>
    <updated>2014-08-05T19:12:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/08/05/create-your-view-with-supporting-xml-attribute</id>
    <content type="html"><![CDATA[<p>在Android中，添加一个View很简单，简单的你可以简简单单地使用xml和一部分简单的java代码就可以搞定。
比如这样</p>

<!--more-->


<p>```xml linenos:false
&lt;RelativeLayout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:paddingBottom="@dimen/activity_vertical_margin"
android:paddingLeft="@dimen/activity_horizontal_margin"
android:paddingRight="@dimen/activity_horizontal_margin"
android:paddingTop="@dimen/activity_vertical_margin"
tools:context=".MainActivity" &gt;

&lt;TextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/hello_world" 
    /&gt;
</code></pre>

<p></RelativeLayout>
```
Android Framework提供了这种便捷的xml布局方式，而且还可以支持从XML节点读取属性值。那么如果如何自定义View并且支持读取XML属性值呢。<br/>
下面开始尝试以一种很简单容易理解的方式介绍一下。</p>

<h2>自定义View代码实现</h2>

<p>比如我们自定义一个View，这个View继承自TextView，名称为ExTextView。这里我们创建简单的构造方法，仅仅包含Context和AttributeSet参数。这样我们就可以在布局编辑器中创建或者修改ExTextView的实例。
```java  linenos:false ExTextView.java
package com.example.customviewwithxml;</p>

<p>import android.content.Context;
import android.util.AttributeSet;
import android.widget.TextView;</p>

<p>public class ExTextView extends TextView {</p>

<pre><code>public ExTextView(Context context, AttributeSet attrs) {
    super(context, attrs);
}
</code></pre>

<p>}
```</p>

<h3>定义XML属性</h3>

<p>在使用系统内置的View时，我们可以通过在XML布局文件中指定属性来控制View的样式和行为。一个优秀的View应该可以通过XML来添加并且设置样式。所以，要让你自定义的View做到上述功能，你需要做。</p>

<ul>
<li>通过<code>&lt;declare-styleable&gt;</code> 来定义自定义View的属性集。</li>
<li>可以在布局文件中指定View的属性值。</li>
<li>在程序运行时可以检索读取属性值。</li>
<li>为View应用读取出来的属性值。</li>
</ul>


<p>现在就为你的View添加<code>&lt;declare-styleable&gt;</code>来定义属性集哈。 其存放文件为 <strong>res/values/attrs.xml</strong>。以下为几个简单实例。
```xml linenos:false attrs.xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<resources></p>

<pre><code>&lt;attr name="enableOnPad" format="boolean" /&gt;
&lt;attr name="supportDeviceType" format="reference"/&gt;
&lt;declare-styleable name="ExTextView"&gt;
    &lt;attr name="enableOnPad"/&gt;
    &lt;attr name="supportDeviceType"/&gt;
&lt;/declare-styleable&gt;
</code></pre>

<p></resources>
```</p>

<h3>注意</h3>

<ul>
<li><code>&lt;declare-styleable name="ExTextView"&gt;</code>中ExTextView为样式实体的名字，例样式实体的名字没有特殊的限制，但是通常约定为View的类名。</li>
</ul>


<h2>布局中使用自定义View</h2>

<p>一旦我们定义了属性值，我们可以想系统内置的属性值一样使用，唯一不同的是，自定义的属性值和系统提供的属于不同的名字空间。系统内置的属性归属于名字空间<code>http://schemas.android.com/apk/res/android</code> 而自定义的属性归属于名字空间<strong><code>http://schemas.android.com/apk/res/[your package name]</code></strong>
```xml linenos:false activity_main.xml
&lt;RelativeLayout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>xmlns:tools="http://schemas.android.com/tools"
xmlns:droidyue="http://schemas.android.com/apk/res/com.example.customviewwithxml"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:paddingBottom="@dimen/activity_vertical_margin"
android:paddingLeft="@dimen/activity_horizontal_margin"
android:paddingRight="@dimen/activity_horizontal_margin"
android:paddingTop="@dimen/activity_vertical_margin"
tools:context=".MainActivity" &gt;

&lt;TextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/hello_world" 
    /&gt;

&lt;com.example.customviewwithxml.ExTextView 
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Hello World"
    droidyue:supportDeviceType="@array/support_device_types"    
    droidyue:enableOnPad="true"

    /&gt;    
</code></pre>

<p></RelativeLayout>
```</p>

<h2>读取XML属性值</h2>

<p>当View从XML中被创建时，其所有标签的属性值都是以AttributeSet的对象从资源包中获取并传递。</p>

<h3>为什么不直接读取AttributeSet，而是obtainStyledAttributes</h3>

<ul>
<li>属性值中得资源引用不能解析</li>
<li>样式不会应用到View</li>
</ul>


<p>```java linenos:false  ExTextView.java
public ExTextView(Context context, AttributeSet attrs) {</p>

<pre><code>    super(context, attrs);
    TypedArray a = context.getTheme().obtainStyledAttributes(
            attrs,R.styleable.ExTextView,
            0, 0);
    int supportDevicesResId = a.getResourceId(R.styleable.ExTextView_supportDeviceType, 0);
    String[] supportDeviceTypes = context.getResources().getStringArray(supportDevicesResId);
    boolean enableOnPad = a.getBoolean(R.styleable.ExTextView_enableOnPad, false);
    Log.i(VIEW_LOG_TAG, "getAtrributeFromXml supportDeviceType=" + Arrays.toString(supportDeviceTypes) + ";enableOnPad=" + enableOnPad);
    a.recycle();
}
</code></pre>

<p>```
注意，TypedArray实例为公用资源，再次使用之前需要回收（recycle）。</p>

<h2>延伸阅读</h2>

<p><a href="http://developer.android.com/training/custom-views/create-view.html" target="_blank">Create View</a></p>

<h2>源码下载</h2>

<p><a href="http://pan.baidu.com/s/1c0gXfw8" target="_blank">百度云</a></p>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00ASIN7G8/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00ASIN7G8&linkCode=as2&tag=droidyue-23">如何才能精通Android</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00ASIN7G8" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B009OLU8EE/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009OLU8EE&linkCode=as2&tag=droidyue-23">你能看懂Android系统源代码么</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009OLU8EE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B00LVHTI9U/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00LVHTI9U&linkCode=as2&tag=droidyue-23">第一行代码:Android</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00LVHTI9U" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中自定义Checkbox]]></title>
    <link href="http://droidyue.com/blog/2014/07/27/change-default-image-of-checkbox-on-android/"/>
    <updated>2014-07-27T14:06:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/27/change-default-image-of-checkbox-on-android</id>
    <content type="html"><![CDATA[<p>在Android中，Checkbox是一个很重要的UI组件，而且在Android中，它展现的形式越来越好看，这就说明有些系统，比如4.0以下，checkbox还是比较不好看，或者跟软件的风格不协调，就需要我们自定义这个组件。</p>

<p>自定义这个组件很简单，简单的增加修改xml文件即可。</p>

<!--more-->


<h2>准备工作</h2>

<p>准备好两张图片，一个是选中的图片，另一个是未选中的图片。本文以checked.png和unchecked.png为例。</p>

<h2>设置选择框</h2>

<p>在drawable下新建文件custom_checkbox.xml
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<selector xmlns:android="http://schemas.android.com/apk/res/android" ></p>

<pre><code>&lt;item android:state_checked="true" android:drawable="@drawable/checked"&gt;&lt;/item&gt;
&lt;item android:state_checked="false" android:drawable="@drawable/unchecked"&gt;&lt;/item&gt;
&lt;item android:drawable="@drawable/unchecked"&gt;&lt;/item&gt;&lt;!-- The default one --&gt;
</code></pre>

<p></selector>
```</p>

<h2>应用自定义</h2>

<p>设置button属性值为上面定义的custom_checkbox。
```xml
&lt;CheckBox</p>

<pre><code>android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:button="@drawable/custom_checkbox"
</code></pre>

<p>/>
```</p>

<p>自定义完毕，跑起来你的程序吧。</p>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00FQEDTA8/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00FQEDTA8&linkCode=as2&tag=droidyue-23">从响应用户交互出发，设计Android的UI</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00FQEDTA8" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B009NKMGTG/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009NKMGTG&linkCode=as2&tag=droidyue-23">一个都不能少的Android UI基础教程</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009NKMGTG" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[超简单实现Google+列表特效]]></title>
    <link href="http://droidyue.com/blog/2014/07/26/apply-google-plus-list-style-on-android/"/>
    <updated>2014-07-26T10:32:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/26/apply-google-plus-list-style-on-android</id>
    <content type="html"><![CDATA[<p>相信用过Google+的人都感到其应用的特效相当棒，本文将以超简单的形式来实现类似Google+列表的特效。仅仅写几行代码就可以实现奥。</p>

<h2>特效真面目</h2>

<p>由于众所周知的原因，很多人无法使用Google+应用。所以有必要让大家先看一看真面目。</p>

<!--more-->


<p>P.S.找了很多的屏目录制软件都不行，并且没有4.4的机器，所以只能用最笨的方法录制了，请见谅哈。</p>

<iframe height=498 width=510 src="http://player.youku.com/embed/XNzQ2MzAzNjIw" frameborder=0 allowfullscreen></iframe>


<h2>特效动画</h2>

<h3>from_bottom_to_top.xml</h3>

<p>```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;set xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code> android:shareInterpolator="@android:anim/decelerate_interpolator"&gt;
&lt;translate
    android:fromXDelta="0%" android:toXDelta="0%"
    android:fromYDelta="100%" android:toYDelta="0%"
    android:duration="400" /&gt;
</code></pre>

<p></set></p>

<p>```</p>

<h3>from_top_to_bottom.xml</h3>

<p>```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;set xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code> android:shareInterpolator="@android:anim/decelerate_interpolator"&gt;
&lt;translate
    android:fromXDelta="0%" android:toXDelta="0%"
    android:fromYDelta="-100%" android:toYDelta="0%"
    android:duration="400" /&gt;
</code></pre>

<p></set></p>

<p>```</p>

<h2>加入动画</h2>

<p>```java
private int mLastPosition = -1;
@Override
public View getView(int position, View convertView, ViewGroup parent) {</p>

<pre><code>View view = super.getView(position, convertView, parent);
int animResId;
if (position &gt; mLastPosition) {
    animResId = R.anim.from_bottom_to_top;
} else {
    animResId = R.anim.from_top_to_bottom;
}

Animation animation = AnimationUtils.loadAnimation(getContext(), animResId);
view.startAnimation(animation);
mLastPosition = position;
return view;
</code></pre>

<p>}
```</p>

<h2>源码</h2>

<p><a href="http://pan.baidu.com/s/1ntmelML" target="_blank">百度云盘</a></p>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00FQEDTA8/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00FQEDTA8&linkCode=as2&tag=droidyue-23">精彩绝伦的Android UI设计</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00FQEDTA8" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B0065DAGZK/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0065DAGZK&linkCode=as2&tag=droidyue-23">精通Android 3</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B0065DAGZK" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你真的懂么:Android中删除Preference]]></title>
    <link href="http://droidyue.com/blog/2014/07/18/remove-a-preference-from-the-screen/"/>
    <updated>2014-07-18T20:50:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/18/remove-a-preference-from-the-screen</id>
    <content type="html"><![CDATA[<p>Android的设置界面实现比较简单,有时甚至只需要使用一个简单的xml文件即可.声明简单,但是如何从PreferenceScreen或者PreferenceCategory中删除一个Preference会简单么.为什么有些人写的就无法删除成功呢?本文将从Android源码实现来分析一下.</p>

<!--more-->


<h2>声明文件</h2>

<p>```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;PreferenceScreen xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>android:key="root"&gt;

&lt;PreferenceCategory 
    android:key="theme" 
    android:title="Theme"
    android:summary="Theme Settings"
    &gt;
    &lt;CheckBoxPreference
        android:key="holo_theme"
        android:title="Holo Theme"
        android:summary="Use Holo Theme"
        /&gt;

&lt;/PreferenceCategory&gt;

&lt;CheckBoxPreference
    android:key="rmcache"
    android:title="Auto Clear Cache"
    android:summary="Enable Auto Clear Cache "
    /&gt;
</code></pre>

<p></PreferenceScreen>
```</p>

<h2>层级关系</h2>

<p><img class="<a" src="href="http://droidyueimg.qiniudn.com/preference_family_tree.png">http://droidyueimg.qiniudn.com/preference_family_tree.png</a>" title="preferece family tree" ></p>

<h2>删除Preference</h2>

<ul>
<li><p>删除key为rmcache的Preference,这个Preference是PreferenceScreen root的子节点.
<code>java
PreferenceScreen screen = getPreferenceScreen();
CheckBoxPreference autoClearCheckboxPref = (CheckBoxPreference) screen.findPreference("rmcache");
screen.removePreference(autoClearCheckboxPref);
</code></p></li>
<li><p>删除key为holo_theme的Preference,其为PreferenceScreen root的孙子节点,非直接关系.
<code>java
PreferenceCategory themePrefCategory = (PreferenceCategory) screen.findPreference("theme");
CheckBoxPreference holoCheckboxPref = (CheckBoxPreference)themePrefCategory.findPreference("holo_theme");
themePrefCategory.removePreference(holoCheckboxPref);
</code></p>

<h2>为什么删除失败</h2>

很多人出现了删除失败的问题,主要原因是使用了非父亲节点来删除,比如这样
<code>java
PreferenceScreen screen = getPreferenceScreen();
CheckBoxPreference holoCheckboxPref = (CheckBoxPreference)screen.findPreference("holo_theme");
screen.removePreference(holoCheckboxPref);
</code>
PreferenceGroup删除实现,其实PreferenceScreen和PreferenceCategory都是PreferenceGroup的子类.
```java
/**

<ul>
<li>Removes a {@link Preference} from this group.</li>
<li></li>
<li>@param preference The preference to remove.</li>
<li>@return Whether the preference was found and removed.
*/
public boolean removePreference(Preference preference) {
 final boolean returnValue = removePreferenceInt(preference);
 notifyHierarchyChanged();
 return returnValue;
}</li>
</ul>


<p>private boolean removePreferenceInt(Preference preference) {
    synchronized(this) {
        preference.onPrepareForRemoval();
        return mPreferenceList.remove(preference);
    }
}
```
而mPreferenceList中存放的都是当前PreferenceGroup的直接子Preference.</p></li>
</ul>


<h2>findPreference实现</h2>

<p>findPreference查找不仅仅限于直接子Preference,会遍历其所有的子Preference.</p>

<p>所以代码中同样有root PreferenceGroup和直接父PreferenceGroup引用时,通常后者效率会高.
```java</p>

<pre><code>/**
 * Finds a {@link Preference} based on its key. If two {@link Preference}
 * share the same key (not recommended), the first to appear will be
 * returned (to retrieve the other preference with the same key, call this
 * method on the first preference). If this preference has the key, it will
 * not be returned.
 * &lt;p&gt;
 * This will recursively search for the preference into children that are
 * also {@link PreferenceGroup PreferenceGroups}.
 * 
 * @param key The key of the preference to retrieve.
 * @return The {@link Preference} with the key, or null.
 */
public Preference findPreference(CharSequence key) {
    if (TextUtils.equals(getKey(), key)) {
        return this;
    }
    final int preferenceCount = getPreferenceCount();
    for (int i = 0; i &lt; preferenceCount; i++) {
        final Preference preference = getPreference(i);
        final String curKey = preference.getKey();

        if (curKey != null &amp;&amp; curKey.equals(key)) {
            return preference;
        }

        if (preference instanceof PreferenceGroup) {
            final Preference returnedPreference = ((PreferenceGroup)preference)
                    .findPreference(key);
            if (returnedPreference != null) {
                return returnedPreference;
            }
        }
    }

    return null;
}
</code></pre>

<p>```</p>

<h2>findPreference和removePreference实现比较</h2>

<p>为什么findPreference遍历所有的子节点,而removePreference不会,只会删除直接子Preference</p>

<h3>原因有以下几点:</h3>

<ul>
<li>findPreference支持遍历查找,减少了声明诸多的中间PreferenceGroup代码.而findPreference属于常用接口方法.</li>
<li>removePreference调用较少.</li>
<li>当存在key相同的Preference时,如果removePreference不限定直接子Preference,那么无法准确删除哪一个.</li>
</ul>


<hr />

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00CJ368JS/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00CJ368JS&linkCode=as2&tag=droidyue-23">Android的设计与实现</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00CJ368JS" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B009OLU8EE/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009OLU8EE&linkCode=as2&tag=droidyue-23">Android系统源代码情景分析</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009OLU8EE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
</feed>
