<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: looper | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/looper/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2015-12-27T23:08:42+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Check If A Thread Is Main Thread In Android]]></title>
    <link href="http://droidyue.com/blog/2014/05/21/check-if-a-thread-is-main-thread-in-android/"/>
    <updated>2014-05-21T21:42:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/05/21/check-if-a-thread-is-main-thread-in-android</id>
    <content type="html"><![CDATA[<p>How to check a certain thread is the main one or not in Android? You may say it could be determined by checking the name. Yes, It may resolve the problem. However I think it&rsquo;s not reliable.</p>

<!-- more -->


<p>This is the most reliable workaround.
```java
public static boolean isInMainThread() {</p>

<pre><code>    return Looper.myLooper() == Looper.getMainLooper();
</code></pre>

<p>}
<code>
Actually the above code could already resolve your problem. If you want to know more details, please go on reading this post.  
Now Let's do some tests to check the reliability of this method.
This the method with additional debug log
</code>java
private boolean isInMainThread() {</p>

<pre><code>Looper myLooper = Looper.myLooper();
Looper mainLooper = Looper.getMainLooper();
Log.i(LOGTAG, "isInMainThread myLooper=" + myLooper 
    + ";mainLooper=" + mainLooper);
return myLooper == mainLooper;
</code></pre>

<p>}
<code>
Now we run this test case. Of course we assume that the following code is running in the main thread.
</code>java
Log.i(LOGTAG, &ldquo;testInMainThread inMainThread=&rdquo; + isInMainThread());
<code>
Look at the output log. It works well.
</code>bash
I/TestInMainThread(32028): isInMainThread myLooper=Looper{40d35ef8};mainLooper=Looper{40d35ef8}
I/TestInMainThread(32028): testInMainThread inMainThread=true
<code>
Now we are going to check the method running in a non-main thread without a message loop.
</code>java
new Thread() {</p>

<pre><code>@Override
public void run() {
    Log.i(LOGTAG, "testIn NOT in MainThread isMainThread="
        + isInMainThread());
    super.run();
}
</code></pre>

<p>}.start();
<code>
As we can see from the below output. the main looper has been assigned. However the looper associated with the current thread is Null. That's because `Threads by default do not have a message loop associated with them. Of course, the method works`.
</code>bash
I/TestInMainThread(32028): isInMainThread myLooper=null;mainLooper=Looper{40d35ef8}
I/TestInMainThread(32028): testIn NOT in MainThread isMainThread=false
<code>
Then, Now we create a thread with a message loop. And let's have a check. According to Android Developer Docs, This is a typical example of the implementation of a Looper thread, using the separation of prepare() and loop() to create an initial Handler to communicate with the Looper.
</code>java
new Thread() {</p>

<pre><code>private Handler mHandler;
@Override
public void run() {
    Looper.prepare();
    mHandler = new Handler() {
        public void handleMessage(Message msg) {
            // process incoming messages here
        }
    };
    Log.i(LOGTAG, "testInNonMainLooperThread isMainThread=" 
        + isInMainThread());
    Looper.loop();
}
</code></pre>

<p>}.start();
<code>
Now both the looper bound to the current thread and the main looper has been assigned. However the are different. That's right; and the method still works.
</code>bash
I/TestInMainThread(32028): isInMainThread myLooper=Looper{40d72c58};mainLooper=Looper{40d35ef8}
I/TestInMainThread(32028): testInNonMainLooperThread isMainThread=false
<code>
But why? And what 's inside?
Let's see the code what's is inside the  Looper.class.
</code>java</p>

<pre><code>// sThreadLocal.get() will return null unless you've called prepare().
static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();
private static Looper sMainLooper;  // guarded by Looper.class

/**
 * Initialize the current thread as a looper, marking it as an
 * application's main looper. The main looper for your application
 * is created by the Android environment, so you should never need
 * to call this function yourself.  See also: {@link #prepare()}
 */
public static void prepareMainLooper() {
    prepare(false);
    synchronized (Looper.class) {
        if (sMainLooper != null) {
            throw new IllegalStateException("The main Looper has already been prepared.");
        }
        sMainLooper = myLooper();
    }
}

private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException("Only one Looper may be created per thread");
    }
    sThreadLocal.set(new Looper(quitAllowed));
}

/**
 * Return the Looper object associated with the current thread.  
 * Returns null if the calling thread is not associated with a Looper.
 */
public static Looper myLooper() {
    return sThreadLocal.get();
}

 /** Returns the application's main looper, which lives in the main thread of the application.
 */
public static Looper getMainLooper() {
    synchronized (Looper.class) {
        return sMainLooper;
    }
}
</code></pre>

<p>```
For the main thread, the prepareMainLooper method will be called by the Android Environment not by developers. In this way, the looper associated with the main thread is created and passed the reference to the sMainLooper; thus this could guarantee the two looper equals, actually the are the same one.</p>

<p>For non-main thread without a message loop, the looper bound to the current thread is null, because you never call the prepare by yourself. Of course the two looper are different.</p>

<p>For non-main thread with a message loop, Before calling the Lopper.prepare method, the main looper is already assigned. And by calling this method, a looper bound to the current thread is created. And Of course, it is not the main looper.</p>

<p>The above code makes sense.</p>

<p>References:</p>

<ul>
<li> <a href="http://developer.android.com/reference/android/os/Looper.html">http://developer.android.com/reference/android/os/Looper.html</a></li>
<li> <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.4.2_r1/android/os/Looper.java/">http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.4.2_r1/android/os/Looper.java/</a></li>
</ul>


<h3>Others</h3>

<ul>
<li><a href="http://www.amazon.com/gp/product/1783286873/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1783286873&linkCode=as2&tag=droidyueblog-20&linkId=GA4SWV3DJHSTDG7A">Asynchronous Android</a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=droidyueblog-20&l=as2&o=1&a=1783286873" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
</feed>
