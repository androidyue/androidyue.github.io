<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2016-01-13T22:11:56+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[修复Android中Navigation Bar遮挡PopupWindow的问题]]></title>
    <link href="http://droidyue.com/blog/2016/01/10/android-navigation-bar-popupwindow-issue/"/>
    <updated>2016-01-10T14:41:00+08:00</updated>
    <id>http://droidyue.com/blog/2016/01/10/android-navigation-bar-popupwindow-issue</id>
    <content type="html"><![CDATA[<p>最近遇到了一个问题，关于Navigation Bar遮挡PopupWindow的问题，问题不难，粗略做一点总结。</p>

<!--more-->


<h2>现象描述</h2>

<ul>
<li>问题应该出现在5.0 Lollipop版本及以上</li>
<li>遮挡的现象如下图,Navigation Bar位于了PopupWindow的上层，明显是一种问题。</li>
</ul>


<p><img src="http://7jpolu.com1.z0.glb.clouddn.com/navigation_issue.png" alt="Android Navigation Bar Issue" /></p>

<h2>我的实现代码</h2>

<p>```java
private void showPopupWindow() {</p>

<pre><code>if (mPopupWindow == null) {
    View contentView = LayoutInflater.from(this).inflate(R.layout.popup_window_content, null);
    mPopupWindow = new PopupWindow(contentView, LinearLayout.LayoutParams.MATCH_PARENT,500, true);
    mPopupWindow.setBackgroundDrawable(new BitmapDrawable());
}
mPopupWindow.showAtLocation(findViewById(R.id.contentContainer), Gravity.BOTTOM, 0,0);
</code></pre>

<p>}
```
<strong>其实和具体的实现代码没有关系</strong>，重点是修改主题style。</p>

<h2>修改style</h2>

<p>修改v21/styles.xml(如没有，可以创建),将<code>android:windowDrawsSystemBarBackgrounds</code>修改为<code>false</code>。</p>

<p>```xml</p>



<p>```</p>

<h2>修改好的效果</h2>

<p><img src="http://7jpolu.com1.z0.glb.clouddn.com/navigation_bar_good.png" alt="Good PopupWindow" /></p>

<h2>demo源码</h2>

<p><a href="https://github.com/androidyue/Navigation-Bar-Issue-Demo">Navigation Bar Issue Demo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Android中工作者线程的思考]]></title>
    <link href="http://droidyue.com/blog/2015/12/20/worker-thread-in-android/"/>
    <updated>2015-12-20T10:47:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/12/20/worker-thread-in-android</id>
    <content type="html"><![CDATA[<h2>版权说明</h2>

<p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/android-worker-thread">http://www.infoq.com/cn/articles/android-worker-thread</a> 如需转载，请与 InfoQ 中文站联系。</p>

<h2>摘要</h2>

<p>在Android开发过程中，我们经常使用工作者线程，如AsyncTask和线程池。然而我们经常使用的这些工作者线程存在哪些不易察觉的问题呢，关于工作者线程有哪些优化呢，文本将逐一介绍并回答这些问题。</p>

<p>本文系2015 北京 GDG Devfest分享内容文章。</p>

<p>在Android中，我们或多或少使用了工作者线程，比如Thread，AsyncTask，HandlerThread，甚至是自己创建的线程池，使用工作者线程我们可以将耗时的操作从主线程中移走。然而在Android系统中为什么存在工作者线程呢，常用的工作者线程有哪些不易察觉的问题呢，关于工作者线程有哪些优化的方面呢，本文将一一解答这些问题。</p>

<!--more-->


<h2>工作者线程的存在原因</h2>

<ul>
<li>因为Android的UI单线程模型，所有的UI相关的操作都需要在主线程(UI线程)执行</li>
<li>Android中各大组件的生命周期回调都是位于主线程中，使得主线程的职责更重</li>
<li>如果不使用工作者线程为主线程分担耗时的任务，会造成应用卡顿，严重时可能出现ANR(Application Not Responding),即程序未响应。</li>
</ul>


<p>因而，在Android中使用工作者线程显得势在必行，如一开始提到那样，在Android中工作者线程有很多，接下来我们将围绕AsyncTask，HandlerThread等深入研究。</p>

<h2>AsyncTask</h2>

<p>AsyncTask是Android框架提供给开发者的一个辅助类，使用该类我们可以轻松的处理异步线程与主线程的交互，由于其便捷性，在Android工程中，AsyncTask被广泛使用。然而AsyncTask并非一个完美的方案，使用它往往会存在一些问题。接下来将逐一列举AsyncTask不容易被开发者察觉的问题。</p>

<h3>AsyncTask与内存泄露</h3>

<p>内存泄露是Android开发中常见的问题，只要开发者稍有不慎就有可能导致程序产生内存泄露，严重时甚至可能导致OOM(OutOfMemory，即内存溢出错误)。AsyncTask也不例外，也有可能造成内存泄露。</p>

<p>以一个简单的场景为例：
在Activity中，通常我们这样使用AsyncTask
```java
//In Activity
new AsyncTask&lt;String, Void, Void>() {</p>

<pre><code>@Override
protected Void doInBackground(String... params) {
    //some code
    return null;
}
</code></pre>

<p>}.execute(&ldquo;hello world&rdquo;);
<code>``
上述代码使用的匿名内存类创建AsyncTask实例，然而在Java中，</code>非静态内存类会隐式持有外部类的实例引用`，上面例子AsyncTask创建于Activity中，因而会隐式持有Activity的实例引用。</p>

<p>而在AsyncTask内部实现中,mFuture同样使用匿名内部类创建对象，而mFuture会作为执行任务加入到任务执行器中。
```
private final WorkerRunnable&lt;Params, Result> mWorker;
public AsyncTask() {</p>

<pre><code>mFuture = new FutureTask&lt;Result&gt;(mWorker) {
    @Override
    protected void done() {
        //some code
    }
};
</code></pre>

<p>}
<code>
而mFuture加入任务执行器，实际上是放入了一个静态成员变量SERIAL_EXECUTOR指向的对象SerialExecutor的一个ArrayDeque类型的集合中。
</code>java
public static final Executor SERIAL_EXECUTOR = new SerialExecutor();
private static class SerialExecutor implements Executor {</p>

<pre><code>    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();

public synchronized void execute(final Runnable r) {
    mTasks.offer(new Runnable() {
        public void run() {
            //fake code
            r.run();
        }
    });
}
</code></pre>

<p>}
```</p>

<p>当任务处于排队状态，则Activity实例引用被静态常量SERIAL_EXECUTOR 间接持有。</p>

<p>在通常情况下，当设备发生屏幕旋转事件，当前的Activity被销毁，新的Activity被创建，以此完成对布局的重新加载。</p>

<p>而本例中，当屏幕旋转时，处于排队的AsyncTask由于其对Activity实例的引用关系，导致这个Activity不能被销毁，其对应的内存不能被GC回收，因而就出现了内存泄露问题。</p>

<p>关于如何避免内存泄露，我们可以使用静态内部类 + 弱引用的形式解决。</p>

<h3>cancel的问题</h3>

<p>AsyncTask作为任务，是支持调用者取消任务的，即允许我们使用AsyncTask.canncel()方法取消提交的任务。然而其实cancel并非真正的起作用。</p>

<p>首先，我们看一下cancel方法：
```java
public final boolean cancel(boolean mayInterruptIfRunning) {</p>

<pre><code>mCancelled.set(true);
return mFuture.cancel(mayInterruptIfRunning);
</code></pre>

<p>}
<code>``
cancel方法接受一个boolean类型的参数，名称为</code>mayInterruptIfRunning`，意思是是否可以打断正在执行的任务。</p>

<p>当我们调用cancel(false)，不打断正在执行的任务，对应的结果是</p>

<ul>
<li>处于doInBackground中的任务不受影响，继续执行</li>
<li>任务结束时不会去调用<code>onPostExecute</code>方法，而是执行<code>onCancelled</code>方法</li>
</ul>


<p>当我们调用cancel(true)，表示打断正在执行的任务，会出现如下情况：</p>

<ul>
<li>如果doInBackground方法处于阻塞状态，如调用Thread.sleep,wait等方法，则会抛出InterruptedException。</li>
<li>对于某些情况下，有可能无法打断正在执行的任务</li>
</ul>


<p>如下，就是一个cancel方法无法打断正在执行的任务的例子
```
AsyncTask&lt;String,Void,Void> task = new AsyncTask&lt;String, Void, Void>() {</p>

<pre><code>@Override
protected Void doInBackground(String... params) {
    boolean loop = true;
    while(loop) {
        Log.i(LOGTAG, "doInBackground after interrupting the loop");
    }
    return null;
}
</code></pre>

<p>}</p>

<p>task.execute(&ldquo;hello world&rdquo;);
try {</p>

<pre><code>Thread.sleep(2000);//确保AsyncTask任务执行
task.cancel(true);
</code></pre>

<p>} catch (InterruptedException e) {</p>

<pre><code>e.printStackTrace();
</code></pre>

<p>}
<code>``
上面的例子，如果想要使cancel正常工作需要在循环中，需要在循环条件里面同时检测</code>isCancelled()`才可以。</p>

<h3>串行带来的问题</h3>

<p>Android团队关于AsyncTask执行策略进行了多次修改，修改大致如下：
  * 自最初引入到Donut(1.6)之前，任务串行执行
  * 从Donut到GINGERBREAD_MR1(2.3.4),任务被修改成了并行执行
  * 从HONEYCOMB（3.0）至今，任务恢复至串行，但可以设置<code>executeOnExecutor()</code>实现并行执行。</p>

<p>然而AsyncTask的串行实际执行起来是这样的逻辑</p>

<ul>
<li>由串行执行器控制任务的初始分发</li>
<li>并行执行器一次执行单个任务，并启动下一个</li>
</ul>


<p>在AsyncTask中，并发执行器实际为ThreadPoolExecutor的实例，其CORE_POOL_SIZE为当前设备CPU数量+1，MAXIMUM_POOL_SIZE值为CPU数量的2倍 + 1。</p>

<p>以一个四核手机为例，当我们持续调用AsyncTask任务过程中</p>

<ul>
<li>在AsyncTask线程数量小于CORE_POOL_SIZE(5个)时，会启动新的线程处理任务，不重用之前空闲的线程</li>
<li>当数量超过CORE_POOL_SIZE(5个)，才开始重用之前的线程处理任务</li>
</ul>


<p>但是由于AsyncTask属于默认线性执行任务，导致并发执行器总是处于某一个线程工作的状态，因而造成了ThreadPool中其他线程的浪费。同时由于AsyncTask中并不存在allowCoreThreadTimeOut(boolean)的调用，所以ThreadPool中的核心线程即使处于空闲状态也不会销毁掉。</p>

<h2>Executors</h2>

<p>Executors是Java API中一个快速创建线程池的工具类，然而在它里面也是存在问题的。</p>

<p>以Executors中获取一个固定大小的线程池方法为例
```java
public static ExecutorService newFixedThreadPool(int nThreads) {</p>

<pre><code>return new ThreadPoolExecutor(nThreads, nThreads,0L, 
    TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());
</code></pre>

<p>}
```
在上面代码实现中，CORE_POOL_SIZE和MAXIMUM_POOL_SIZE都是同样的值，如果把nThreads当成核心线程数，则无法保证最大并发，而如果当做最大并发线程数，则会造成线程的浪费。因而Executors这样的API导致了我们无法在最大并发数和线程节省上做到平衡。</p>

<p>为了达到最大并发数和线程节省的平衡，建议自行创建ThreadPoolExecutor，根据业务和设备信息确定CORE_POOL_SIZE和MAXIMUM_POOL_SIZE的合理值。</p>

<h2>HandlerThread</h2>

<p>HandlerThread是Android中提供特殊的线程类，使用这个类我们可以轻松创建一个带有Looper的线程，同时利用Looper我们可以结合Handler实现任务的控制与调度。以Handler的post方法为例，我们可以封装一个轻量级的任务处理器
```java
private Handler mHandler;
private LightTaskManager() {</p>

<pre><code>HandlerThread workerThread = new HandlerThread("LightTaskThread");
workerThread.start();
mHandler = new Handler(workerThread.getLooper());
</code></pre>

<p>}</p>

<p>public void post(Runnable run) {</p>

<pre><code>mHandler.post(run);
</code></pre>

<p>}</p>

<p>public void postAtFrontOfQueue(Runnable runnable) {</p>

<pre><code>mHandler.postAtFrontOfQueue(runnable);
</code></pre>

<p>}</p>

<p>public void postDelayed(Runnable runnable, long delay) {</p>

<pre><code>mHandler.postDelayed(runnable, delay);
</code></pre>

<p>}</p>

<p>public void postAtTime(Runnable runnable, long time) {</p>

<pre><code>mHandler.postAtTime(runnable, time);
</code></pre>

<p>}
```
在本例中，我们可以按照如下规则提交任务</p>

<ul>
<li>post 提交优先级一般的任务</li>
<li>postAtFrontOfQueue 将优先级较高的任务加入到队列前端</li>
<li>postAtTime 指定时间提交任务</li>
<li>postDelayed 延后提交优先级较低的任务</li>
</ul>


<p>上面的轻量级任务处理器利用HandlerThread的单一线程 + 任务队列的形式，可以处理类似本地IO（文件或数据库读取）的轻量级任务。在具体的处理场景下，可以参考如下做法：</p>

<ul>
<li>对于本地IO读取，并显示到界面，建议使用postAtFrontOfQueue</li>
<li>对于本地IO写入，不需要通知界面，建议使用postDelayed</li>
<li>一般操作，可以使用post</li>
</ul>


<h2>线程优先级调整</h2>

<p>在Android应用中，将耗时任务放入异步线程是一个不错的选择，那么为异步线程调整应有的优先级则是一件锦上添花的事情。众所周知，线程的并行通过CPU的时间片切换实现，对线程优先级调整，最主要的策略就是降低异步线程的优先级，从而使得主线程获得更多的CPU资源。</p>

<p>Android中的线程优先级和Linux系统进程优先级有些类似，其值都是从-20至19。其中Android中，开发者可以控制的优先级有：</p>

<ul>
<li><code>THREAD_PRIORITY_DEFAULT</code>，默认的线程优先级，值为0</li>
<li><code>THREAD_PRIORITY_LOWEST</code>，最低的线程级别，值为19</li>
<li><code>THREAD_PRIORITY_BACKGROUND</code> 后台线程建议设置这个优先级，值为10</li>
<li><code>THREAD_PRIORITY_MORE_FAVORABLE</code> 相对<code>THREAD_PRIORITY_DEFAULT</code>稍微优先，值为-1</li>
<li><code>THREAD_PRIORITY_LESS_FAVORABLE</code> 相对<code>THREAD_PRIORITY_DEFAULT</code>稍微落后一些，值为1</li>
</ul>


<p>为线程设置优先级也比较简单，通用的做法是在run方法体的开始部分加入下列代码
<code>java
android.os.Process.setThreadPriority(priority);
</code></p>

<p>通常设置优先级的规则如下：</p>

<ul>
<li>一般的工作者线程，设置成<code>THREAD_PRIORITY_BACKGROUND</code></li>
<li>对于优先级很低的线程，可以设置<code>THREAD_PRIORITY_LOWEST</code></li>
<li>其他特殊需求，视业务应用具体的优先级</li>
</ul>


<h2>总结</h2>

<p>在Android中工作者线程如此普遍，然而潜在的问题也不可避免，建议在开发者使用工作者线程时，从工作者线程的数量和优先级等方面进行审视，做到较为合理的使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 中 SQLite 性能优化]]></title>
    <link href="http://droidyue.com/blog/2015/12/13/android-sqlite-tuning/"/>
    <updated>2015-12-13T17:38:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/12/13/android-sqlite-tuning</id>
    <content type="html"><![CDATA[<p>数据库是应用开发中常用的技术，在Android应用中也不例外。Android默认使用了SQLite数据库，在应用程序开发中，我们使用最多的无外乎增删改查。纵使操作简单，也有可能出现查找数据缓慢，插入数据耗时等情况，如果出现了这种问题，我们就需要考虑对数据库操作进行优化了。本文将介绍一些实用的数据库优化操作，希望可以帮助大家更好地在开发过程中使用数据库。</p>

<!--more-->


<h2>建立索引</h2>

<p>很多时候，我们都听说，想要查找快速就建立索引。这句话没错，数据表的索引类似于字典中的拼音索引或者部首索引。</p>

<h3>索引的解释</h3>

<p>重温一下我们小时候查字典的过程：</p>

<ul>
<li>对于已经知道拼音的字，比如<code>中</code>这个字，我们只需要在拼音索引里面找到<code>zhong</code>，就可以确定这个字在词典中的页码。</li>
<li>对于不知道拼音的字，比如<code>欗</code>这个字，我们只需要在部首索引里面查找这个字，就能找到确定这个字在词典中的页码。</li>
</ul>


<p>没错，索引做的事情就是这么简单，使得我们不需要查找整个数据表就可以实现快速访问。</p>

<h3>建立索引</h3>

<p>创建索引的基本语法如下
<code>
CREATE INDEX index_name ON table_name;
</code></p>

<p>创建单列索引
<code>
CREATE INDEX index_name ON table_name (column_name);
</code></p>

<h3>索引真的好么</h3>

<p>毋庸置疑，索引加速了我们检索数据表的速度。然而正如西方谚语 &ldquo;There are two sides of a coin"，索引亦有缺点：</p>

<ul>
<li>对于增加，更新和删除来说，使用了索引会变慢，比如你想要删除字典中的一个字，那么你同时也需要删除这个字在拼音索引和部首索引中的信息。</li>
<li>建立索引会增加数据库的大小，比如字典中的拼音索引和部首索引实际上是会增加字典的页数，让字典变厚的。</li>
<li>为数据量比较小的表建立索引，往往会事倍功半。</li>
</ul>


<p>所以使用索引需要考虑实际情况进行利弊权衡，对于查询操作量级较大，业务对要求查询要求较高的，还是推荐使用索引的。</p>

<h2>编译SQL语句</h2>

<p>SQLite想要执行操作，需要将程序中的sql语句编译成对应的SQLiteStatement，比如<code>select * from record</code>这一句，被执行100次就需要编译100次。对于批量处理插入或者更新的操作，我们可以使用显式编译来做到重用SQLiteStatement。</p>

<p>想要做到重用SQLiteStatement也比较简单，基本如下：</p>

<ul>
<li>编译sql语句获得SQLiteStatement对象，参数使用<code>?</code>代替</li>
<li>在循环中对SQLiteStatement对象进行具体数据绑定，bind方法中的index从1开始，不是0</li>
</ul>


<p>请参考如下简单的使用代码
```java
private void insertWithPreCompiledStatement(SQLiteDatabase db) {</p>

<pre><code>String sql = "INSERT INTO " + TableDefine.TABLE_RECORD + "( " + TableDefine.COLUMN_INSERT_TIME + ") VALUES(?)";
SQLiteStatement  statement = db.compileStatement(sql);
int count = 0;
while (count &lt; 100) {
    count++;
    statement.clearBindings();
    statement.bindLong(1, System.currentTimeMillis());
    statement.executeInsert();
}
</code></pre>

<p>}
```</p>

<h2>显式使用事务</h2>

<p>在Android中，无论是使用SQLiteDatabase的insert,delete等方法还是execSQL都开启了事务，来确保每一次操作都具有原子性，使得结果要么是操作之后的正确结果，要么是操作之前的结果。</p>

<p>然而事务的实现是依赖于名为rollback journal文件，借助这个临时文件来完成原子操作和回滚功能。既然属于文件，就符合Unix的文件范型(Open-Read/Write-Close)，因而对于批量的修改操作会出现反复打开文件读写再关闭的操作。然而好在，我们可以显式使用事务，将批量的数据库更新带来的journal文件打开关闭降低到1次。</p>

<p>具体的实现代码如下：</p>

<p>```java
private void insertWithTransaction(SQLiteDatabase db) {</p>

<pre><code>int count = 0;
ContentValues values = new ContentValues();
try {
    db.beginTransaction();
    while (count++ &lt; 100) {
        values.put(TableDefine.COLUMN_INSERT_TIME, System.currentTimeMillis());
        db.insert(TableDefine.TABLE_RECORD, null, values);
    }
    db.setTransactionSuccessful();
} catch (Exception e) {
    e.printStackTrace();
} finally {
    db.endTransaction();
}
</code></pre>

<p>}
```</p>

<p>上面的代码中，如果没有异常抛出，我们则认为事务成功，调用<code>db.setTransactionSuccessful();</code>确保操作真实生效。如果在此过程中出现异常，则批量数据一条也不会插入现有的表中。</p>

<h2>查询数据优化</h2>

<p>对于查询的优化，除了建立索引以外，有以下几点微优化的建议</p>

<h3>按需获取数据列信息</h3>

<p>通常情况下，我们处于自己省时省力的目的，对于查找使用类似这样的代码
```java
private void badQuery(SQLiteDatabase db) {</p>

<pre><code>db.query(TableDefine.TABLE_RECORD, null, null, null, null, null, null) ;
</code></pre>

<p>}
```
其中上面方法的第二个参数类型为String[]，意思是返回结果参考的colum信息，传递null表明需要获取全部的column数据。这里建议大家传递真实需要的字符串数据对象表明需要的列信息，这样做效率会有所提升。</p>

<h3>提前获取列索引</h3>

<p>当我们需要遍历cursor时，我们通常的做法是这样
```java
private void badQueryWithLoop(SQLiteDatabase db) {</p>

<pre><code>Cursor cursor = db.query(TableDefine.TABLE_RECORD, new String[]{TableDefine.COLUMN_INSERT_TIME}, null, null, null, null, null) ;
while (cursor.moveToNext()) {
    long insertTime = cursor.getLong(cursor.getColumnIndex(TableDefine.COLUMN_INSERT_TIME));
}
</code></pre>

<p>}
<code>
但是如果我们将获取ColumnIndex的操作提到循环之外，效果会更好一些，修改后的代码如下：
</code>java
private void goodQueryWithLoop(SQLiteDatabase db) {</p>

<pre><code>Cursor cursor = db.query(TableDefine.TABLE_RECORD, new String[]{TableDefine.COLUMN_INSERT_TIME}, null, null, null, null, null) ;
int insertTimeColumnIndex = cursor.getColumnIndex(TableDefine.COLUMN_INSERT_TIME);
while (cursor.moveToNext()) {
    long insertTime = cursor.getLong(insertTimeColumnIndex);
}
cursor.close();
</code></pre>

<p>}
```</p>

<h2>ContentValues的容量调整</h2>

<p>SQLiteDatabase提供了方便的ContentValues简化了我们处理列名与值的映射，ContentValues内部采用了HashMap来存储Key-Value数据，ContentValues的初始容量是8，如果当添加的数据超过8之前，则会进行双倍扩容操作，因此建议对ContentValues填入的内容进行估量，设置合理的初始化容量，减少不必要的内部扩容操作。</p>

<h2>及时关闭Cursor</h2>

<p>使用数据库，比较常见的就是忘记关闭Cursor。关于如何发现未关闭的Cursor，我们可以使用StrictMode，详细请戳这里<a href="http://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode/">Android性能调优利器StrictMode</a></p>

<h2>耗时异步化</h2>

<p>数据库的操作，属于本地IO，通常比较耗时，如果处理不好，很容易导致<a href="http://droidyue.com/blog/2015/07/18/anr-in-android/">ANR</a>,因此建议将这些耗时操作放入异步线程中处理，这里推荐一个单线程 + 任务队列形式处理的<a href="http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/">HandlerThread</a>实现异步化。</p>

<h2>源码下载</h2>

<p>示例源码，存放在Github，地址为<a href="https://github.com/androidyue/AndroidSQLiteTuningDemo">AndroidSQLiteTuningDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android处理崩溃的一些实践]]></title>
    <link href="http://droidyue.com/blog/2015/12/06/practise-about-crash-in-android/"/>
    <updated>2015-12-06T22:47:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/12/06/practise-about-crash-in-android</id>
    <content type="html"><![CDATA[<p>对于任何程序来说，崩溃都是一件很难避免的事情，当然Android程序也不例外。在Android程序中，引起崩溃的多属于运行时异常或者错误，对于这些异常我们很难做到类似Checked Exception那样显式捕获，因而最终导致了程序崩溃。本文讲介绍一些如何处理崩溃的实践，比如收集崩溃的stacktrace，甚至如何避免出现程序已停止的对话框。</p>

<!--more-->


<h2>如何收集崩溃信息</h2>

<p>收集崩溃信息，可以更好的修复问题，增强程序的稳定性。Android中的崩溃收集沿用了Java的收集机制，实现起来比较简单。</p>

<h3>1.实现UncaughtExceptionHandler</h3>

<p>我们需要实现UncaughtExceptionHandler接口中的<code>uncaughtException</code>方法。该方法体中最常见的操作就是读取崩溃的stacktrace信息，然后上报到服务器数据便于开发者分析。实现代码如下：
```java
public class SimpleUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {</p>

<pre><code>private static final String LOGTAG = "SimpleUncaughtExceptionHandler";

@Override
public void uncaughtException(Thread thread, Throwable ex) {
    //读取stacktrace信息
    final Writer result = new StringWriter();
    final PrintWriter printWriter = new PrintWriter(result);
    ex.printStackTrace(printWriter);
    String errorReport = result.toString();
    Log.i(LOGTAG, "uncaughtException errorReport=" + errorReport);
}
</code></pre>

<p>}
```
除此之外，还建议携带以下信息发送到服务器，帮助更快定位和重现问题。</p>

<ul>
<li>设备唯一ID（基于IMEI或者Android ID等），方便根据用户提供的id，查找崩溃的stacktrace</li>
<li>设备语言与区域 方便重现</li>
<li>应用的版本号</li>
<li>设备的系统版本</li>
<li>设备类型，如平板，手机，TV等</li>
<li>崩溃发生的时间等</li>
</ul>


<h3>注册默认的异常处理</h3>

<p>注册默认的异常处理就是最后的一步，很简单，通常建议放在Application的onCreate方法中进行。
```java
public class DroidApplication extends Application {</p>

<pre><code>private static final String LOGTAG = "DroidApplication";

@Override
public void onCreate() {
    super.onCreate();
    Log.i(LOGTAG, "onCreate");
    Thread.setDefaultUncaughtExceptionHandler(new SimpleUncaughtExceptionHandler());
}
</code></pre>

<p>}
```</p>

<h3>验证</h3>

<p>当我们刻意触发一个NullPointerException时，过滤日志<code>adb logcat | grep SimpleUncaughtExceptionHandler</code>类似如下信息，则说明成功了。
<code>java
I/SimpleUncaughtExceptionHandler(22469): uncaughtException errorReport=java.lang.NullPointerException
I/SimpleUncaughtExceptionHandler(22469):  at com.droidyue.avoidforceclosedemo.MainActivity.causeNPE(MainActivity.java:22)
I/SimpleUncaughtExceptionHandler(22469):  at com.droidyue.avoidforceclosedemo.MainActivity.onClick(MainActivity.java:29)
I/SimpleUncaughtExceptionHandler(22469):  at android.view.View.performClick(View.java:4470)
I/SimpleUncaughtExceptionHandler(22469):  at android.view.View$PerformClick.run(View.java:18593)
I/SimpleUncaughtExceptionHandler(22469):  at android.os.Handler.handleCallback(Handler.java:733)
I/SimpleUncaughtExceptionHandler(22469):  at android.os.Handler.dispatchMessage(Handler.java:95)
I/SimpleUncaughtExceptionHandler(22469):  at android.os.Looper.loop(Looper.java:157)
I/SimpleUncaughtExceptionHandler(22469):  at android.app.ActivityThread.main(ActivityThread.java:5867)
I/SimpleUncaughtExceptionHandler(22469):  at java.lang.reflect.Method.invokeNative(Native Method)
I/SimpleUncaughtExceptionHandler(22469):  at java.lang.reflect.Method.invoke(Method.java:515)
I/SimpleUncaughtExceptionHandler(22469):  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:858)
I/SimpleUncaughtExceptionHandler(22469):  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:674)
I/SimpleUncaughtExceptionHandler(22469):  at dalvik.system.NativeStart.main(Native Method)
</code></p>

<h2>不出现应用崩溃对话框</h2>

<p>在Android崩溃的时候，我们都会看到类似这样的对话框</p>

<p><img src="http://7jpolu.com1.z0.glb.clouddn.com/app_crash.png" alt="app crash" /></p>

<p>然而，实际上有些情况下是不需要展示这个对话框的，一个常用的例子，我的程序中一个不太重要的推送服务采用了单独的进程，当这个进程崩溃时，实际上是可以允许不让用户感知的。</p>

<p>如果我们采取主进程仍弹出对话框，其他进程不弹出的策略，那么我们的问题，可以总结成如下三个</p>

<ul>
<li>如何判断进程为主进程还是其他进程，或者某个进程</li>
<li>如何在某些进程不弹出应用崩溃对话框</li>
<li>如何在主进程弹出崩溃对话框</li>
</ul>


<p>既然问题来了，我们就开动挖掘机深挖吧。</p>

<h3>进程判定</h3>

<p>进行进程判定也比较容易，首先我们需要获得进程名
```java
public static String getProcessName(Context appContext) {</p>

<pre><code>String currentProcessName = "";
int pid = android.os.Process.myPid();
ActivityManager manager = (ActivityManager) appContext.getSystemService(Context.ACTIVITY_SERVICE);
for (ActivityManager.RunningAppProcessInfo processInfo : manager.getRunningAppProcesses()) {
    if (processInfo.pid == pid) {
        currentProcessName = processInfo.processName;
        break;
    }
}
return currentProcessName;
</code></pre>

<p>}
<code>
判断主进程，则对比进程名是否和包名相同即可
</code>java
mAppContext.getPackageName().equals(processName)
<code>
判断为某个进程，在mainifest这样这样声明
</code>java
<service android:name=".DroidService" android:process=":service"></service>
<code>
其对应的完整进程名为`com.droidyue.avoidforceclosedemo:service`，我们判断可以使用如下代码
</code>java
&ldquo;com.droidyue.avoidforceclosedemo:service&rdquo;.equals(processName);
```</p>

<h3>不弹框的处理</h3>

<p>不弹框的需要做的就是不调用Android默认的异常处理，当异常出现时，收集完信息，执行进程kill即可。
<code>java
android.os.Process.killProcess(android.os.Process.myPid());
</code></p>

<h3>主进程保持弹窗的处理</h3>

<p>想要保持弹窗也比较容易，就是调用Android默认的异常处理。</p>

<p>首先需要获得Android默认的异常处理，在设置自定的异常处理之前，将Android默认处理保存起来。如下是在自定义异常处理的构造方法中获取Android默认处理
```java
public DroidUncaughtExceptionHandler(Context context) {</p>

<pre><code>mAppContext = context.getApplicationContext();
mDefaultExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
</code></pre>

<p>}
<code>
然后在异常处理方法uncaughtException中调用如下方法
</code>java
mDefaultExceptionHandler.uncaughtException(thread, ex);
```</p>

<p>注意，如果你的应用崩溃后，不调用Android默认的异常处理，也不进行杀死进程，则进程处于不可交互，即UI点击无响应状态。</p>

<h2>源码</h2>

<p>本示例源码，存放在Github，地址为<a href="https://github.com/androidyue/AvoidForceCloseDemo">AvoidForceCloseDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[详解 Android 中的 HandlerThread]]></title>
    <link href="http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/"/>
    <updated>2015-11-08T22:50:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread</id>
    <content type="html"><![CDATA[<p>HandlerThread是Android API提供的一个便捷的类，使用它我们可以快速的创建一个带有Looper的线程，有了Looper这个线程，我们又可以生成Handler，那么HandlerThread是什么，可以做什么呢，有哪些奇技淫巧可以被我们利用呢？</p>

<!--more-->


<h2>实现原理</h2>

<p>在介绍原理之前，我们先使用普通的Thread来创建一个Handler，创建的过程大致如下：
```java
Handler mHandler;
private void createManualThreadWithHandler() {</p>

<pre><code>new Thread() {
    @Override
    public void run() {
        super.run();
        Looper.prepare();
        mHandler = new Handler(Looper.myLooper());
        Looper.loop();
    }
}.start();
</code></pre>

<p>}
```
实现很简单，在目标线程内如下配置</p>

<ul>
<li>调用Looper.prepare 创建与当前线程绑定的Looper实例</li>
<li>使用上面创建的Looper生成Handler实例</li>
<li>调用Looper.loop()实现消息循环</li>
</ul>


<p>明白上面的实现步骤，HandlerThread的实现也就简单了，其实现为：
```java
@Override
public void run() {</p>

<pre><code>mTid = Process.myTid();
Looper.prepare();
synchronized (this) {
    mLooper = Looper.myLooper();
    notifyAll();
}
Process.setThreadPriority(mPriority);
onLooperPrepared();
Looper.loop();
mTid = -1;
</code></pre>

<p>}
```
确实很简单，无需赘述。</p>

<h2>Handler原理</h2>

<p>要理解Handler的原理，理解如下几个概念即可茅塞顿开。</p>

<ul>
<li>Message 意为消息，发送到Handler进行处理的对象，携带描述信息和任意数据。</li>
<li>MessageQueue 意为消息队列，Message的集合。</li>
<li>Looper 有着一个很难听的中文名字，消息泵，用来从MessageQueue中抽取Message，发送给Handler进行处理。</li>
<li>Handler 处理Looper抽取出来的Message。</li>
</ul>


<h2>如何使用</h2>

<p>HandlerThread使用起来很容易，首先需要进行初始化。
```java
private Handler mHandler;
private LightTaskManager() {</p>

<pre><code>HandlerThread workerThread = new HandlerThread("LightTaskThread");
workerThread.start();
mHandler = new Handler(workerThread.getLooper());
</code></pre>

<p>}
<code>``
注意：上面的</code>workerThread.start();`必须要执行。</p>

<p>至于如何使用HandlerThread来执行任务，主要是调用Handler的API</p>

<ul>
<li>使用post方法提交任务，postAtFrontOfQueue将任务加入到队列前端，postAtTime指定时间提交任务，postDelayed延后提交任务。</li>
<li>使用sendMessage方法可以发送消息，sendMessageAtFrontOfQueue将该消息放入消息队列前端，sendMessageAtTime 指定时间发送消息，sendMessageDelayed延后提交消息。</li>
</ul>


<p>通过包裹Handler API，我们可以实现如下代码(仅post相关方法):
```java
public void post(Runnable run) {</p>

<pre><code>mHandler.post(run);
</code></pre>

<p>}</p>

<p>public void postAtFrontOfQueue(Runnable runnable) {</p>

<pre><code>mHandler.postAtFrontOfQueue(runnable);
</code></pre>

<p>}</p>

<p>public void postDelayed(Runnable runnable, long delay) {</p>

<pre><code>mHandler.postDelayed(runnable, delay);
</code></pre>

<p>}</p>

<p>public void postAtTime(Runnable runnable, long time) {</p>

<pre><code>mHandler.postAtTime(runnable, time);
</code></pre>

<p>}
```</p>

<h2>控制优先级</h2>

<p>了解到如何使用之外，关于HandlerThread的使用需要上升一个界别，那就是优化。这里的优化主要是合理调整HandlerThread的优先级。</p>

<p>HandlerThread的默认优先级是<code>Process.THREAD_PRIORITY_DEFAULT</code>,具体值为0。线程的优先级的取值范围为-20到19。优先级高的获得的CPU资源更多，反之则越少。-20代表优先级最高，19最低。0位于中间位置，但是作为工作线程的HandlerThread没有必要设置这么高的优先级，因而需要我们降低其优先级。</p>

<h3>可控制的优先级</h3>

<ul>
<li>THREAD_PRIORITY_DEFAULT，默认的线程优先级，值为0。</li>
<li>THREAD_PRIORITY_LOWEST，最低的线程级别，值为19。</li>
<li>THREAD_PRIORITY_BACKGROUND 后台线程建议设置这个优先级，值为10。</li>
<li>THREAD_PRIORITY_MORE_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微优先，值为-1。</li>
<li>THREAD_PRIORITY_LESS_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微落后一些，值为1。</li>
</ul>


<p>以上的这些优先级都是可以在程序中设置的，除此之外还有不可控的优先级均有系统进行自动调整。</p>

<h3>如何修改权限</h3>

<p>最通用的就是在run方法中，加入合理的设置优先级代码，比如
```
Runnable run = new Runnable() {</p>

<pre><code>@Override
public void run() {
    android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
</code></pre>

<p>};
LightTaskManager.getInstance().post(run);
```
上述方法不仅适用于HandlerThread，也可以适用于其他的线程。</p>

<p>除此之外，HandlerThread的构造方法也提供了设置优先级的功能。用法如下：
<code>java
HandlerThread workerThread = new HandlerThread("LightTaskThread", Process.THREAD_PRIORITY_BACKGROUND);
</code></p>

<p>关于设置优先级，系统的AsyncTask已经开始进行了默认设置，将线程的优先级设置成THREAD_PRIORITY_BACKGROUND了。
```java
public AsyncTask() {</p>

<pre><code>mWorker = new WorkerRunnable&lt;Params, Result&gt;() {
    public Result call() throws Exception {
        mTaskInvoked.set(true);

        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
        //noinspection unchecked
        Result result = doInBackground(mParams);
        Binder.flushPendingCommands();
        return postResult(result);
    }
};
</code></pre>

<p>}
```</p>

<p>关于Android中线程的调度详情，请参考<a href="">剖析Android中进程与线程调度之nice</a></p>

<h2>应用场景</h2>

<p>我们可以使用HandlerThread处理本地IO读写操作（数据库，文件），因为本地IO操作大多数的耗时属于毫秒级别，对于单线程 + 异步队列的形式 不会产生较大的阻塞。因此在这个HandlerThread中不适合加入网络IO操作。</p>

<p>对于本地IO读取操作，我们可以使用postAtFrontOfQueue方法，快速将读取操作加入队列前端执行，必要时返回给主线程更新UI。示例场景，从数据库中读取数据展现在ListView中。注意读取也是需要花费一定时间，推荐在数据展示之前有必要的用户可感知进度提示。</p>

<p>对于本地IO写操作，根据具体情况，选择post或者postDelayed方法执行。比如SharedPreference commit，或者文件写入操作。</p>
]]></content>
  </entry>
  
</feed>
