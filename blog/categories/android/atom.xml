<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://androidyue.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://androidyue.github.io/"/>
  <updated>2014-06-13T23:07:45+08:00</updated>
  <id>http://androidyue.github.io/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android NinePatch Attention]]></title>
    <link href="http://androidyue.github.io/blog/2014/04/26/android-ninepatch-attention/"/>
    <updated>2014-04-26T12:23:00+08:00</updated>
    <id>http://androidyue.github.io/blog/2014/04/26/android-ninepatch-attention</id>
    <content type="html"><![CDATA[<p>I have got many crash report data about using NinePath Drwable. I put a .9.png file into the drawable-xhdpi folder and the file did not exist in any other folder. And I got ResourceNotFoundException. I got this following sayings.</p>

<blockquote><p>A NinePatchDrawable graphic is a stretchable bitmap image, which Android will automatically resize to accommodate the contents of the View in which you have placed it as the background. An example use of a NinePatch is the backgrounds used by standard Android buttons — buttons must stretch to accommodate strings of various lengths. A NinePatch drawable is a standard PNG image that includes an extra 1-pixel-wide border. <strong>It must be saved with the extension .9.png, and saved into the res/drawable/ directory of your project.</strong>
<a href="http://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch">http://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch</a></p></blockquote>

<p>The .9.png files must be saved into the res/drawable directory. Why? I guess the legacy Resouce Loading System implemententation may result in this issue. So at least put one .9.png file into the drawable folder.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fix Notification Switching Position Issue]]></title>
    <link href="http://androidyue.github.io/blog/2014/03/21/fix-notification-switching-position-issue/"/>
    <updated>2014-03-21T22:14:00+08:00</updated>
    <id>http://androidyue.github.io/blog/2014/03/21/fix-notification-switching-position-issue</id>
    <content type="html"><![CDATA[<p>I once faced with a problem. I wrote a piece of code related with notifcation. Everything goes fine except one little issue. I found the ongoing notification switching order. My notification blinked each second.  After Googling I found the reason and resolved the problem.<br/>
In my code I wrote like this
```java</p>

<pre><code>notification.when = System.currentTimeMillis();
</code></pre>

<p><code>
That's was the key point. For the notification the when timestamp should be fixed when an activity starts. And the default value is Now(which is the value of System.currentTimeMillis()).I used **a fixed value** and resovled the problem.
</code>java
notification.when = TIMESTAMP_FIXED;
```
Now This is what Google says</p>

<blockquote><p>A timestamp related to this notification, in milliseconds since the epoch. Default value: Now. Choose a timestamp that will be most relevant to the user. For most finite events, this corresponds to the time the event happened (or will happen, in the case of events that have yet to occur but about which the user is being informed). Indefinite events should be timestamped according to when the activity began. Some examples:</p>

<ul>
<li>Notification of a new chat message should be stamped when the message was received.</li>
<li>Notification of an ongoing file download (with a progress bar, for example) should be stamped when the download started.</li>
<li>Notification of a completed file download should be stamped when the download finished.</li>
<li>Notification of an upcoming meeting should be stamped with the time the meeting will begin (that is, in the future).</li>
<li>Notification of an ongoing stopwatch (increasing timer) should be stamped with the watch&rsquo;s start time.</li>
<li>Notification of an ongoing countdown timer should be stamped with the timer&rsquo;s end time.
Reference from <a href="http://developer.android.com/reference/android/app/Notification.html#when">http://developer.android.com/reference/android/app/Notification.html#when</a>
Written with <a href="https://stackedit.io/">StackEdit</a>.</li>
</ul>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Snippet For Media on Android]]></title>
    <link href="http://androidyue.github.io/blog/2014/02/09/code-snippet-for-media-on-android/"/>
    <updated>2014-02-09T19:37:00+08:00</updated>
    <id>http://androidyue.github.io/blog/2014/02/09/code-snippet-for-media-on-android</id>
    <content type="html"><![CDATA[<p>A few days ago,I have wrote down this post <a href="http://androidyue.github.io/blog/2014/01/19/scan-media-files-in-android/">http://androidyue.github.io/blog/2014/01/19/scan-media-files-in-android/</a>. Now I will paste my code snippet.</p>

<h3>MediaUtils.java</h3>

<p>```java
package com.mx.browser.utils;</p>

<p>import java.io.File;
import java.util.Locale;</p>

<p>import com.mx.utils.FileUtils;
import com.mx.utils.Log;</p>

<p>import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.media.MediaScannerConnection;
import android.media.MediaScannerConnection.OnScanCompletedListener;
import android.net.Uri;
import android.provider.MediaStore.Audio;
import android.provider.MediaStore.Images;
import android.provider.MediaStore.Video;
import android.text.TextUtils;</p>

<p>/<em>*
 * Utility Methods for Media Library Operations
 * @author androidyue
 * Referrer  <a href="http://androidyue.github.io/blog/2014/01/19/scan-media-files-in-android/">http://androidyue.github.io/blog/2014/01/19/scan-media-files-in-android/</a>
 </em>/
public class MediaUtils {</p>

<pre><code>private static final String LOGTAG = "MediaUtils";

/**
 * Scan a media file by sending a broadcast.This is the easiest way.
 * 对方成功接收广播并处理条件  文件必须存在，文件路径必须以Environment.getExternalStorageDirectory().getPath() 的返回值开头
 */
public static void sendScanFileBroadcast(Context context, String filePath) {
        File file = new File(filePath);
        Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.fromFile(file));
        context.sendBroadcast(intent);
}


/**
 * 
 * @param context
 * @param paths File paths to scan 
 * @param mimeTypes mimeTypes in array;it could be null;then 
 * @param callback
 */
public static void scanFiles(Context context, String[] paths, String[] mimeTypes, OnScanCompletedListener callback) {
    if (null != paths &amp;&amp; paths.length != 0) {
        MediaScannerConnection.scanFile(context, paths, mimeTypes, callback);
    } else {
        Log.i(LOGTAG, "scanFiles paths = null or paths.length=0 paths=" + paths);
    }
}

public static void scanFiles(Context context, String[] paths, String[] mimeTypes) {
    scanFiles(context, paths, mimeTypes, null);
}

public static void scanFiles(Context context, String[] paths) {
    scanFiles(context, paths, null);
}

public static int removeImageFromLib(Context context, String filePath) {
    ContentResolver resolver = context.getContentResolver();
    return resolver.delete(Images.Media.EXTERNAL_CONTENT_URI, Images.Media.DATA + "=?", new String[]{filePath});
}

public static int removeAudioFromLib(Context context, String filePath) {
    return context.getContentResolver().delete(Audio.Media.EXTERNAL_CONTENT_URI, 
            Audio.Media.DATA + "=?", new String[] {filePath});
}

public static int removeVideoFromLib(Context context, String filePath) {
    return context.getContentResolver().delete(Video.Media.EXTERNAL_CONTENT_URI, 
            Video.Media.DATA + "=?", new String[] {filePath});

}

public static int removeMediaFromLib(Context context, String filePath) {
    String mimeType = FileUtils.getFileMimeType(filePath);
    int affectedRows = 0;
    if (null != mimeType) {
        mimeType = mimeType.toLowerCase(Locale.US);
        if (isImage(mimeType)) {
            affectedRows = removeImageFromLib(context, filePath);
        } else if (isAudio(mimeType)) {
            affectedRows = removeAudioFromLib(context ,filePath);
        } else if (isVideo(mimeType)) {
            affectedRows = removeVideoFromLib(context, filePath);
        }
    }
    return affectedRows;
}

public static boolean isAudio(String mimeType) {
    return mimeType.startsWith("audio");
}

public static boolean isImage(String mimeType) {
    return mimeType.startsWith("image");
}

public static boolean isVideo(String mimeType) {
    return mimeType.startsWith("video");
}


public static boolean isMediaFile(String filePath) {
    String mimeType = FileUtils.getFileMimeType(filePath);
    return isMediaType(mimeType);
}

public static boolean isMediaType(String mimeType) {
    boolean isMedia = false;
    if (!TextUtils.isEmpty(mimeType)) {
        mimeType = mimeType.toLowerCase(Locale.US);
        isMedia = isImage(mimeType) || isAudio(mimeType) || isVideo(mimeType);
    }
    return isMedia;
}


/**
 * Before using it,please do have a media type check.
 * @param context
 * @param srcPath
 * @param destPath
 * @return
 */
public static int renameMediaFile(Context context, String srcPath, String destPath) {
    removeMediaFromLib(context, srcPath);
    sendScanFileBroadcast(context, destPath);
    return 0;
}
</code></pre>

<p>}</p>

<p>```</p>

<h3>FileUtils.java</h3>

<p>```java</p>

<pre><code>public static String getFileMimeType(String filename) {
    if (TextUtils.isEmpty(filename)) {
        return null;
    }
    int lastDotIndex = filename.lastIndexOf('.');
    String mimetype = MimeTypeMap.getSingleton().getMimeTypeFromExtension(
            filename.substring(lastDotIndex + 1).toLowerCase());
    Log.i(LOGTAG, "getFileMimeType mimeType = " + mimetype);
    return mimetype;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scan Media Files In Android]]></title>
    <link href="http://androidyue.github.io/blog/2014/01/19/scan-media-files-in-android/"/>
    <updated>2014-01-19T19:39:00+08:00</updated>
    <id>http://androidyue.github.io/blog/2014/01/19/scan-media-files-in-android</id>
    <content type="html"><![CDATA[<p>I once tried to use MediaScanner to resolve problems; however it turned out to be a failure. Now I make it.This post is to write down why I failed and how I work it out now. I think it could be deeper that other posts.</p>

<h2>Android Media Scanning Mechanism</h2>

<p>Android provides a great application for developers to add created media files to add them into the library. The application is called MediaProvider. Now let&rsquo;s have a glance of MediaProvider. <br/>
The receiver part of its  manifest
```xml</p>

<pre><code>    &lt;receiver android:name="MediaScannerReceiver"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt;
        &lt;/intent-filter&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MEDIA_MOUNTED" /&gt;
            &lt;data android:scheme="file" /&gt;
        &lt;/intent-filter&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MEDIA_UNMOUNTED" /&gt;
            &lt;data android:scheme="file" /&gt;
        &lt;/intent-filter&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MEDIA_SCANNER_SCAN_FILE" /&gt;
            &lt;data android:scheme="file" /&gt;
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
</code></pre>

<p>```
The MediaScannerReceiver will receive the above intents with right action and data scheme.</p>

<h3>How the MediaScannerRecieve handles the intent</h3>

<ul>
<li>It will scan internal storage only after receiving the <strong>action android.intent.action.BOOT_COMPLETED</strong></li>
<li>All intent but the <strong>android.intent.action.BOOT_COMPLETED</strong> intent should carry the file scheme data</li>
<li>It will scan external storage when receiving the <strong>Intent.ACTION_MEDIA_MOUNTED</strong> intent.</li>
<li>It will scan the single file when receiving the <strong>Intent.ACTION_MEDIA_SCANNER_SCAN_FILE</strong> intent.

<h3>How the MediaScannerService works</h3>

<p>Actually receiver does not do scanning. It will start a service called MediaScannerService.
The service part of its manifest
<code>xml
    &lt;service android:name="MediaScannerService" android:exported="true"&gt;
         &lt;intent-filter&gt;
             &lt;action android:name="android.media.IMediaScannerService" /&gt;
         &lt;/intent-filter&gt;
     &lt;/service&gt;
</code></p></li>
</ul>


<p>scanFile Method
```java</p>

<pre><code>private Uri scanFile(String path, String mimeType) {
    String volumeName = MediaProvider.EXTERNAL_VOLUME;
    openDatabase(volumeName);
    MediaScanner scanner = createMediaScanner();
    return scanner.scanSingleFile(path, volumeName, mimeType);
}
</code></pre>

<p><code>
scan Method
</code>java</p>

<pre><code>private void scan(String[] directories, String volumeName) {
    // don't sleep while scanning
    mWakeLock.acquire();

    ContentValues values = new ContentValues();
    values.put(MediaStore.MEDIA_SCANNER_VOLUME, volumeName);
    Uri scanUri = getContentResolver().insert(MediaStore.getMediaScannerUri(), values);

    Uri uri = Uri.parse("file://" + directories[0]);
    sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_STARTED, uri));

    try {
        if (volumeName.equals(MediaProvider.EXTERNAL_VOLUME)) {
            openDatabase(volumeName);
        }

        MediaScanner scanner = createMediaScanner();
        scanner.scanDirectories(directories, volumeName);
    } catch (Exception e) {
        Log.e(TAG, "exception in MediaScanner.scan()", e);
    }

    getContentResolver().delete(scanUri, null, null);

    sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, uri));
    mWakeLock.release();
}
</code></pre>

<p><code>
Actually the scan code is not really in the MediaScannerService
</code>java
private MediaScanner createMediaScanner() {</p>

<pre><code>    MediaScanner scanner = new MediaScanner(this);
    Locale locale = getResources().getConfiguration().locale;
    if (locale != null) {
        String language = locale.getLanguage();
        String country = locale.getCountry();
        String localeString = null;
        if (language != null) {
            if (country != null) {
                scanner.setLocale(language + "_" + country);
            } else {
                scanner.setLocale(language);
            }
        }    
    }

    return scanner;
</code></pre>

<p>}
```
It&rsquo;s using the android.media.MediaScanner
<a href="https://android.googlesource.com/platform/frameworks/base/+/cd92588/media/java/android/media/MediaScanner.java">https://android.googlesource.com/platform/frameworks/base/+/cd92588/media/java/android/media/MediaScanner.java</a></p>

<h2>How To Scan A Created File</h2>

<p>Now I am going to introduce two ways to add a created file into the media library.</p>

<h3>The Simplest Method</h3>

<p>Just send a broadcast, as we have posted above. Just send a broadcast intent to MediaScannerReceiver.
```java</p>

<pre><code>String saveAs = "Your_Created_File_Path"
Uri contentUri = Uri.fromFile(new File(saveAs));
Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,contentUri);
getContext().sendBroadcast(mediaScanIntent);
</code></pre>

<p>```
The above method maybe has been seen thousands of times. Actually it should work. However I failed and failed in sending broadcast intent. In the following section. I will point out why the sending broadcast not works. Even though you get well on with sending broadcast,it&rsquo;s strongly recommended to read the Section Why Sending MEDIA_SCANNER_SCAN_FILE broadcast not works.</p>

<h3>Use MediaScannerConnection</h3>

<p>```java</p>

<pre><code>public void mediaScan(File file) {
    MediaScannerConnection.scanFile(getActivity(),
            new String[] { file.getAbsolutePath() }, null,
            new OnScanCompletedListener() {
                @Override
                public void onScanCompleted(String path, Uri uri) {
                    Log.v("MediaScanWork", "file " + path
                            + " was scanned seccessfully: " + uri);
                }
            });
}
</code></pre>

<p>```
the scanFile method is introduced since API 8</p>

<h3>Create an instance and call scanFile (String path, String mimeType)</h3>

<p>It&rsquo;s really easy, just read the post <a href="http://developer.android.com/reference/android/media/MediaScannerConnection.html">http://developer.android.com/reference/android/media/MediaScannerConnection.html</a></p>

<h3>How To Scan Mutiple Files</h3>

<ul>
<li>Sending Mutiple Intent.ACTION_MEDIA_SCANNER_SCAN_FILE broadcast intents.</li>
<li>Use the second method by filled the second params with an array of paths.</li>
</ul>


<h2>Why Sending MEDIA_SCANNER_SCAN_FILE broadcast not works</h2>

<p>Actually someone may think sending ACTION_MEDIA_SCANNER_SCAN_FILE works on some devices but not on other devices. Actually it&rsquo;s. Is it a API limit?<br/>
No, It&rsquo;s has someting to do with your file path.
Take a look at this
```java</p>

<pre><code>public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    Uri uri = intent.getData();
    if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
        // scan internal storage
        scan(context, MediaProvider.INTERNAL_VOLUME);
    } else {
        if (uri.getScheme().equals("file")) {
            // handle intents related to external storage
            String path = uri.getPath();
            String externalStoragePath = Environment.getExternalStorageDirectory().getPath();

            Log.d(TAG, "action: " + action + " path: " + path);
            if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
                // scan whenever any volume is mounted
                scan(context, MediaProvider.EXTERNAL_VOLUME);
            } else if (action.equals(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE) &amp;&amp;
                    path != null &amp;&amp; path.startsWith(externalStoragePath + "/")) {
                scanFile(context, path);
            }
        }
    }
}
</code></pre>

<p><code>
Every part is right except the intent data. I mean the file path. You may hardcode the filepath. This is my example
</code>java</p>

<pre><code>final String saveAs = "/sdcard/" + System.currentTimeMillis() + "_add.png";
Uri contentUri = Uri.fromFile(new File(saveAs));
Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,contentUri);
getContext().sendBroadcast(mediaScanIntent);
Uri uri = mediaScanIntent.getData();
String path = uri.getPath();
String externalStoragePath = Environment.getExternalStorageDirectory().getPath();
Log.i("LOGTAG", "Androidyue onReceive intent= " + mediaScanIntent 
                        + ";path=" + path + ";externalStoragePath=" +
                        externalStoragePath);
</code></pre>

<p><code>
And this is the output log
</code>bash
LOGTAG Androidyue onReceive intent= Intent { act=android.intent.action.MEDIA_SCANNER_SCAN_FILE dat=file:///sdcard/1390136305831_add.png };path=/sdcard/1390136305831_add.png;externalStoragePath=/mnt/sdcard
```
So in the sending broadcast, your action is right, your data schema  OK, your data path not null;but your path  /sdcard/1390136305831_add.png does not <strong>startswith</strong> the externalStoragePath /mnt/sdcard/
And so the scan file is actually <strong>not called</strong>.
In conclusion your hardcoding path results in the failure.</p>

<h2>Remove From Media Library</h2>

<p>If we deleted a file ,it means that we need to remove the file from the media library.</p>

<h3>Simply sending a broadcast?</h3>

<p>Can we simple sending a broadcast to the MediaScannerReceiver? I also wish it could. But actually it does not work.
Look at this code for the explanation.
```java</p>

<pre><code>// this function is used to scan a single file
public Uri scanSingleFile(String path, String volumeName, String mimeType) {
    try {
        initialize(volumeName);
        prescan(path, true);

        File file = new File(path);
        if (!file.exists()) {
            return null;
        }

        // lastModified is in milliseconds on Files.
        long lastModifiedSeconds = file.lastModified() / 1000;

        // always scan the file, so we can return the content://media Uri for existing files
        return mClient.doScanFile(path, mimeType, lastModifiedSeconds, file.length(),
                false, true, MediaScanner.isNoMediaPath(path));
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in MediaScanner.scanFile()", e);
        return null;
    }
}
</code></pre>

<p><code>
As the above code points out, It does have a check before the real scanning.
Then how should I do?
</code>java</p>

<pre><code>public void testDeleteFile() {
    String existingFilePath = "/mnt/sdcard/1390116362913_add.png";
    File  existingFile = new File(existingFilePath);
    existingFile.delete();
    ContentResolver resolver = getActivity().getContentResolver();
    resolver.delete(Images.Media.EXTERNAL_CONTENT_URI, Images.Media.DATA + "=?", new String[]{existingFilePath});

}
</code></pre>

<p>```
The above code works. Just remove from Media Provider</p>

<h2>Special</h2>

<ul>
<li>You could check the external.db or internal.db file under /data/data/com.android.providers.media/ for more detailed information.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Set The Preferred Application in Android]]></title>
    <link href="http://androidyue.github.io/blog/2014/01/12/set-the-preferred-application-in-android/"/>
    <updated>2014-01-12T14:29:00+08:00</updated>
    <id>http://androidyue.github.io/blog/2014/01/12/set-the-preferred-application-in-android</id>
    <content type="html"><![CDATA[<p>A great application should provide a function to let users set it as the preferred or default application. In this post, I will make a description on PreferredApplication<br/>
Before an application is about to be set as default, it has two possibilities. One is that there is already a default application and the other is no default application.</p>

<h3>Detect the Default Application Exists or Not</h3>

<p>This is really important. It determines what we should do next.
```java</p>

<pre><code>public void testGetDefaultActivity() {
    PackageManager pm = mContext.getPackageManager();
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setData(Uri.parse("http://www.google.com"));
    ResolveInfo info = pm.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
    Log.i(VIEW_LOG_TAG, "getDefaultActivity info = " + info + ";pkgName = " + info.activityInfo.packageName);
</code></pre>

<p>}
<code>
Result before I set Maxthon Browser as the default one. If no default one is set, the system will call the com.android.internal.app.ResolverActivity
</code>java
I/View    ( 1145 ): View getDefaultActivity info = ResolveInfo{410e4868 com.android.internal.app.ResolverActivity p=0 o=0 m=0x0};pkgName = android
<code>
Result after I set Maxthon Browser as the default one. If the default one is set just call the default activity
</code>java
I/View    ( 1145 ): View getDefaultActivity info = ResolveInfo{410ae1e8 com.mx.browser.MxBrowserActivity p=0 o=0 m=0x208000};pkgName = com.mx.browser
<code>
So it is really clear that you could use the following code to judge.
</code>
//Use this to determine whether default application is set or not
boolean defaultSet = !&ldquo;android&rdquo;.equals(info.activityInfo.packageName);
```</p>

<h3>If the default one is already set</h3>

<p>Just remove the preferred settings of the default application. However you could not do this in the code due to the permission control. It&rsquo;s generally done by users manually. What you could do is lead the user to the clear default page(installedAppDetails)
```java
public void testStartAppDetails() {</p>

<pre><code>//Use the destination package name
Intent intent = new Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS, Uri.parse("package:com.mx.browser"));
getActivity().startActivity(intent);
</code></pre>

<p>}
```
Then you navigate the user to the installedAppDetails and you could show some tips to click Button Clear Default.
<img src="/images/post_images/installed_app_details_clear_default.png">
When users go back from installedAppDetails to your application check is there any default appliction now. If the default application(in general, it&rsquo;s not the previous one) remains repeat the above actions until there is not default one.</p>

<h3>No default One</h3>

<p>Now there is only one step to set ours as the default one. You could not do this in codes. It&rsquo;s also required manual operation. What you could do is popup the selecting dialog and tip the use select your one.</p>

<p>```java
public void testStartChooseDialog() {</p>

<pre><code>Intent intent = new Intent();
intent.setAction("android.intent.action.VIEW");
intent.addCategory("android.intent.category.BROWSABLE");
intent.setData(Uri.parse("http://androidyue.github.io/"));
intent.setComponent(new ComponentName("android","com.android.internal.app.ResolverActivity"));
getActivity().startActivity(intent);
</code></pre>

<p>}
```
The dialog is like this <br/>
<img src="/images/post_images/choose_default_activity_dialog.png"><br/>
What&rsquo;s more, your tips is really essential. Make sure to notify that  &ldquo;Use by default for this action&rdquo; should be  checked.</p>

<h3>How to Clear my own default</h3>

<p>```java
public void testClearDefault() {</p>

<pre><code>PackageManager pm = mContext.getPackageManager();
pm.clearPackagePreferredActivities(mContext.getPackageName());
</code></pre>

<p>}
```
Note you could only clear packagePreferredActivities of your own.</p>

<h3>A step into system control</h3>

<p>the following settings is some content of /data/system/packages.xml
<code>xml
&lt;preferred-activities&gt;
&lt;item name="com.mx.browser/.MxBrowserActivity" match="200000" set="2"&gt;
&lt;set name="com.android.browser/.BrowserActivity" /&gt;
&lt;set name="com.mx.browser/.MxBrowserActivity" /&gt;
&lt;filter&gt;
&lt;action name="android.intent.action.VIEW" /&gt;
&lt;cat name="android.intent.category.BROWSABLE" /&gt;
&lt;cat name="android.intent.category.DEFAULT" /&gt;
&lt;scheme name="http" /&gt;
&lt;/filter&gt;
&lt;/item&gt;
&lt;/preferred-activities&gt;
</code></p>

<h3>Special</h3>

<ul>
<li>What will system do if I install or uninstall a related  application?</li>
<li>Actually the system provide you a special chance to rechoose if a related activity is added or removed. When you click the url it should popup a dialog not use the previous preferred activity.</li>
<li>When the system popup the choosing dialog?</li>
<li>After some tests I guess the system will make  a list of  interested activities instantly. And then use the previous list to compare with the list stored in /data/system/packages.xml. If they are not the same, the choose dialog should be poped up.</li>
</ul>

]]></content>
  </entry>
  
</feed>
