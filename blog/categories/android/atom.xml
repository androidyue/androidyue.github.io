<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2014-11-29T17:08:00+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[偷懒的OnSharedPreferenceChangeListener]]></title>
    <link href="http://droidyue.com/blog/2014/11/29/why-onsharedpreferencechangelistener-was-not-called/"/>
    <updated>2014-11-29T16:41:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/29/why-onsharedpreferencechangelistener-was-not-called</id>
    <content type="html"><![CDATA[<p>之前使用OnSharedPreferenceChangeListener，遇到了点小问题，就是有些时候OnSharedPreferenceChangeListener没有被触发。最近花了点时间研究了一下，小做整理。本文将会介绍监听器不被触发的原因，解决方法，以及其中隐含的一些技术细节。</p>

<!--more-->


<h2>问题再现</h2>

<p>OnSharedPreferenceChangeListener是Android中SharedPreference文件发生变化的监听器。通常我们想要进行监听，会实现如下的代码。
```java
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>PreferenceManager.getDefaultSharedPreferences(getApplicationContext())
    .registerOnSharedPreferenceChangeListener(new OnSharedPreferenceChangeListener() {
    @Override
    public void onSharedPreferenceChanged(
        SharedPreferences sharedPreferences, String key) {
        Log.i(LOGTAG, "testOnSharedPreferenceChangedWrong key =" + key);
    }
});
</code></pre>

<p>}
```
这种写法看上去没有什么问题，而且很多时候开始几次onSharedPreferenceChanged方法也可以被调用。但是过一段时间（简单demo不容易出现，但是使用DDMS中的gc会立刻导致接下来的问题），你会发现前面的方法突然不再被调用，进而影响到程序的处理。</p>

<h2>原因剖析</h2>

<p>简而言之，就是你注册的监听器被移除掉了。<br/>
首先我们先了解一下registerOnSharedPreferenceChangeListener注册的实现。
```
private final WeakHashMap&lt;OnSharedPreferenceChangeListener, Object> mListeners =</p>

<pre><code>        new WeakHashMap&lt;OnSharedPreferenceChangeListener, Object&gt;();
</code></pre>

<p>//some code goes here
public void More &hellip;registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {</p>

<pre><code>synchronized(this) {
    mListeners.put(listener, mContent);
}
</code></pre>

<p>}
```
从上面的代码可以得知，一个OnSharedPreferenceChangeListener对象实际上是放到了一个WeakHashMap的容器中，执行完示例中的onCreate方法，这个监听器对象很快就会成为垃圾回收的目标，由于放在WeakHashMap中作为key不会阻止垃圾回收，所以当监听器对象被回收之后，这个监听器也会从mListeners中移除。所以就造成了onSharedPreferenceChanged不会被调用。</p>

<p>关于WeakHashMap相关，请阅读<a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">译文：理解Java中的弱引用</a>进而更多了解。</p>

<h2>如何解决</h2>

<h3>改为对象成员变量（推荐）</h3>

<p>将监听器作为Activity的一个成员变量，在Activity的onResume进行注册，在onPause时进行注销。推荐在这两个Activity生命周期中进行处理，尤其是当SharedPreference值发生变化后，对Activity展示的UI进行处理操作的情况。这种方法是最推荐的解决方案。
```java
private OnSharedPreferenceChangeListener mListener = new OnSharedPreferenceChangeListener() {</p>

<pre><code>@Override
public void onSharedPreferenceChanged(
    SharedPreferences sharedPreferences, String key) {
    Log.i(LOGTAG, "instance variable key=" + key);
}
</code></pre>

<p>};</p>

<p>@Override
protected void onResume() {</p>

<pre><code>PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).registerOnSharedPreferenceChangeListener(mListener);
super.onResume();
</code></pre>

<p>}</p>

<p>@Override
protected void onPause() {</p>

<pre><code>PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).unregisterOnSharedPreferenceChangeListener(mListener);
super.onPause();
</code></pre>

<p>}
```</p>

<h3>改为静态变量（不推荐）</h3>

<p>如下，将一个指向匿名的内部类对象的变量sListener使用static修饰，这个内部类对象则不会持有外部类的引用。<br/>
但是这种做法并不推荐，因为一个静态变量和与外部实例不相关，我们很难和外部实例进行一些操作。
```java
private static OnSharedPreferenceChangeListener sListener = new OnSharedPreferenceChangeListener() {</p>

<pre><code>@Override
public void onSharedPreferenceChanged(
    SharedPreferences sharedPreferences, String key) {
    Log.i(LOGTAG, "static variable key=" + key);
}
</code></pre>

<p>};
```</p>

<h2>为什么这样设计</h2>

<p>可能会有人认为这是系统设计的猫腻或者bug，其实不然，这正是Android设计人员的高明之处。</p>

<p>正如我们示例的代码一样，将一个（隐式的）局部变量添加到监听器容器中，如果该容器只是一个普通的HashMap，这样会导致内存泄露，因为该容器还有局部变量指向的对象，该对象又隐式持有外部Activity的对象，导致Activity无法被销毁。关于非静态内部类持有隐式持有外部类引用，请参考<a href="http://droidyue.com/blog/2014/10/02/the-private-modifier-in-java/">细话Java："失效"的private修饰符</a></p>

<p>除此之外，因为局部变量无法在其所在方法外部访问，这样就导致了我们只可以使用方法中使用局部变量就行注册，在合适的时机却无法使用局部变量进行注销。</p>

<h2>三本帮助深入研究Java的书</h2>

<ul>
<li><a href="http://www.amazon.cn/gp/product/0137142528/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=0137142528&amp;linkCode=as2&amp;tag=droidyue-23">Java Performance</a></li>
<li><a href="http://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011F7WU4&amp;linkCode=as2&amp;tag=droidyue-23">Java编程思想(第4版)</a></li>
<li><a href="http://www.amazon.cn/gp/product/B001PTGR52/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001PTGR52&amp;linkCode=as2&amp;tag=droidyue-23">Sun 公司核心技术丛书:Effective Java中文版(第2版)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中WebView拦截替换网络请求数据]]></title>
    <link href="http://droidyue.com/blog/2014/11/23/block-web-resource-in-webview/"/>
    <updated>2014-11-23T21:54:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/23/block-web-resource-in-webview</id>
    <content type="html"><![CDATA[<p>Android中处理网页时我们必然用到WebView,这里我们有这样一个需求，我们想让WebView在处理网络请求的时候将某些请求拦截替换成某些特殊的资源。具体一点儿说，在WebView加载 <code>http://m.sogou.com</code> 时，会加载一个logo图片，我们的需求就是将这个logo图片换成另一张图片。</p>

<!--more-->


<h3>shouldInterceptRequest</h3>

<p>好在Android中的WebView比较强大，从API 11(Android 3.0)开始， shouldInterceptRequest被引入就是为了解决这一类的问题。</p>

<p>shouldInterceptRequest这个回调可以通知主程序WebView处理的资源（css,js,image等）请求，并允许主程序进行处理后返回数据。如果主程序返回的数据为null，WebView会自行请求网络加载资源，否则使用主程序提供的数据。注意这个回调发生在非UI线程中,所以进行UI系统相关的操作是不可以的。</p>

<p>shouldInterceptRequest有两种重载。</p>

<ul>
<li><strong>public WebResourceResponse shouldInterceptRequest (WebView view, String url)</strong> 从API 11开始引入，API 21弃用</li>
<li><strong>public WebResourceResponse shouldInterceptRequest (WebView view, WebResourceRequest request)</strong> 从API 21开始引入</li>
</ul>


<p>本次例子暂时使用第一种，即shouldInterceptRequest (WebView view, String url)。</p>

<h3>示例代码</h3>

<p>```java
WebView webView = new WebView(this);
webView.setWebViewClient(new WebViewClient() {</p>

<pre><code>@Override
public WebResourceResponse shouldInterceptRequest(WebView view, String url) {
    Log.i(LOGTAG, "shouldInterceptRequest url=" + url + ";threadInfo" + Thread.currentThread());
    WebResourceResponse response = null;
    if (url.contains("logo")) {
        try {
            InputStream localCopy = getAssets().open("droidyue.png");
            response = new WebResourceResponse("image/png", "UTF-8", localCopy);
        } catch (IOException e) {
            e.printStackTrace();
        }       
    }
    return response;
}   
</code></pre>

<p>});
setContentView(webView);
webView.loadUrl(&ldquo;<a href="http://m.sogou.com">http://m.sogou.com</a>&rdquo;);
```
其中WebResourceResponse需要设定三个属性，MIME类型，数据编码，数据(InputStream流形式)。</p>

<h3>示例下载</h3>

<ul>
<li><a href="http://pan.baidu.com/s/1ntOaHoH">百度云盘</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[点击网页链接调用Android程序]]></title>
    <link href="http://droidyue.com/blog/2014/11/23/start-android-application-when-click-a-link/"/>
    <updated>2014-11-23T15:58:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/23/start-android-application-when-click-a-link</id>
    <content type="html"><![CDATA[<p>最近前端同事问了我一个问题，如何让网页链接实现启动Android的应用，网上有说重写WebView相关的shouldOverrideUrlLoading方法，但是这种理论上能实现，因为你的网页不是仅仅被你自己的webview来浏览，你需要做的是让市面上的浏览器支持才行。</p>

<p>这里利用零碎的时间整理一下。主要涉及到的问题就是关于Intent在字符串形式和Intent对象之间的转换。如果你是一位前端工程师，请让你的Anroid开发小伙伴来看这篇文章，一同解决问题。</p>

<!--more-->


<h2>两种表现形式</h2>

<p>Intent是Android开发中常见的API。在处理Android组件中，有着必不可少的作用。Intent可以以两种方式存在。</p>

<ul>
<li>Intent对象。用于在程序中处理，在处理Android组件时使用。</li>
<li>字符串形式的URI。 用于在非程序代码中，如网页中进行使用等。</li>
</ul>


<p>而这里我们解决我们上面问题的就是后者，字符串形式的Intent。</p>

<h2>Intent对象转成字符串URI</h2>

<p>Intent提供了两种将对象转换成字符串URI，一个是推荐的<code>public String toUri (int flags)</code>，
在API 4加入，将Intent对象转换成字符串形式的URI。字符串形式的URI可以包含Intent的data,action,categories, type, flags, package, component和extras。
<code>java
Intent intent = new Intent();
ComponentName comp = new ComponentName("com.mx.app.mxhaha", "com.mx.app.MxMainActivity");
intent.setComponent(comp);
Log.i(LOGTAG, "intent.uri=" + intent.toUri(Intent.URI_INTENT_SCHEME));
</code>
生成的字符串URI为
<code>
intent:#Intent;component=com.mx.app.mxhaha/com.mx.app.MxMainActivity;end
</code></p>

<p>另一个方法是<code>public String toURI ()</code>，
这是一个弃用的方法，因为它生成的字符串以<strong>#</strong>开头，<strong>放在链接上会被当成锚点</strong>。不建议使用使用这个方法。</p>

<p>上面的Intent对象使用toUri转换成
```</p>

<h1>Intent;component=com.mx.app.mxhaha/com.mx.app.MxMainActivity;end</h1>

<p>```</p>

<h2>字符串URI转成Intent对象</h2>

<h3>getIntent(String uri)</h3>

<p>这个方法只适用于处理以#开头的URI，而且在其方法内部实际上是调用的<code>parseUri(uri, 0)</code>来实现的。这个方法已经被比较为弃用，不推荐使用。</p>

<h3>getIntentOld(String uri)</h3>

<p>getIntentOld既可以支持#开头的URI转换成Intent对象，如果uri不是Intent的字符串形式，那么也会返回一个Intent，只是其data部分为uri，action为android.intent.action.VIEW。</p>

<h3>parseUri(String uri, int flags)</h3>

<p>这个是最完整的转换方法。接收uri和flag作为参数。支持将字符串形式的URI转成Intent对象.</p>

<p>以下为一个既可以解析<strong>intent:</strong>开头的URI也可以解析<strong>#Intent</strong>开头的URI的方法。
```java
public static Intent parseIntent(String url) {</p>

<pre><code>Intent intent = null;
// Parse intent URI into Intent Object
int flags = 0;
boolean isIntentUri = false;
if (url.startsWith("intent:")) {
    isIntentUri = true;
    flags = Intent.URI_INTENT_SCHEME;
} else if (url.startsWith("#Intent;")) {
    isIntentUri = true;
}
if (isIntentUri) {
    try {
        intent = Intent.parseUri(url, flags);
    } catch (URISyntaxException e) {
        e.printStackTrace();
    }
}
return intent;
</code></pre>

<p>}
```</p>

<h2>多说一下</h2>

<p>对于Intent字符串形式URI在网页链接中的应用，不同的浏览器实现程度不一致。目前<a href="http://www.maxthon.cn/">傲游浏览器Android版</a>由我已经完全实现这一功能。希望其他的浏览器也可以实现一下这个功能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[译文：理解Android中垃圾回收日志信息]]></title>
    <link href="http://droidyue.com/blog/2014/11/08/understanding-garbage-collection-output-messages-in-android/"/>
    <updated>2014-11-08T18:16:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/08/understanding-garbage-collection-output-messages-in-android</id>
    <content type="html"><![CDATA[<p>如果你是一名Android开发者并且常常看程序日志的话，那么下面的这些信息对你来说可能一点都不陌生。
<code>java
GC_CONCURRENT freed 178K, 41% free 3673K/6151K, external 0K/0K, paused 2ms+2ms
GC_EXPLICIT freed 6K, 41% free 3667K/6151K, external 0K/0K, paused 29ms
GC_CONCURRENT freed 379K, 42% free 3856K/6535K, external 0K/0K, paused 2ms+3ms
GC_EXPLICIT freed 144K, 41% free 3898K/6535K, external 0K/0K, paused 32ms
GC_CONCURRENT freed 334K, 40% free 4091K/6727K, external 0K/0K, paused 2ms+3ms
</code></p>

<p>但是这些到底是什么，又有什么含义呢？</p>

<!--more-->


<p>上面的这几行就是Android系统垃圾回收的部分输出信息。每当垃圾回收被触发的时候，你就可以通过logcat查看到这样的信息。这样短短的一行的日志有着很大的信息量。比如通过日志我们可以发现程序可能有内存（泄露）问题。本文将具体介绍这些日志信息的每一部分的含义来帮助帮助大家更好地了解垃圾回收的运行情况。</p>

<h2>原因</h2>

<p><font color="red">GC_CONCURRENT</font> freed 178K, 41% free 3673K/6151K, external 0K/0K, paused 2ms+2ms <br/>
<font color="red">GC_EXPLICIT</font> freed 6K, 41% free 3667K/6151K, external 0K/0K, paused 29ms</p>

<p>红颜色标出的部分就是垃圾回收触发的原因。在Android中有五种类型的垃圾回收触发原因。</p>

<ul>
<li><strong>GC_CONCURRENT</strong> 当堆内存增长到一定程度时会触发。此时触发可以对堆中的没有用的对象及时进行回收，腾出空间供新的对象申请，避免进行不必要的增大堆内存的操作。</li>
<li><strong>GC_EXPLICIT</strong>   当程序中调用System.gc()方法触发。这个方法应避免出现在程序中调用。因为JVM有足够的能力来控制垃圾回收。</li>
<li><strong>GC_EXTERNAL_MALLOC</strong> 当Bitmap和NIO Direct ByteBuffer对象分配外部存储（机器内存，非Dalvik堆内存）触发。这个日志只有在2.3之前存在，从2.3系统开始，垃圾回收进行了调整，前面的对象都会存储到Dalivik堆内存中。所以在2.3系统之后，你就再也不会看到这种信息了。</li>
<li><strong>GC_FOR_MALLOC</strong> 当堆内存已满，系统需要更多内存的时候触发。这条日志出现后意味着JVM要暂停你的程序进行垃圾回收操作。</li>
<li><strong>GC_HPROF_DUMP_HEAP</strong> 当创建一个内存分析文件HPROF时触发。</li>
</ul>


<h2>结果</h2>

<p>GC_CONCURRENT <font color="red">freed 178K</font>, 41% free 3673K/6151K, external 0K/0K, paused 2ms+2ms <br/>
GC_EXPLICIT <font color="red">freed 6K</font>, 41% free 3667K/6151K, external 0K/0K, paused 29ms</p>

<p>这部分数据告诉我们JVM进行垃圾回收释放了多少空间。</p>

<h2>堆内存数据</h2>

<p>GC_CONCURRENT freed 178K, <font color="red">41% free 3673K/6151K</font>, external 0K/0K, paused 2ms+2ms <br/>
GC_EXPLICIT freed 6K, <font color="red">41% free 3667K/6151K</font>, external 0K/0K, paused 29ms</p>

<p>这部分告诉我们堆内存中可用内存占的比例，当前活跃的对象总的空间，以及当前堆的总大小。所以这里的数据就是41%的堆内存可用，已经使用了3673K，总的堆内存大小为6151K。</p>

<h2>外部存储数据</h2>

<p>GC_EXTERNAL_ALLOC freed 1125K, 47% free 6310K/11847K,  <font color="red">external 1051K/1103K</font>, paused 46ms<br/>
GC_EXTERNAL_ALLOC freed 295K, 47% free 6335K/11847K,  <font color="red">external 1613K/1651K</font>, paused 41ms</p>

<p>这部分数据告诉我们外部存储（位于机器内存）对象的数据。在2.3之前，bitmap对象存放在机器内存。因此在第一条数据中我们可以看到以有1051K使用，外部存储为1103K。</p>

<p>上面两行数据相差100毫秒，我们可以看到第一条数据表明外部存储快满了，由于GC_EXTERNAL_ALLOC被触发，外部存储空间扩大到了1651K。</p>

<h2>垃圾回收暂停时间</h2>

<p>GC_CONCURRENT freed 178K, 41% free 3673K/6151K, external 0K/0K, <font color="red">paused 2ms+2ms</font> <br/>
GC_EXPLICIT freed 6K, 41% free 3667K/6151K, external 0K/0K, <font color="red">paused 29ms</font></p>

<p>这部分数据表明垃圾回收消耗的时间。在GC_CONCURRENT回收时，你会发现两个暂停时间。一个是在回收开始的暂停时间，另一个时在回收结束的暂停时间。GC_CONCURRENT从2.3开始引入，相比之前的程序全部暂停的垃圾回收机制，它的暂停时间要小的多。一般少于5毫秒。因为GC_CONCURRENT的绝大多数操作在一个单独的线程中进行。</p>

<p>本文中内容摘自 Google I/O 2011: Memory management for Android Apps，如果感兴趣，请访问<a href="http://droidyue.com/blog/2014/11/02/note-for-google-io-memory-management-for-android-chinese-edition/">这里</a>了解更多。</p>

<h2>原文地址</h2>

<p><a href="https://sites.google.com/site/pyximanew/blog/androidunderstandingddmslogcatmemoryoutputmessages">https://sites.google.com/site/pyximanew/blog/androidunderstandingddmslogcatmemoryoutputmessages</a></p>

<h2>其他</h2>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B009VV6EG8/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009VV6EG8&linkCode=as2&tag=droidyue-23">Android应用性能优化</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009VV6EG8" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[啰嗦一下android中的NetworkOnMainThreadException]]></title>
    <link href="http://droidyue.com/blog/2014/11/08/look-into-android-dot-os-dot-networkonmainthreadexception/"/>
    <updated>2014-11-08T15:26:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/08/look-into-android-dot-os-dot-networkonmainthreadexception</id>
    <content type="html"><![CDATA[<p>相信很多Android开发者很多都遇到过android.os.NetworkOnMainThreadException 这个异常，意思就是主线程进行网络操作异常。这个问题比较简单，但是网络上有着鱼龙混杂的答案，这里想花点时间做一个比较完整的描述。</p>

<!--more-->


<h2>严格模式</h2>

<p>在早期的Android版本（2.3之前）中，Google并没有提供一个很严格的程序编写要求，所以在那时我们可以在主线程中执行本地IO操作，网络操作等这些不规范的行为。后来在2.3的姜饼（GINGERBREAD）开始提供了一个开发者工具，这就是StrictMode严格模式。</p>

<p>严格模式可以帮助开发者发现主线程中的磁盘操作和网络操作，开发者根据严格模式的输出信息可以改善程序来更好地响应用户操作，来较少ANR（程序未响应）的问题。</p>

<p>android.os.NetworkOnMainThreadException这个异常从Android 3.0（API 11）引入，出现情况为主线程进行网络操作。</p>

<h3>代码开启StrictMode</h3>

<p>```java
if (Build.VERSION.SDK_INT >= VERSION_CODES.GINGERBREAD) {</p>

<pre><code>ThreadPolicy.Builder threadPolicyBuilder = new StrictMode.ThreadPolicy.Builder();
threadPolicyBuilder.detectDiskReads().detectDiskWrites().detectNetwork().penaltyLog();
StrictMode.setThreadPolicy(threadPolicyBuilder.build());
VmPolicy.Builder vmPolicyBuilder = new VmPolicy.Builder();
vmPolicyBuilder.detectLeakedSqlLiteObjects().penaltyLog();
if (Build.VERSION.SDK_INT &gt;= VERSION_CODES.HONEYCOMB) {
    vmPolicyBuilder.detectLeakedClosableObjects();
}
StrictMode.setVmPolicy(vmPolicyBuilder.build());
</code></pre>

<p>}
```</p>

<h3>特别注意</h3>

<ul>
<li>严格模式不应该在发布版本时开启</li>
</ul>


<h2>治标不治本的办法</h2>

<p>下面的这段代码会让严格模式允许所有的磁盘操作和网络操作。但是这并没有改变真正解决问题，主线程中照样还是有网络操作，可能导致程序出现未响应的情况。所以这是一个很糟糕的解决方法，问题的解决思路应该是将网络操作移到非主线程进行，而不是这种掩耳盗铃的做法。
<code>java
StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();
StrictMode.setThreadPolicy(policy);
</code>
p.s. 这个很笨的方法居然在Stackoverflow上有很多人认为有用，难以理解。</p>

<h2>AsyncTask也不好</h2>

<p>先实现一个我们用来测试的请求网络的方法
```java
private void doGetRequest() {</p>

<pre><code>    HttpGet method = new HttpGet("http://droidyue.com");
    AbstractHttpClient http = new DefaultHttpClient();
    try {
        HttpResponse response = http.execute(method);
        Log.i(LOGTAG, "doGetRequest responseCode=" + response.getStatusLine().getStatusCode() + "; ThreadInfo=" + Thread.currentThread());
    } catch (ClientProtocolException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>```
使用AsyncTask可以将网络操作移到了AsyncTask的线程，可以避免NetworkOnMainThreadException异常。</p>

<p>```java
new AsyncTask&lt;Void, Integer, Void>() {</p>

<pre><code>@Override
protected Void doInBackground(Void... params) {
    doGetRequest();
    return null;
}
</code></pre>

<p>}.execute();
```</p>

<h3>AsyncTask的弊端</h3>

<ul>
<li>上述AsyncTask为一个匿名内部类的对象,由于Java中非static内部类实例会持有外部类实例的引用,AsyncTask实例持有Activity的引用,这样很容易引起内存泄露</li>
<li>按照Android官方文档支出,AsyncTask被推荐为处理短时间(10秒以内)的操作,即本地的轻量IO操作.不适合使用网络这样时间不定的操作.</li>
</ul>


<p>更详细的关于AsyncTask请参考<a href="http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android/">Android中糟糕的AsyncTask</a></p>

<h2>这样也不好</h2>

<p>既然AsyncTask可能导致内存泄露并且不适用于长时间操作,那么这样呢
```java
new Thread() {</p>

<pre><code>@Override
public void run() {
    super.run();
    doGetRequest();
}
</code></pre>

<p>}.start();
```
这样还是不够好,虽然单独线程可以处理长时间的操作,但是问题还是依旧</p>

<ul>
<li>内存泄露问题依旧可能存在</li>
<li>如果多次重复进行这样的操作,每次重新创建新的Thread不好.</li>
</ul>


<h2>解决上述两处内部类可能引起的内存泄露问题</h2>

<ul>
<li>将AsyncTask或者Thread的子类作为单独的文件,不持有Activity的强引用</li>
<li>将AsyncTask或者Thread的子类使用static修饰,则不会隐式持有Activity的强引用</li>
<li>如果是匿名内部类，则需要将其对象设置成成员属性，使用static修饰就不会隐式持有Activity的强引用。</li>
</ul>


<h2>解决问题哪家强</h2>

<p>解决了上述的内存泄露基本可以做到比较完美的实现,或者使用Loaders实现也不错。关于线程重用问题，可以使用Executors.newSingleThreadExecutor()来解决。具体方案因情况而定。</p>
]]></content>
  </entry>
  
</feed>
