<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2015-11-15T22:28:37+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[详解 Android 中的 HandlerThread]]></title>
    <link href="http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/"/>
    <updated>2015-11-08T22:50:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread</id>
    <content type="html"><![CDATA[<p>HandlerThread是Android API提供的一个便捷的类，使用它我们可以快速的创建一个带有Looper的线程，有了Looper这个线程，我们又可以生成Handler，那么HandlerThread是什么，可以做什么呢，有哪些奇技淫巧可以被我们利用呢？</p>

<!--more-->


<h2>实现原理</h2>

<p>在介绍原理之前，我们先使用普通的Thread来创建一个Handler，创建的过程大致如下：
```java
Handler mHandler;
private void createManualThreadWithHandler() {</p>

<pre><code>new Thread() {
    @Override
    public void run() {
        super.run();
        Looper.prepare();
        mHandler = new Handler(Looper.myLooper());
        Looper.loop();
    }
}.start();
</code></pre>

<p>}
```
实现很简单，在目标线程内如下配置</p>

<ul>
<li>调用Looper.prepare 创建与当前线程绑定的Looper实例</li>
<li>使用上面创建的Looper生成Handler实例</li>
<li>调用Looper.loop()实现消息循环</li>
</ul>


<p>明白上面的实现步骤，HandlerThread的实现也就简单了，其实现为：
```java
@Override
public void run() {</p>

<pre><code>mTid = Process.myTid();
Looper.prepare();
synchronized (this) {
    mLooper = Looper.myLooper();
    notifyAll();
}
Process.setThreadPriority(mPriority);
onLooperPrepared();
Looper.loop();
mTid = -1;
</code></pre>

<p>}
```
确实很简单，无需赘述。</p>

<h2>Handler原理</h2>

<p>要理解Handler的原理，理解如下几个概念即可茅塞顿开。</p>

<ul>
<li>Message 意为消息，发送到Handler进行处理的对象，携带描述信息和任意数据。</li>
<li>MessageQueue 意为消息队列，Message的集合。</li>
<li>Looper 有着一个很难听的中文名字，消息泵，用来从MessageQueue中抽取Message，发送给Handler进行处理。</li>
<li>Handler 处理Looper抽取出来的Message。</li>
</ul>


<h2>如何使用</h2>

<p>HandlerThread使用起来很容易，首先需要进行初始化。
```java
private Handler mHandler;
private LightTaskManager() {</p>

<pre><code>HandlerThread workerThread = new HandlerThread("LightTaskThread");
workerThread.start();
mHandler = new Handler(workerThread.getLooper());
</code></pre>

<p>}
<code>``
注意：上面的</code>workerThread.start();`必须要执行。</p>

<p>至于如何使用HandlerThread来执行任务，主要是调用Handler的API</p>

<ul>
<li>使用post方法提交任务，postAtFrontOfQueue将任务加入到队列前端，postAtTime指定时间提交任务，postDelayed延后提交任务。</li>
<li>使用sendMessage方法可以发送消息，sendMessageAtFrontOfQueue将该消息放入消息队列前端，sendMessageAtTime 指定时间发送消息，sendMessageDelayed延后提交消息。</li>
</ul>


<p>通过包裹Handler API，我们可以实现如下代码(仅post相关方法):
```java
public void post(Runnable run) {</p>

<pre><code>mHandler.post(run);
</code></pre>

<p>}</p>

<p>public void postAtFrontOfQueue(Runnable runnable) {</p>

<pre><code>mHandler.postAtFrontOfQueue(runnable);
</code></pre>

<p>}</p>

<p>public void postDelayed(Runnable runnable, long delay) {</p>

<pre><code>mHandler.postDelayed(runnable, delay);
</code></pre>

<p>}</p>

<p>public void postAtTime(Runnable runnable, long time) {</p>

<pre><code>mHandler.postAtTime(runnable, time);
</code></pre>

<p>}
```</p>

<h2>控制优先级</h2>

<p>了解到如何使用之外，关于HandlerThread的使用需要上升一个界别，那就是优化。这里的优化主要是合理调整HandlerThread的优先级。</p>

<p>HandlerThread的默认优先级是<code>Process.THREAD_PRIORITY_DEFAULT</code>,具体值为0。线程的优先级的取值范围为-20到19。优先级高的获得的CPU资源更多，反之则越少。-20代表优先级最高，19最低。0位于中间位置，但是作为工作线程的HandlerThread没有必要设置这么高的优先级，因而需要我们降低其优先级。</p>

<h3>可控制的优先级</h3>

<ul>
<li>THREAD_PRIORITY_DEFAULT，默认的线程优先级，值为0。</li>
<li>THREAD_PRIORITY_LOWEST，最低的线程级别，值为19。</li>
<li>THREAD_PRIORITY_BACKGROUND 后台线程建议设置这个优先级，值为10。</li>
<li>THREAD_PRIORITY_MORE_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微优先，值为-1。</li>
<li>THREAD_PRIORITY_LESS_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微落后一些，值为1。</li>
</ul>


<p>以上的这些优先级都是可以在程序中设置的，除此之外还有不可控的优先级均有系统进行自动调整。</p>

<h3>如何修改权限</h3>

<p>最通用的就是在run方法中，加入合理的设置优先级代码，比如
```
Runnable run = new Runnable() {</p>

<pre><code>@Override
public void run() {
    android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
</code></pre>

<p>};
LightTaskManager.getInstance().post(run);
```
上述方法不仅适用于HandlerThread，也可以适用于其他的线程。</p>

<p>除此之外，HandlerThread的构造方法也提供了设置优先级的功能。用法如下：
<code>java
HandlerThread workerThread = new HandlerThread("LightTaskThread", Process.THREAD_PRIORITY_BACKGROUND);
</code></p>

<p>关于设置优先级，系统的AsyncTask已经开始进行了默认设置，将线程的优先级设置成THREAD_PRIORITY_BACKGROUND了。
```java
public AsyncTask() {</p>

<pre><code>mWorker = new WorkerRunnable&lt;Params, Result&gt;() {
    public Result call() throws Exception {
        mTaskInvoked.set(true);

        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
        //noinspection unchecked
        Result result = doInBackground(mParams);
        Binder.flushPendingCommands();
        return postResult(result);
    }
};
</code></pre>

<p>}
```</p>

<p>关于Android中线程的调度详情，请参考<a href="">剖析Android中进程与线程调度之nice</a></p>

<h2>应用场景</h2>

<p>我们可以使用HandlerThread处理本地IO读写操作（数据库，文件），因为本地IO操作大多数的耗时属于毫秒级别，对于单线程 + 异步队列的形式 不会产生较大的阻塞。因此在这个HandlerThread中不适合加入网络IO操作。</p>

<p>对于本地IO读取操作，我们可以使用postAtFrontOfQueue方法，快速将读取操作加入队列前端执行，必要时返回给主线程更新UI。示例场景，从数据库中读取数据展现在ListView中。注意读取也是需要花费一定时间，推荐在数据展示之前有必要的用户可感知进度提示。</p>

<p>对于本地IO写操作，根据具体情况，选择post或者postDelayed方法执行。比如SharedPreference commit，或者文件写入操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Android Log的一些思考]]></title>
    <link href="http://droidyue.com/blog/2015/11/01/thinking-about-android-log/"/>
    <updated>2015-11-01T17:09:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/11/01/thinking-about-android-log</id>
    <content type="html"><![CDATA[<p>在日常的Android开发中，日志打印是一项必不可少的操作，我们通过分析打印的日志可以分析程序的运行数据和情况。然而使用日志打印的正确姿势又是怎样呢，如何屏蔽日志信息输出呢，本文将逐一进行回答。</p>

<!--more-->


<h2>哪些形式</h2>

<h3>System.out.println</h3>

<p>这是标准的Java输出方法，相信很多公司都不提倡使用，这里进行列举，目的是为了提醒大家不用。</p>

<h3>Android Log</h3>

<p>Android自身提供了一个日志工具类，那就是android.util.Log。使用很简单，如下
<code>java
Log.i(LOGTAG, "onCreate");
</code></p>

<h2>TAG选取</h2>

<h3>选用人名</h3>

<p>关于TAG的选取，很多人都曾采用人名的形式，比如
<code>
Log.i("andy", "onCreate");
</code>
这样做的目标一是为了过滤方便，当一个人在写一个模块多个文件时，使用这个形式，过滤起来很容易帮助理解程序的执行情况。另外的目的就是为了表明日志周围代码的作者姓甚名谁。</p>

<p>然而，我却不推荐这种人名作为TAG的形式。原因如下</p>

<ul>
<li>以人名作为关键字过滤，不易确定产生日志的类文件</li>
<li>随着某个人模块实现的增加，过滤人名易产生来自其他模块的干扰信息。</li>
</ul>


<h3>动态选取</h3>

<p>还有一种选取LOGTAG的方式，就是
<code>
private static final String LOGTAG = DroidSettings.class.getSimpleName();
</code>
这样使用，得到的LOGTAG的值就是DroidSettings，然而并非如此，当DroidSettings这个类进行了混淆之后，类名变成了类似a,b,c这样的名称，LOGTAG则不再是DroidSettings这个值了。这样可能造成的问题就是，内部混淆有日志的包，我们去过滤DroidSettings 却永远得不到任何信息。</p>

<h3>推荐的记录形式</h3>

<p>推荐的形式就是以字符串字面量形式去设置LOGTAG。如下，在DroidSettings类中
<code>java
private static final String LOGTAG = "DroidSettings";
</code></p>

<h3>优雅打印日志的姿势</h3>

<p>什么才是打印日志的优雅姿势是，我认为一条好的日志需要包含以下三点</p>

<ul>
<li>这条日志所在的类，我们通过LOGTAG可以表示</li>
<li>这条日志所在的方法，需要加入方法名的字符串</li>
<li>必要的其他信息，比如参数或者局部变量。</li>
</ul>


<p>结合三点，下面是一个符合规则的简单示例
```java
private String  getBookName(int bookId) {</p>

<pre><code>String bookName = mBooks.get(bookId);
DroidLog.i(LOGTAG, "getBookName bookId=" + bookId + ";bookName=" + bookName);
return bookName;
</code></pre>

<p>}
```
上面的代码，包含了所在类（LOGTAG），方法名(getBookName)， 参数(bookId)，局部变量(bookName)。必要的信息都展示了出来，对于了解程序运行很有帮助。</p>

<h2>屏蔽日志输出</h2>

<p>在Android中进行屏蔽日志，有两种实现形式，一种是在编译期屏蔽，另一种则是从运行时进行屏蔽，后者相对比较常见，从后向前介绍。</p>

<h3>运行时屏蔽</h3>

<p>在运行时屏蔽日志，通常的做法是创建一个自定义的类，比如叫做DroidLog
```java
public class DroidLog {</p>

<pre><code>private static final boolean ENABLE_LOG = true;


public static void i(String tag, String message) {
    if (ENABLE_LOG) {
        android.util.Log.i(tag, message);
    }
}
</code></pre>

<p>}
```
在编码时，我们调用DroidLog.i方法来记录日志，然后在打包时，修改ENABLE_LOG的值为false，这样就能屏蔽了日志输出。</p>

<p>然后运行时屏蔽的方案实际上有一点小问题，比如
```java
private void dumpDebugInfo() {</p>

<pre><code>DroidLog.i(LOGTAG, "sdkVersion=" + Build.VERSION.SDK_INT + "; Locale=" + Locale.getDefault());
</code></pre>

<p>}
<code>``
虽然上面的日志不会打印，但是</code>&ldquo;sdkVersion=&rdquo; + Build.VERSION.SDK_INT + &ldquo;; Locale=&rdquo; + Locale.getDefault()`这段字符串拼接语句却实实在在执行了。总的来说，还是会产生一些影响。</p>

<p>关于字符串拼接的细节，可以阅读<a href="http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/">Java细节：字符串的拼接</a></p>

<h2>编译期屏蔽</h2>

<p>既然运行时屏蔽存在问题，那么是否可以提前到编译期进行屏蔽呢，答案是肯定的。这里我们就使用了Proguard的一个小功能。</p>

<p>assumenosideeffects从英文单词上去理解，意思为 假设没有副作用。该功能属于优化的一种方式，该功能常常用来处理日志打印，比如我们想要屏蔽掉来自DroidLog的日志打印。
在混淆的配置文件中，加入下列代码</p>

<p>```
-assumenosideeffects class com.droidyue.logdemo.DroidLog {</p>

<pre><code>    public static *** i(...);
</code></pre>

<p>}
```</p>

<p>然而仅仅处理DroidLog是不够的，因为我们无法保证团队其他成员是否使用了原生的android.utils.Log来进行日志打印（尽管有编码约束）</p>

<p>```
-assumenosideeffects class android.util.Log {</p>

<pre><code>    public static *** d(...);
    public static *** e(...);
    public static *** i(...);
    public static *** v(...);
    public static *** println(...);
    public static *** w(...);
    public static *** wtf(...);
</code></pre>

<p>}
```</p>

<p>一般写到这里，基本可以结束，但是我们还需要探究一下，编译期屏蔽是否和运行时屏蔽一样有着同样的问题呢？ 我们接下来证明<br/>
首先，我们选用这段代码作为例子
```java
public class MainActivity extends Activity {</p>

<pre><code>private static final String LOGTAG = "MainActivity" ;
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    dumpDebugInfo();
}

private void dumpDebugInfo() {
    Locale defaultLocale = Locale.getDefault();
    DroidLog.i(LOGTAG, "sdkVersion=" + Build.VERSION.SDK_INT + "; Locale=" + defaultLocale);
}
</code></pre>

<p>}
<code>
然后修改混淆文件proguard-project.txt，启用混淆处理。
</code>
-assumenosideeffects class android.util.Log {</p>

<pre><code>public static *** d(...);
public static *** i(...);
public static *** v(...);
</code></pre>

<p>}</p>

<p>-assumenosideeffects class com.droidyue.logdemo.DroidLog {</p>

<pre><code>    public static *** i(...);
</code></pre>

<p>}
```</p>

<p>然后使用Eclipse的导出功能，生成指定签名的APK包，运行必然没有日志输出。</p>

<p>接下来对生成的APK包进行反编译，得到的smali文件。查看MainActivity.smali。</p>

<p>注意：Proguard进行优化，发生了内联操作，讲dumpDebugInfo的方法体实现提取到onCreate方法中。</p>

<p>onCreate方法体中没有任何关于<code>DroidLog.i</code>方法的调用，但是<code>"sdkVersion=" + Build.VERSION.SDK_INT + "; Locale=" + defaultLocale</code>对应的字符串拼接操作依然存在。
```</p>

<h1>virtual methods</h1>

<p>.method protected onCreate(Landroid/os/Bundle;)V</p>

<pre><code>.locals 3

invoke-super {p0, p1}, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V

const v0, 0x7f030017

invoke-virtual {p0, v0}, Lcom/droidyue/logdemo/MainActivity;-&gt;setContentView(I)V

invoke-static {}, Ljava/util/Locale;-&gt;getDefault()Ljava/util/Locale;

move-result-object v0

new-instance v1, Ljava/lang/StringBuilder;

const-string v2, "sdkVersion="

invoke-direct {v1, v2}, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;(Ljava/lang/String;)V

sget v2, Landroid/os/Build$VERSION;-&gt;SDK_INT:I

invoke-virtual {v1, v2}, Ljava/lang/StringBuilder;-&gt;append(I)Ljava/lang/StringBuilder;

move-result-object v1

const-string v2, "; Locale="

invoke-virtual {v1, v2}, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder;

move-result-object v1

invoke-virtual {v1, v0}, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/Object;)Ljava/lang/StringBuilder;

move-result-object v0

invoke-virtual {v0}, Ljava/lang/StringBuilder;-&gt;toString()Ljava/lang/String;

return-void
</code></pre>

<p>.end method
```
因此，无论是运行时日志屏蔽还是编译期，message参数上发生的字符串拼接都依然存在。但是编译期屏蔽减少了方法调用（即方法进出栈操作），理论上编译期屏蔽日志更优。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能调优利器StrictMode]]></title>
    <link href="http://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode/"/>
    <updated>2015-09-26T20:50:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode</id>
    <content type="html"><![CDATA[<p>作为Android开发，日常的开发工作中或多或少要接触到性能问题，比如我的Android程序运行缓慢卡顿，并且常常出现ANR对话框等等问题。既然有性能问题，就需要进行性能优化。正所谓工欲善其事，必先利其器。一个好的工具，可以帮助我们发现并定位问题，进而有的放矢进行解决。本文主要介绍StrictMode 在Android 应用开发中的应用和一些问题。</p>

<!--more-->


<h2>什么是StrictMode</h2>

<p>StrictMode意思为严格模式，是用来检测程序中违例情况的开发者工具。最常用的场景就是检测主线程中本地磁盘和网络读写等耗时的操作。</p>

<h3>严在哪里</h3>

<p>既然叫做严格模式，那么又严格在哪些地方呢？<br/>
在Android中，主线程，也就是UI线程，除了负责处理UI相关的操作外，还可以执行文件读取或者数据库读写操作（从Android 4.0 开始，网络操作禁止在主线程中执行，否则会抛出<a href="http://droidyue.com/blog/2014/11/08/look-into-android-dot-os-dot-networkonmainthreadexception/">NetworkOnMainThreadException</a>）。使用严格模式，系统检测出主线程违例的情况会做出相应的反应，如日志打印，弹出对话框亦或者崩溃等。换言之，严格模式会将应用的违例细节暴露给开发者方便优化与改善。</p>

<h3>具体能检测什么</h3>

<p>严格模式主要检测两大问题，一个是线程策略，即TreadPolicy，另一个是VM策略，即VmPolicy。</p>

<h3>ThreadPolicy</h3>

<p>线程策略检测的内容有</p>

<ul>
<li>自定义的耗时调用 使用<strong>detectCustomSlowCalls()</strong>开启</li>
<li>磁盘读取操作 使用<strong>detectDiskReads()</strong>开启</li>
<li>磁盘写入操作 使用<strong>detectDiskWrites()</strong>开启</li>
<li>网络操作  使用<strong>detectNetwork()</strong>开启</li>
</ul>


<h3>VmPolicy</h3>

<p>虚拟机策略检测的内容有</p>

<ul>
<li>Activity泄露 使用<strong>detectActivityLeaks()</strong>开启</li>
<li>未关闭的Closable对象泄露  使用<strong>detectLeakedClosableObjects()</strong>开启</li>
<li>泄露的Sqlite对象  使用<strong>detectLeakedSqlLiteObjects()</strong>开启</li>
<li>检测实例数量 使用<strong>setClassInstanceLimit()</strong>开启</li>
</ul>


<h2>工作原理</h2>

<p>其实StrictMode实现原理也比较简单，以IO操作为例，主要是通过在open，read，write，close时进行监控。<code>libcore.io.BlockGuardOs</code>文件就是监控的地方。以open为例，如下进行监控。</p>

<p>```java
@Override
public FileDescriptor open(String path, int flags, int mode) throws ErrnoException {</p>

<pre><code>BlockGuard.getThreadPolicy().onReadFromDisk();
if ((mode &amp; O_ACCMODE) != O_RDONLY) {
    BlockGuard.getThreadPolicy().onWriteToDisk();
}
return os.open(path, flags, mode);
</code></pre>

<p>}
<code>
其中**onReadFromDisk()**方法的实现，代码位于StrictMode.java中。
</code>
public void onReadFromDisk() {</p>

<pre><code>if ((mPolicyMask &amp; DETECT_DISK_READ) == 0) {
    return;
}
if (tooManyViolationsThisLoop()) {
    return;
}
BlockGuard.BlockGuardPolicyException e = new StrictModeDiskReadViolation(mPolicyMask);
e.fillInStackTrace();
startHandlingViolationException(e);
</code></pre>

<p>}
```</p>

<h2>如何使用</h2>

<p>关于StrictMode如何使用，最重要的就是如何启用严格模式。</p>

<h3>放在哪里</h3>

<p>严格模式的开启可以放在Application或者Activity以及其他组件的onCreate方法。为了更好地分析应用中的问题，建议放在Application的onCreate方法中。</p>

<h3>简单启用</h3>

<p>以下的代码启用全部的ThreadPolicy和VmPolicy违例检测
```java
if (IS_DEBUG &amp;&amp; Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {</p>

<pre><code>StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectAll().penaltyLog().build());
StrictMode.setVmPolicy(new VmPolicy.Builder().detectAll().penaltyLog().build());
</code></pre>

<p>}
```
严格模式需要在debug模式开启，不要在release版本中启用。</p>

<p>同时，严格模式自API 9 开始引入，某些API方法也从 API 11 引入。使用时应该注意 API 级别。</p>

<p>如有需要，也可以开启部分的严格模式。</p>

<h3>查看结果</h3>

<p>严格模式有很多种报告违例的形式，但是想要分析具体违例情况，还是需要查看日志，终端下过滤StrictMode就能得到违例的具体stacktrace信息。
<code>bash
adb logcat | grep StrictMode
</code></p>

<h2>解决违例</h2>

<ul>
<li>如果是主线程中出现文件读写违例，建议使用工作线程（必要时结合Handler）完成。</li>
<li>如果是对SharedPreferences写入操作，在API 9 以上 建议优先调用apply而非commit。</li>
<li>如果是存在未关闭的Closable对象，根据对应的stacktrace进行关闭。</li>
<li>如果是SQLite对象泄露，根据对应的stacktrace进行释放。</li>
</ul>


<p>举个例子</p>

<p>以主线程中的文件写入为例，引起违例警告的代码
```java
public void writeToExternalStorage() {</p>

<pre><code>File externalStorage = Environment.getExternalStorageDirectory();
File destFile = new File(externalStorage, "dest.txt");
try {
    OutputStream output = new FileOutputStream(destFile, true);
    output.write("droidyue.com".getBytes());
    output.flush();
    output.close();
} catch (FileNotFoundException e) {
    e.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
}
</code></pre>

<p>}
<code>
引起的警告为
</code>bash
D/StrictMode( 9730): StrictMode policy violation; ~duration=20 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=31 violation=2
D/StrictMode( 9730):    at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1176)
D/StrictMode( 9730):    at libcore.io.BlockGuardOs.open(BlockGuardOs.java:106)
D/StrictMode( 9730):    at libcore.io.IoBridge.open(IoBridge.java:390)
D/StrictMode( 9730):    at java.io.FileOutputStream.<init>(FileOutputStream.java:88)
D/StrictMode( 9730):    at com.example.strictmodedemo.MainActivity.writeToExternalStorage(MainActivity.java:56)
D/StrictMode( 9730):    at com.example.strictmodedemo.MainActivity.onCreate(MainActivity.java:30)
D/StrictMode( 9730):    at android.app.Activity.performCreate(Activity.java:4543)
<code>
因为上述属于主线程中的IO违例，解决方法就是讲写入操作放入工作线程。
</code>
public void writeToExternalStorage() {</p>

<pre><code>new Thread() {
    @Override
    public void run() {
        super.run();
        File externalStorage = Environment.getExternalStorageDirectory();
        File destFile = new File(externalStorage, "dest.txt");
        try {
            OutputStream output = new FileOutputStream(destFile, true);
            output.write("droidyue.com".getBytes());
            output.flush();
            output.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}.start();
</code></pre>

<p>}
<code>
然而这并非完善，因为OutputStream.write方法可能抛出IOException，导致存在OutputStream对象未关闭的情况，仍然需要改进避免出现Closable对象未关闭的违例。改进如下
</code>java
public void writeToExternalStorage() {</p>

<pre><code>new Thread() {
    @Override
    public void run() {
        super.run();
        File externalStorage = Environment.getExternalStorageDirectory();
        File destFile = new File(externalStorage, "dest.txt");
        OutputStream output = null;
        try {
            output = new FileOutputStream(destFile, true);
            output.write("droidyue.com".getBytes());
            output.flush();
            output.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (null != output) {
                try {
                    output.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}.start();
</code></pre>

<p>}
```</p>

<h2>检测内存泄露</h2>

<p>通常情况下，检测内存泄露，我们需要使用MAT对heap dump 文件进行分析，这种操作不困难，但也不容易。使用严格模式，只需要过滤日志就能发现内存泄露。</p>

<p>这里以Activity为例说明，首先我们需要开启对检测Activity泄露的违例检测。使用上面的detectAll或者detectActivityLeaks()均可。其次写一段能够产生Activity泄露的代码。
```
public class LeakyActivity extends Activity{</p>

<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    MyApplication.sLeakyActivities.add(this);
}
</code></pre>

<p>}
<code>
MyApplication中关于sLeakyActivities的部分实现
</code>java
public class MyApplication extends Application {</p>

<pre><code>public static final boolean IS_DEBUG = true;
public static ArrayList&lt;Activity&gt; sLeakyActivities = new ArrayList&lt;Activity&gt;();
</code></pre>

<p>}
```</p>

<p>当我们反复进入LeakyActivity再退出，过滤StrictMode就会得到这样的日志
<code>bash
E/StrictMode( 2622): class com.example.strictmodedemo.LeakyActivity; instances=2; limit=1
E/StrictMode( 2622): android.os.StrictMode$InstanceCountViolation: class com.example.strictmodedemo.LeakyActivity; instances=2; limit=1
E/StrictMode( 2622):    at android.os.StrictMode.setClassInstanceLimit(StrictMode.java:1)
</code>
分析日志，LeakyActivity本应该是只存在一份实例，但现在出现了2个，说明LeakyActivity发生了内存泄露。</p>

<p>严格模式除了可以检测Activity的内存泄露之外，还能自定义检测类的实例泄露。从API 11 开始，系统提供的这个方法可以实现我们的需求。
<code>
public StrictMode.VmPolicy.Builder setClassInstanceLimit (Class klass, int instanceLimit)
</code>
举个栗子，比如一个浏览器中只允许存在一个SearchBox实例，我们就可以这样设置已检测SearchBox实例的泄露
<code>
StrictMode.setVmPolicy(new VmPolicy.Builder().setClassInstanceLimit(SearchBox.class, 1).penaltyLog().build());
</code></p>

<h2>noteSlowCall</h2>

<p>StrictMode从 API 11开始允许开发者自定义一些耗时调用违例，这种自定义适用于自定义的任务执行类中，比如我们有一个进行任务处理的类，为TaskExecutor。
```
public class TaskExecutor {</p>

<pre><code>public void execute(Runnable task) {
    task.run();
}
</code></pre>

<p>}
<code>
先需要跟踪每个任务的耗时情况，如果大于500毫秒需要提示给开发者，noteSlowCall就可以实现这个功能，如下修改代码
</code>java
public class TaskExecutor {</p>

<pre><code>private static long SLOW_CALL_THRESHOLD = 500;
public void executeTask(Runnable task) {
    long startTime = SystemClock.uptimeMillis();
    task.run();
    long cost = SystemClock.uptimeMillis() - startTime;
    if (cost &gt; SLOW_CALL_THRESHOLD) {
        StrictMode.noteSlowCall("slowCall cost=" + cost);
    }
}
</code></pre>

<p>}
<code>
执行一个耗时2000毫秒的任务
</code>bash
TaskExecutor executor = new TaskExecutor();
executor.executeTask(new Runnable() {</p>

<pre><code>@Override
public void run() {
    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>});
<code>
得到的违例日志，注意其中`~duration=20 ms`并非耗时任务的执行时间，而我们的自定义信息`msg=slowCall cost=2000`才包含了真正的耗时。
</code>bash
D/StrictMode(23890): StrictMode policy violation; ~duration=20 ms: android.os.StrictMode$StrictModeCustomViolation: policy=31 violation=8 msg=slowCall cost=2000
D/StrictMode(23890):    at android.os.StrictMode$AndroidBlockGuardPolicy.onCustomSlowCall(StrictMode.java:1163)
D/StrictMode(23890):    at android.os.StrictMode.noteSlowCall(StrictMode.java:1974)
D/StrictMode(23890):    at com.example.strictmodedemo.TaskExecutor.executeTask(TaskExecutor.java:17)
D/StrictMode(23890):    at com.example.strictmodedemo.MainActivity.onCreate(MainActivity.java:36)
D/StrictMode(23890):    at android.app.Activity.performCreate(Activity.java:4543)
D/StrictMode(23890):    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1071)
D/StrictMode(23890):    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2158)
D/StrictMode(23890):    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2237)
D/StrictMode(23890):    at android.app.ActivityThread.access$600(ActivityThread.java:139)
D/StrictMode(23890):    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1262)
D/StrictMode(23890):    at android.os.Handler.dispatchMessage(Handler.java:99)
D/StrictMode(23890):    at android.os.Looper.loop(Looper.java:156)
D/StrictMode(23890):    at android.app.ActivityThread.main(ActivityThread.java:5005)
D/StrictMode(23890):    at java.lang.reflect.Method.invokeNative(Native Method)
D/StrictMode(23890):    at java.lang.reflect.Method.invoke(Method.java:511)
D/StrictMode(23890):    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:784)
D/StrictMode(23890):    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:551)
D/StrictMode(23890):    at dalvik.system.NativeStart.main(Native Method)
```</p>

<h2>其他技巧</h2>

<p>除了通过日志查看之外，我们也可以在开发者选项中开启严格模式，开启之后，如果主线程中有执行时间长的操作，屏幕则会闪烁，这是一个更加直接的方法。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/strictmode_developer_tools.png">http://7jpolu.com1.z0.glb.clouddn.com/strictmode_developer_tools.png</a>"></p>

<h2>问题来了</h2>

<h3>日志的时间靠谱么</h3>

<p>在下面的过滤日志中，我们看到下面的一个IO操作要消耗31毫秒，这是真的么<br/>
<code>bash
D/StrictMode( 2921): StrictMode policy violation; ~duration=31 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=31 violation=2
D/StrictMode( 2921):    at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1176)
D/StrictMode( 2921):    at libcore.io.BlockGuardOs.read(BlockGuardOs.java:148)
D/StrictMode( 2921):    at libcore.io.IoBridge.read(IoBridge.java:422)
D/StrictMode( 2921):    at java.io.FileInputStream.read(FileInputStream.java:179)
D/StrictMode( 2921):    at java.io.InputStreamReader.read(InputStreamReader.java:244)
D/StrictMode( 2921):    at java.io.BufferedReader.fillBuf(BufferedReader.java:130)
D/StrictMode( 2921):    at java.io.BufferedReader.readLine(BufferedReader.java:354)
D/StrictMode( 2921):    at com.example.strictmodedemo.MainActivity.testReadContentOfFile(MainActivity.java:65)
D/StrictMode( 2921):    at com.example.strictmodedemo.MainActivity.onCreate(MainActivity.java:28)
D/StrictMode( 2921):    at android.app.Activity.performCreate(Activity.java:4543)
</code></p>

<p>从上面的stacktrace可以看出testReadContentOfFile方法中包含了文件读取IO操作，至于是否为31毫秒，我们可以利用秒表的原理计算一下，即在方法调用的地方如下记录
<code>java
long startTime = System.currentTimeMillis();
testReadContentOfFile();
long cost = System.currentTimeMillis() - startTime;
Log.d(LOGTAG, "cost = " + cost);
</code>
得到的日志中上述操作耗时9毫秒，非31毫秒。
<code>bash
D/MainActivity(20996): cost = 9
</code>
注：通常情况下StrictMode给出的耗时相对实际情况偏高，并不是真正的耗时数据。</p>

<h2>注意</h2>

<ul>
<li>在线上环境即Release版本不建议开启严格模式。</li>
<li>严格模式无法监控JNI中的磁盘IO和网络请求。</li>
<li>应用中并非需要解决全部的违例情况，比如有些IO操作必须在主线程中进行。</li>
</ul>


<p><script type="text/javascript" src="http://droidyue.b0.upaiyun.com/js/blog/book_copyright.js"></script>
<script type="text/javascript">
	showBookCopyright();
</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android进程线程调度之cgroups]]></title>
    <link href="http://droidyue.com/blog/2015/09/17/android-process-and-thread-schedule-cgroups/"/>
    <updated>2015-09-17T21:17:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/09/17/android-process-and-thread-schedule-cgroups</id>
    <content type="html"><![CDATA[<p>做Android开发的同学们，了解cgroups的同学其实不多，cgroups是什么意思呢，在操作系统中有着什么样的作用，以及Android中的cgroups有哪些，各有什么用呢，本文将会进行逐一剖析。</p>

<!--more-->


<h2>先看定义</h2>

<p>下面的引用为维基百科的<a href="https://zh.wikipedia.org/wiki/Cgroups">cgroups的定义</a></p>

<blockquote><p>cgroups，其名称源自控制组群（control groups）的简写，是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。</p></blockquote>

<p>维基百科的解释言简意赅，无需赘述，下面以例子讲解如何使用cgroups。</p>

<h2>结合示例</h2>

<p>以下会以Fedora这个Linux发行版为例，介绍如何使用cgroups限制进程的CPU使用率。</p>

<p>这里我们使用一个死循环的Python脚本用来消耗CPU，文件名为loop.py，。
```python</p>

<h1>!/usr/bin/env python</h1>

<h1>coding=utf-8</h1>

<p>i = 0
while True:</p>

<pre><code>i = i + 1
</code></pre>

<p>```</p>

<p>执行脚本<code>python loop.py</code>，使用top查看该进程的CPU使用情况,CPU使用率接近100%。
<img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/cpu_cost_no_limit.png">http://7jpolu.com1.z0.glb.clouddn.com/cpu_cost_no_limit.png</a>"></p>

<p>然后我们将会通过修改配置，利用cgroups将该进程的CPU使用率降低到10%</p>

<p>首先查看当前系统的cgroups
<code>bash
16:31:57-androidyue/tmp$ sudo mount -t cgroup
[sudo] password for androidyue:
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)
cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)
cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)
</code></p>

<p>然后创建一个cgroup,控制CPU使用率。
<code>bash
cd /sys/fs/cgroup/cpu
sudo mkdir cpu_test
</code></p>

<p>接下来查看刚刚创建的cpu_test
<code>bash
17:04:54-androidyue/sys/fs/cgroup/cpu$ ls cpu_test/
cgroup.clone_children  cgroup.procs  cpuacct.usage         cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  notify_on_release
cgroup.event_control   cpuacct.stat  cpuacct.usage_percpu  cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat    tasks
</code></p>

<p>完成这一目标修改涉及到的文件有</p>

<p>cpu.cfs_period_us
设置该cgroup请求到CPU资源分配的周期，单位为微秒（这里使用us代替微秒单位µs）。</p>

<p>cpu.cfs_quota_us
设置cgroup组内的进程在一次CPU分配周期（即cpu.cfs_period_us指定的值）内可以执行的时间。</p>

<p>如果我们想要设置该cpu_test组内的cpu使用率为10%，我们需要这样修改
<code>
echo 1000000 &gt; cpu.cfs_period_us
echo 100000 &gt; cpu.cfs_quota_us
</code>
注意上述修改需要使用root身份登陆，即<code>sudo -i</code>,下面的将进程加入cgroup同样需要root身份。</p>

<p>将上图中的进程ID 写入到cpu_test下的tasks文件中，并查看tasks验证是否加入成功
<code>bash
17:12:27-root/sys/fs/cgroup/cpu/cpu_test$ sudo echo 12093 &gt; tasks
17:12:41-root/sys/fs/cgroup/cpu/cpu_test$ cat tasks
12093
</code></p>

<p>再次查看进程id为12093的CPU使用率，已成功降低到10%左右。
<img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/cpu_cost_with_limit.png">http://7jpolu.com1.z0.glb.clouddn.com/cpu_cost_with_limit.png</a>"></p>

<h2>cgroups在Android中的应用</h2>

<p>在Android中也存在cgroups，涉及到CPU的目前只有两个，一个是apps，路径为<code>/dev/cpuctl/apps</code>。另一个是bg_non_interactive，路径为<code>/dev/cpuctl/apps/bg_non_interactive</code></p>

<h3>cpu.share</h3>

<p>cpu.share文件中保存了整数值，用来设置cgroup分组任务获得CPU时间的相对值。举例来说，cgroup A和cgroup B的cpu.share值都是1024，那么cgroup A 与cgroup B中的任务分配到的CPU时间相同，如果cgroup C的cpu.share为512，那么cgroup C中的任务获得的CPU时间是A或B的一半。</p>

<p>apps下的cpu.share 值为1024
<code>bash
root@htc_m8tl:/dev/cpuctl/apps # cat cpu.shares
1024
</code>
bg_non_interactive下的cpu_share值为52
<code>bash
root@htc_m8tl:/dev/cpuctl/apps/bg_non_interactive # cat cpu.shares
52
</code>
也就是说apps分组与bg_non_interactive分组cpu.share值相比接近于20:1。由于Android中只有这两个cgroup，也就是说apps分组中的应用可以利用95%的CPU，而处于bg_non_interactive分组中的应用则只能获得5%的CPU利用率。</p>

<h2>cpu.rt_period_us与cpu.rt_runtime_us</h2>

<p>cpu.rt_period_us用来设置cgroup获得CPU资源的周期，单位为微秒。
cpu.rt_runtime_us用来设置cgroup中的任务可以最长获得CPU资源的时间，单位为微秒。设定这个值可以访问某个cgroup独占CPU资源。最长的获取CPU资源时间取决于逻辑CPU的数量。比如cpu.rt_runtime_us设置为200000（0.2秒），cpu.rt_period_us设置为1000000（1秒）。在单个逻辑CPU上的获得时间为每秒为0.2秒。 2个逻辑CPU，获得的时间则是0.4秒。</p>

<p>apps分组下的两个配置的值
<code>bash
root@htc_m8tl:/dev/cpuctl/apps # cat cpu.rt_period_us
1000000
root@htc_m8tl:/dev/cpuctl/apps # cat cpu.rt_runtime_us
800000
</code>
即单个逻辑CPU下每一秒内可以获得0.8秒的执行时间。</p>

<p>bg_non_interactive分组下的两个配置的值
<code>bash
root@htc_m8tl:/dev/cpuctl/apps/bg_non_interactive # cat cpu.rt_period_us
1000000
root@htc_m8tl:/dev/cpuctl/apps/bg_non_interactive # cat cpu.rt_runtime_us
700000
</code>
即单个逻辑CPU下每一秒可以获得0.7秒的执行时间。</p>

<h3>花落谁家</h3>

<p>在Android中，一个应用（进程）既可以由apps切换到bg_non_interactive，也可以切换回来。</p>

<h4>Activity</h4>

<p>当一个Activity处于可见的状态下，那么这个应用进程就属于apps分组。</p>

<h4>Service</h4>

<p>当Service调用startForeground方法后，那么这个应用进程则是归类于apps分组
<code>java
Notification.Builder  builder = new Notification.Builder(this);
builder.setContentTitle("Title");
Notification notification = builder.build();
startForeground(notification.hashCode(), notification);
</code></p>

<h3>如何确定进程的cgroups</h3>

<p>其实确定过程也很简单，总共分三步。</p>

<p>第一步，进入已经root的Android设备终端
<code>
11:10 $ adb shell
root@htc_m8tl:/ # su
root@htc_m8tl:/ #
</code></p>

<p>第二步，目标应用的进程id，这里以我们的demo程序（包名为com.droidyue.androidthreadschedule）为例。得到的进程id为22871
<code>
root@htc_m8tl:/ # ps | grep com.droidyue
u0_a1434  22871 23723 970040 54304 ffffffff 400a045c S com.droidyue.androidthreadschedule
</code></p>

<p>第三步，利用进程id查看其所在的cgroups
<code>
2|root@htc_m8tl:/ # cat  /proc/22871/cgroup
3:cpu:/apps
2:memory:/
1:cpuacct:/uid/11434
</code></p>

<p>通过以上三步，<del>我们就能把大象关冰箱里</del>,我们就能得到进程所在的cgroups分组。</p>

<h2>利用cgroups我们可以做什么</h2>

<p>其实对于一般应用来说，能做的事情少之又少。对于有需要的应用可以使用Service.startForeground方法来获取更多的CPU资源，但并不建议盲目去这样做，还是要根据自身应用需要实现。</p>

<p>另外，个人认为最大的收获，就是我们可以参照cgroups的分组的思想来设计有类似场景的方案解决实际问题。</p>

<h3>同系列文章</h3>

<ul>
<li><a href="/blog/2015/09/05/android-process-and-thread-schedule-nice/?droid_refer=series">剖析Android中进程与线程调度之nice</a></li>
</ul>


<p><script type="text/javascript" src="http://droidyue.b0.upaiyun.com/js/blog/book_copyright.js"></script>
<script type="text/javascript">
	showBookCopyright();
</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剖析Android中进程与线程调度之nice]]></title>
    <link href="http://droidyue.com/blog/2015/09/05/android-process-and-thread-schedule-nice/"/>
    <updated>2015-09-05T11:35:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/09/05/android-process-and-thread-schedule-nice</id>
    <content type="html"><![CDATA[<p>在计算机操作系统中，进程是进行资源分配和调度的基本单位，同时每个进程之内也可以存在多个线程。那么在Android系统（Linux Kernel）中，进程是如何去抢占资源，线程又是如何根据优先级切换呢，本文将尝试剖析这个问题，研究nice在Linux以及Android系统中的应用。</p>

<!--more-->


<h2>一些概念</h2>

<ul>
<li>进程 是计算机系统中，程序运行的实体，也是线程的容器。</li>
<li>线程 是进程中实际执行单位，一个线程是程序执行流的最小单元。在一个进程中可以有多个线程存在。</li>
</ul>


<h2>nice与进程调度</h2>

<p>Linux中，使用nice value（以下成为nice值）来设定一个进程的优先级，系统任务调度器根据nice值合理安排调度。</p>

<ul>
<li>nice的取值范围为-20到19。</li>
<li>通常情况下，nice的默认值为0。视具体操作系统而定。</li>
<li>nice的值越大，进程的优先级就越低，获得CPU调用的机会越少，nice值越小，进程的优先级则越高，获得CPU调用的机会越多。</li>
<li>一个nice值为-20的进程优先级最高，nice值为19的进程优先级最低。</li>
<li>父进程fork出来的子进程nice值与父进程相同。父进程renice，子进程nice值不会随之改变。</li>
</ul>


<h3>词源考究</h3>

<p>nice这个命令的来源几乎没有资料提到，于是便尝试自己来推断一下。在诸如词霸，沪江等词典给出的意思均为<code>好的；美好的；可爱的；好心的，友好的</code>。而有道词典则稍微给出了一个其他词典没有的<code>和蔼的</code>。个人认为有道给出的这个比较合理。要想做到和蔼，就需要做到谦让，因此或多或少牺牲自己一点，成全他人。所以nice值越高，越和蔼，但是自己的优先级也会越低。</p>

<h3>renice</h3>

<p>对于一个新的进程我们可以按照下面的代码为一个进程设定nice值。
<code>bash
nice -n 10 adb logcat
</code>
对于已经创建的进程，我们可以使用renice来修改nice值
<code>
sudo renice -n 0 -p 24161
</code>
该命令需要使用root权限，-p对应的值为进程id。</p>

<p>注意renice命令在Linux发行版中-n 的值应该为进程的目标优先级。而Mac下-n，则是代表对当前权限的增加值。
比如在Mac下，讲一个进程的nice值由19改成10，可以这样操作<code>sudo renice -n -9  -p 24161</code>,这一点需要注意，避免掉进坑里。</p>

<h3>Android中的nice</h3>

<p>由于Android基于Linux Kernel，在Android中也存在nice值。但是一般情况下我们无法控制，原因如下：</p>

<ul>
<li>Android系统并不像其他Linux发行版那样便捷地使用nice命令操作。</li>
<li>renice需要root权限，一般应用无法实现。</li>
</ul>


<h2>线程调度</h2>

<p>虽然对于进程的优先级，我们无法控制，但是我们可以控制进程中的线程的优先级。在Android中有两种线程的优先级，一种为Android API版本，另一种是 Java 原生版本。</p>

<h3>Android API</h3>

<p>Android中的线程优先级别目前规定了如下，了解了进程优先级与nice值的关系，那么线程优先级与值之间的关系也就更加容易理解。</p>

<ul>
<li>THREAD_PRIORITY_DEFAULT，默认的线程优先级，值为0。</li>
<li>THREAD_PRIORITY_LOWEST，最低的线程级别，值为19。</li>
<li>THREAD_PRIORITY_BACKGROUND 后台线程建议设置这个优先级，值为10。</li>
<li>THREAD_PRIORITY_FOREGROUND 用户正在交互的UI线程，代码中无法设置该优先级，系统会按照情况调整到该优先级，值为-2。</li>
<li>THREAD_PRIORITY_DISPLAY 也是与UI交互相关的优先级界别，但是要比THREAD_PRIORITY_FOREGROUND优先，代码中无法设置，由系统按照情况调整，值为-4。</li>
<li>THREAD_PRIORITY_URGENT_DISPLAY 显示线程的最高级别，用来处理绘制画面和检索输入事件，代码中无法设置成该优先级。值为-8。</li>
<li>THREAD_PRIORITY_AUDIO 声音线程的标准级别，代码中无法设置为该优先级，值为 -16。</li>
<li>THREAD_PRIORITY_URGENT_AUDIO 声音线程的最高级别，优先程度较THREAD_PRIORITY_AUDIO要高。代码中无法设置为该优先级。值为-19。</li>
<li>THREAD_PRIORITY_MORE_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微优先，值为-1。</li>
<li>THREAD_PRIORITY_LESS_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微落后一些，值为1。</li>
</ul>


<p>使用Android API为线程设置优先级也很简单，只需要在线程执行时调用android.os.Process.setThreadPriority方法即可。这种在线程运行时进行修改优先级，效果类似renice。
```
new Thread () {</p>

<pre><code>@Override
public void run() {
    super.run();
    android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
</code></pre>

<p>}.start();
```</p>

<h3>Java原生API</h3>

<p>Java为Thread提供了三个级别的设置，</p>

<ul>
<li>MAX_PRIORITY，相当于android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY，值为10。</li>
<li>MIN_PRIORITY，相当于android.os.Process.THREAD_PRIORITY_LOWEST，值为0。</li>
<li>NORM_PRIORITY，相当于android.os.Process.THREAD_PRIORITY_DEFAULT，值为5。</li>
</ul>


<p>使用setPriority我们可以为某个线程设置优先级，使用getPriority可以获得某个线程的优先级。</p>

<p>在Android系统中，不建议使用Java原生的API，因为Android提供的API划分的级别更多，更适合在Android系统中进行设定细致的优先级。</p>

<h2>注意</h2>

<p>Android API的线程优先级和Java原生API的优先级是相对独立的，比如使用android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)后，使用Java原生API,Thread.getPriority()得到的值不会改变。如下面代码：
```
new Thread() {</p>

<pre><code>@Override
public void run() {
    super.run();
    Log.i(LOGTAG, "Java Thread Priority Before=" + Thread.currentThread().getPriority());
    Process.setThreadPriority(Process.THREAD_PRIORITY_LOWEST);
    Log.i(LOGTAG, "Java Thread Priority=" + Thread.currentThread().getPriority());
}
</code></pre>

<p>}.start();
<code>
上述代码的运行日志为
</code>
I/MainActivity( 3679): Java Thread Priority Before=5
I/MainActivity( 3679): Java Thread Priority=5
```</p>

<p>由于上面的这一点缺陷，导致我们在分析ANR trace时需要注意，在下面的ANR日志信息中，<code>prio=5</code>中proi的值对应的Java原生API的线程优先级。而<code>nice=-6</code>中的nice表示的Android API版本的线程优先级。</p>

<p><code>
"main" prio=5 tid=1 NATIVE
  | group="main" sCount=1 dsCount=0 obj=0x41690f18 self=0x4167e650
  | sysTid=1765 nice=-6 sched=0/0 cgrp=apps handle=1074196888
  | state=S schedstat=( 0 0 0 ) utm=5764 stm=3654 core=2
  #00  pc 00022624  /system/lib/libc.so (__futex_syscall3+8)
  #01  pc 0000f054  /system/lib/libc.so (__pthread_cond_timedwait_relative+48)
  #02  pc 0000f0b4  /system/lib/libc.so (__pthread_cond_timedwait+64)
</code></p>

<h2>避免ANR</h2>

<p>我在之前的文章<a href="http://droidyue.com/blog/2015/07/18/anr-in-android/">说说Android中的ANR</a>中提到使用WorkerThread处理耗时IO操作，同时将WorkerThread的优先级降低，对于耗时IO操作，比如读取数据库，文件等，我们可以设置该workerThread优先级为THREAD_PRIORITY_BACKGROUND，以此降低与主线程竞争的能力。</p>

<h3>同系列文章</h3>

<ul>
<li><a href="/blog/2015/09/17/android-process-and-thread-schedule-cgroups/?droid_refer=series">剖析Android中进程与线程调度之cgroups</a></li>
</ul>


<p><script type="text/javascript" src="http://droidyue.b0.upaiyun.com/js/blog/book_copyright.js"></script>
<script type="text/javascript">
	showBookCopyright();
</script>
</p>
]]></content>
  </entry>
  
</feed>
