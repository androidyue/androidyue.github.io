<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2014-11-23T22:13:25+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android中WebView拦截替换网络请求数据]]></title>
    <link href="http://droidyue.com/blog/2014/11/23/block-web-resource-in-webview/"/>
    <updated>2014-11-23T21:54:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/23/block-web-resource-in-webview</id>
    <content type="html"><![CDATA[<p>Android中处理网页时我们必然用到WebView,这里我们有这样一个需求，我们想让WebView在处理网络请求的时候将某些请求拦截替换成某些特殊的资源。具体一点儿说，在WebView加载 <code>http://m.sogou.com</code> 时，会加载一个logo图片，我们的需求就是将这个logo图片换成另一张图片。</p>

<!--more-->


<h3>shouldInterceptRequest</h3>

<p>好在Android中的WebView比较强大，从API 11(Android 3.0)开始， shouldInterceptRequest被引入就是为了解决这一类的问题。</p>

<p>shouldInterceptRequest这个回调可以通知主程序WebView处理的资源（css,js,image等）请求，并允许主程序进行处理后返回数据。如果主程序返回的数据为null，WebView会自行请求网络加载资源，否则使用主程序提供的数据。注意这个回调发生在非UI线程中,所以进行UI系统相关的操作是不可以的。</p>

<p>shouldInterceptRequest有两种重载。</p>

<ul>
<li><strong>public WebResourceResponse shouldInterceptRequest (WebView view, String url)</strong> 从API 11开始引入，API 21弃用</li>
<li><strong>public WebResourceResponse shouldInterceptRequest (WebView view, WebResourceRequest request)</strong> 从API 21开始引入</li>
</ul>


<p>本次例子暂时使用第一种，即shouldInterceptRequest (WebView view, String url)。</p>

<h3>示例代码</h3>

<p>```java
WebView webView = new WebView(this);
webView.setWebViewClient(new WebViewClient() {</p>

<pre><code>@Override
public WebResourceResponse shouldInterceptRequest(WebView view, String url) {
    Log.i(LOGTAG, "shouldInterceptRequest url=" + url + ";threadInfo" + Thread.currentThread());
    WebResourceResponse response = null;
    if (url.contains("logo")) {
        try {
            InputStream localCopy = getAssets().open("droidyue.png");
            response = new WebResourceResponse("image/png", "UTF-8", localCopy);
        } catch (IOException e) {
            e.printStackTrace();
        }       
    }
    return response;
}   
</code></pre>

<p>});
setContentView(webView);
webView.loadUrl(&ldquo;<a href="http://m.sogou.com">http://m.sogou.com</a>&rdquo;);
```
其中WebResourceResponse需要设定三个属性，MIME类型，数据编码，数据(InputStream流形式)。</p>

<h3>示例下载</h3>

<ul>
<li><a href="http://pan.baidu.com/s/1ntOaHoH">百度云盘</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[点击网页链接调用Android程序]]></title>
    <link href="http://droidyue.com/blog/2014/11/23/start-android-application-when-click-a-link/"/>
    <updated>2014-11-23T15:58:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/23/start-android-application-when-click-a-link</id>
    <content type="html"><![CDATA[<p>最近前端同事问了我一个问题，如何让网页链接实现启动Android的应用，网上有说重写WebView相关的shouldOverrideUrlLoading方法，但是这种理论上能实现，因为你的网页不是仅仅被你自己的webview来浏览，你需要做的是让市面上的浏览器支持才行。</p>

<p>这里利用零碎的时间整理一下。主要涉及到的问题就是关于Intent在字符串形式和Intent对象之间的转换。如果你是一位前端工程师，请让你的Anroid开发小伙伴来看这篇文章，一同解决问题。</p>

<!--more-->


<h2>两种表现形式</h2>

<p>Intent是Android开发中常见的API。在处理Android组件中，有着必不可少的作用。Intent可以以两种方式存在。</p>

<ul>
<li>Intent对象。用于在程序中处理，在处理Android组件时使用。</li>
<li>字符串形式的URI。 用于在非程序代码中，如网页中进行使用等。</li>
</ul>


<p>而这里我们解决我们上面问题的就是后者，字符串形式的Intent。</p>

<h2>Intent对象转成字符串URI</h2>

<p>Intent提供了两种将对象转换成字符串URI，一个是推荐的<code>public String toUri (int flags)</code>，
在API 4加入，将Intent对象转换成字符串形式的URI。字符串形式的URI可以包含Intent的data,action,categories, type, flags, package, component和extras。
<code>java
Intent intent = new Intent();
ComponentName comp = new ComponentName("com.mx.app.mxhaha", "com.mx.app.MxMainActivity");
intent.setComponent(comp);
Log.i(LOGTAG, "intent.uri=" + intent.toUri(Intent.URI_INTENT_SCHEME));
</code>
生成的字符串URI为
<code>
intent:#Intent;component=com.mx.app.mxhaha/com.mx.app.MxMainActivity;end
</code></p>

<p>另一个方法是<code>public String toURI ()</code>，
这是一个弃用的方法，因为它生成的字符串以<strong>#</strong>开头，<strong>放在链接上会被当成锚点</strong>。不建议使用使用这个方法。</p>

<p>上面的Intent对象使用toUri转换成
```</p>

<h1>Intent;component=com.mx.app.mxhaha/com.mx.app.MxMainActivity;end</h1>

<p>```</p>

<h2>字符串URI转成Intent对象</h2>

<h3>getIntent(String uri)</h3>

<p>这个方法只适用于处理以#开头的URI，而且在其方法内部实际上是调用的<code>parseUri(uri, 0)</code>来实现的。这个方法已经被比较为弃用，不推荐使用。</p>

<h3>getIntentOld(String uri)</h3>

<p>getIntentOld既可以支持#开头的URI转换成Intent对象，如果uri不是Intent的字符串形式，那么也会返回一个Intent，只是其data部分为uri，action为android.intent.action.VIEW。</p>

<h3>parseUri(String uri, int flags)</h3>

<p>这个是最完整的转换方法。接收uri和flag作为参数。支持将字符串形式的URI转成Intent对象.</p>

<p>以下为一个既可以解析<strong>intent:</strong>开头的URI也可以解析<strong>#Intent</strong>开头的URI的方法。
```java
public static Intent parseIntent(String url) {</p>

<pre><code>Intent intent = null;
// Parse intent URI into Intent Object
int flags = 0;
boolean isIntentUri = false;
if (url.startsWith("intent:")) {
    isIntentUri = true;
    flags = Intent.URI_INTENT_SCHEME;
} else if (url.startsWith("#Intent;")) {
    isIntentUri = true;
}
if (isIntentUri) {
    try {
        intent = Intent.parseUri(url, flags);
    } catch (URISyntaxException e) {
        e.printStackTrace();
    }
}
return intent;
</code></pre>

<p>}
```</p>

<h2>多说一下</h2>

<p>对于Intent字符串形式URI在网页链接中的应用，不同的浏览器实现程度不一致。目前<a href="http://www.maxthon.cn/">傲游浏览器Android版</a>由我已经完全实现这一功能。希望其他的浏览器也可以实现一下这个功能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[译文：理解Android中垃圾回收日志信息]]></title>
    <link href="http://droidyue.com/blog/2014/11/08/understanding-garbage-collection-output-messages-in-android/"/>
    <updated>2014-11-08T18:16:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/08/understanding-garbage-collection-output-messages-in-android</id>
    <content type="html"><![CDATA[<p>如果你是一名Android开发者并且常常看程序日志的话，那么下面的这些信息对你来说可能一点都不陌生。
<code>java
GC_CONCURRENT freed 178K, 41% free 3673K/6151K, external 0K/0K, paused 2ms+2ms
GC_EXPLICIT freed 6K, 41% free 3667K/6151K, external 0K/0K, paused 29ms
GC_CONCURRENT freed 379K, 42% free 3856K/6535K, external 0K/0K, paused 2ms+3ms
GC_EXPLICIT freed 144K, 41% free 3898K/6535K, external 0K/0K, paused 32ms
GC_CONCURRENT freed 334K, 40% free 4091K/6727K, external 0K/0K, paused 2ms+3ms
</code></p>

<p>但是这些到底是什么，又有什么含义呢？</p>

<!--more-->


<p>上面的这几行就是Android系统垃圾回收的部分输出信息。每当垃圾回收被触发的时候，你就可以通过logcat查看到这样的信息。这样短短的一行的日志有着很大的信息量。比如通过日志我们可以发现程序可能有内存（泄露）问题。本文将具体介绍这些日志信息的每一部分的含义来帮助帮助大家更好地了解垃圾回收的运行情况。</p>

<h2>原因</h2>

<p><font color="red">GC_CONCURRENT</font> freed 178K, 41% free 3673K/6151K, external 0K/0K, paused 2ms+2ms <br/>
<font color="red">GC_EXPLICIT</font> freed 6K, 41% free 3667K/6151K, external 0K/0K, paused 29ms</p>

<p>红颜色标出的部分就是垃圾回收触发的原因。在Android中有五种类型的垃圾回收触发原因。</p>

<ul>
<li><strong>GC_CONCURRENT</strong> 当堆内存增长到一定程度时会触发。此时触发可以对堆中的没有用的对象及时进行回收，腾出空间供新的对象申请，避免进行不必要的增大堆内存的操作。</li>
<li><strong>GC_EXPLICIT</strong>   当程序中调用System.gc()方法触发。这个方法应避免出现在程序中调用。因为JVM有足够的能力来控制垃圾回收。</li>
<li><strong>GC_EXTERNAL_MALLOC</strong> 当Bitmap和NIO Direct ByteBuffer对象分配外部存储（机器内存，非Dalvik堆内存）触发。这个日志只有在2.3之前存在，从2.3系统开始，垃圾回收进行了调整，前面的对象都会存储到Dalivik堆内存中。所以在2.3系统之后，你就再也不会看到这种信息了。</li>
<li><strong>GC_FOR_MALLOC</strong> 当堆内存已满，系统需要更多内存的时候触发。这条日志出现后意味着JVM要暂停你的程序进行垃圾回收操作。</li>
<li><strong>GC_HPROF_DUMP_HEAP</strong> 当创建一个内存分析文件HPROF时触发。</li>
</ul>


<h2>结果</h2>

<p>GC_CONCURRENT <font color="red">freed 178K</font>, 41% free 3673K/6151K, external 0K/0K, paused 2ms+2ms <br/>
GC_EXPLICIT <font color="red">freed 6K</font>, 41% free 3667K/6151K, external 0K/0K, paused 29ms</p>

<p>这部分数据告诉我们JVM进行垃圾回收释放了多少空间。</p>

<h2>堆内存数据</h2>

<p>GC_CONCURRENT freed 178K, <font color="red">41% free 3673K/6151K</font>, external 0K/0K, paused 2ms+2ms <br/>
GC_EXPLICIT freed 6K, <font color="red">41% free 3667K/6151K</font>, external 0K/0K, paused 29ms</p>

<p>这部分告诉我们堆内存中可用内存占的比例，当前活跃的对象总的空间，以及当前堆的总大小。所以这里的数据就是41%的堆内存可用，已经使用了3673K，总的堆内存大小为6151K。</p>

<h2>外部存储数据</h2>

<p>GC_EXTERNAL_ALLOC freed 1125K, 47% free 6310K/11847K,  <font color="red">external 1051K/1103K</font>, paused 46ms<br/>
GC_EXTERNAL_ALLOC freed 295K, 47% free 6335K/11847K,  <font color="red">external 1613K/1651K</font>, paused 41ms</p>

<p>这部分数据告诉我们外部存储（位于机器内存）对象的数据。在2.3之前，bitmap对象存放在机器内存。因此在第一条数据中我们可以看到以有1051K使用，外部存储为1103K。</p>

<p>上面两行数据相差100毫秒，我们可以看到第一条数据表明外部存储快满了，由于GC_EXTERNAL_ALLOC被触发，外部存储空间扩大到了1651K。</p>

<h2>垃圾回收暂停时间</h2>

<p>GC_CONCURRENT freed 178K, 41% free 3673K/6151K, external 0K/0K, <font color="red">paused 2ms+2ms</font> <br/>
GC_EXPLICIT freed 6K, 41% free 3667K/6151K, external 0K/0K, <font color="red">paused 29ms</font></p>

<p>这部分数据表明垃圾回收消耗的时间。在GC_CONCURRENT回收时，你会发现两个暂停时间。一个是在回收开始的暂停时间，另一个时在回收结束的暂停时间。GC_CONCURRENT从2.3开始引入，相比之前的程序全部暂停的垃圾回收机制，它的暂停时间要小的多。一般少于5毫秒。因为GC_CONCURRENT的绝大多数操作在一个单独的线程中进行。</p>

<p>本文中内容摘自 Google I/O 2011: Memory management for Android Apps，如果感兴趣，请访问<a href="http://droidyue.com/blog/2014/11/02/note-for-google-io-memory-management-for-android-chinese-edition/">这里</a>了解更多。</p>

<h2>原文地址</h2>

<p><a href="https://sites.google.com/site/pyximanew/blog/androidunderstandingddmslogcatmemoryoutputmessages">https://sites.google.com/site/pyximanew/blog/androidunderstandingddmslogcatmemoryoutputmessages</a></p>

<h2>其他</h2>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B009VV6EG8/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009VV6EG8&linkCode=as2&tag=droidyue-23">Android应用性能优化</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009VV6EG8" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[啰嗦一下android中的NetworkOnMainThreadException]]></title>
    <link href="http://droidyue.com/blog/2014/11/08/look-into-android-dot-os-dot-networkonmainthreadexception/"/>
    <updated>2014-11-08T15:26:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/08/look-into-android-dot-os-dot-networkonmainthreadexception</id>
    <content type="html"><![CDATA[<p>相信很多Android开发者很多都遇到过android.os.NetworkOnMainThreadException 这个异常，意思就是主线程进行网络操作异常。这个问题比较简单，但是网络上有着鱼龙混杂的答案，这里想花点时间做一个比较完整的描述。</p>

<!--more-->


<h2>严格模式</h2>

<p>在早期的Android版本（2.3之前）中，Google并没有提供一个很严格的程序编写要求，所以在那时我们可以在主线程中执行本地IO操作，网络操作等这些不规范的行为。后来在2.3的姜饼（GINGERBREAD）开始提供了一个开发者工具，这就是StrictMode严格模式。</p>

<p>严格模式可以帮助开发者发现主线程中的磁盘操作和网络操作，开发者根据严格模式的输出信息可以改善程序来更好地响应用户操作，来较少ANR（程序未响应）的问题。</p>

<p>android.os.NetworkOnMainThreadException这个异常从Android 3.0（API 11）引入，出现情况为主线程进行网络操作。</p>

<h3>代码开启StrictMode</h3>

<p>```java
if (Build.VERSION.SDK_INT >= VERSION_CODES.GINGERBREAD) {</p>

<pre><code>ThreadPolicy.Builder threadPolicyBuilder = new StrictMode.ThreadPolicy.Builder();
threadPolicyBuilder.detectDiskReads().detectDiskWrites().detectNetwork().penaltyLog();
StrictMode.setThreadPolicy(threadPolicyBuilder.build());
VmPolicy.Builder vmPolicyBuilder = new VmPolicy.Builder();
vmPolicyBuilder.detectLeakedSqlLiteObjects().penaltyLog();
if (Build.VERSION.SDK_INT &gt;= VERSION_CODES.HONEYCOMB) {
    vmPolicyBuilder.detectLeakedClosableObjects();
}
StrictMode.setVmPolicy(vmPolicyBuilder.build());
</code></pre>

<p>}
```</p>

<h3>特别注意</h3>

<ul>
<li>严格模式不应该在发布版本时开启</li>
</ul>


<h2>治标不治本的办法</h2>

<p>下面的这段代码会让严格模式允许所有的磁盘操作和网络操作。但是这并没有改变真正解决问题，主线程中照样还是有网络操作，可能导致程序出现未响应的情况。所以这是一个很糟糕的解决方法，问题的解决思路应该是将网络操作移到非主线程进行，而不是这种掩耳盗铃的做法。
<code>java
StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();
StrictMode.setThreadPolicy(policy);
</code>
p.s. 这个很笨的方法居然在Stackoverflow上有很多人认为有用，难以理解。</p>

<h2>AsyncTask也不好</h2>

<p>先实现一个我们用来测试的请求网络的方法
```java
private void doGetRequest() {</p>

<pre><code>    HttpGet method = new HttpGet("http://droidyue.com");
    AbstractHttpClient http = new DefaultHttpClient();
    try {
        HttpResponse response = http.execute(method);
        Log.i(LOGTAG, "doGetRequest responseCode=" + response.getStatusLine().getStatusCode() + "; ThreadInfo=" + Thread.currentThread());
    } catch (ClientProtocolException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>```
使用AsyncTask可以将网络操作移到了AsyncTask的线程，可以避免NetworkOnMainThreadException异常。</p>

<p>```java
new AsyncTask&lt;Void, Integer, Void>() {</p>

<pre><code>@Override
protected Void doInBackground(Void... params) {
    doGetRequest();
    return null;
}
</code></pre>

<p>}.execute();
```</p>

<h3>AsyncTask的弊端</h3>

<ul>
<li>上述AsyncTask为一个匿名内部类的对象,由于Java中非static内部类实例会持有外部类实例的引用,AsyncTask实例持有Activity的引用,这样很容易引起内存泄露</li>
<li>按照Android官方文档支出,AsyncTask被推荐为处理短时间(10秒以内)的操作,即本地的轻量IO操作.不适合使用网络这样时间不定的操作.</li>
</ul>


<p>更详细的关于AsyncTask请参考<a href="http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android/">Android中糟糕的AsyncTask</a></p>

<h2>这样也不好</h2>

<p>既然AsyncTask可能导致内存泄露并且不适用于长时间操作,那么这样呢
```java
new Thread() {</p>

<pre><code>@Override
public void run() {
    super.run();
    doGetRequest();
}
</code></pre>

<p>}.start();
```
这样还是不够好,虽然单独线程可以处理长时间的操作,但是问题还是依旧</p>

<ul>
<li>内存泄露问题依旧可能存在</li>
<li>如果多次重复进行这样的操作,每次重新创建新的Thread不好.</li>
</ul>


<h2>解决上述两处内部类可能引起的内存泄露问题</h2>

<ul>
<li>将AsyncTask或者Thread的子类作为单独的文件,不持有Activity的强引用</li>
<li>将AsyncTask或者Thread的子类使用static修饰,则不会隐式持有Activity的强引用</li>
<li>如果是匿名内部类，则需要将其对象设置成成员属性，使用static修饰就不会隐式持有Activity的强引用。</li>
</ul>


<h2>解决问题哪家强</h2>

<p>解决了上述的内存泄露基本可以做到比较完美的实现,或者使用Loaders实现也不错。关于线程重用问题，可以使用Executors.newSingleThreadExecutor()来解决。具体方案因情况而定。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[译文：Android中糟糕的AsyncTask]]></title>
    <link href="http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android/"/>
    <updated>2014-11-08T14:33:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android</id>
    <content type="html"><![CDATA[<p>AsyncTask是一个很常用的API，尤其异步处理数据并将数据应用到视图的操作场合。其实AsyncTask并不是那么好，甚至有些糟糕。本文我会讲AsyncTask会引起哪些问题，如何修复这些问题，并且关于AsyncTask的一些替代方案。</p>

<h2>AsyncTask</h2>

<p>从Android API 3（1.5 Cupcake）开始，AsyncTask被引入用来帮助开发者更简单地管理线程。实际上在Android 1.0和1.1也是有类似的实现，那就是UserTask。UserTask和AsyncTask有着相同的API及实现，但是由于由于1.0和1.1的设备份额微乎其微，这里的概念就不会涉及到UserTask。</p>

<!--more-->


<h2>生命周期</h2>

<p>关于AsyncTask存在一个这样广泛的误解，很多人认为一个在Activity中的AsyncTask会随着Activity的销毁而销毁。然后事实并非如此。AsyncTask会一直执行doInBackground()方法直到方法执行结束。一旦上述方法结束，会依据情况进行不同的操作。</p>

<ul>
<li>如果cancel(boolean)调用了，则执行onCancelled(Result)方法</li>
<li>如果cancel(boolean)没有调用，则执行onPostExecute(Result)方法</li>
</ul>


<p>AsyncTask的cancel方法需要一个布尔值的参数，参数名为mayInterruptIfRunning,意思是<code>如果正在执行是否可以打断</code>,如果这个值设置为true，表示这个任务可以被打断，否则，正在执行的程序会继续执行直到完成。如果在doInBackground()方法中有一个循环操作，我们应该在循环中使用isCancelled()来判断，如果返回为true，我们应该避免执行后续无用的循环操作。</p>

<p>总之，我们使用AsyncTask需要确保AsyncTask正确地取消。</p>

<h2>不好好工作的cancel()</h2>

<p>简而言之的答案，<strong>有时候起作用</strong>。</p>

<p>如果你调用了AsyncTask的cancel(false)，doInBackground()仍然会执行到方法结束，只是不会去调用onPostExecute()方法。但是实际上这是让应用程序执行了没有意义的操作。那么是不是我们调用cancel(true)前面的问题就能解决呢？并非如此。如果mayInterruptIfRunning设置为true，会使任务尽早结束，但是如果的doInBackground()有不可打断的方法会失效，比如这个BitmapFactory.decodeStream() IO操作。但是你可以提前关闭IO流并捕获这样操作抛出的异常。但是这样会使得cancel()方法没有任何意义。</p>

<h2>内存泄露</h2>

<p>还有一种常见的情况就是，在Activity中使用非静态匿名内部AsyncTask类，由于Java内部类的特点，AsyncTask内部类会持有外部类的隐式引用。详细请参考<a href="http://droidyue.com/blog/2014/10/02/the-private-modifier-in-java/">细话Java："失效"的private修饰符</a>,由于AsyncTask的生命周期可能比Activity的长，当Activity进行销毁AsyncTask还在执行时，由于AsyncTask持有Activity的引用，导致Activity对象无法回收，进而产生内存泄露。</p>

<h2>结果丢失</h2>

<p>另一个问题就是在屏幕旋转等造成Activity重新创建时AsyncTask数据丢失的问题。当Activity销毁并创新创建后，还在运行的AsyncTask会持有一个Activity的非法引用即之前的Activity实例。导致onPostExecute()没有任何作用。</p>

<h2>串行还是并行</h2>

<p>关于AsyncTask时串行还是并行有很多疑问，这很正常，因为它经过多次的修改。如果你并不明白什么时串行还是并行，可以通过接下来的例子了解，假设我们在一个方法体里面有如下两行代码
<code>java
new AsyncTask1().execute();
new AsyncTask2().execute();
</code>
上面的两个任务时同时执行呢，还是AsyncTask1执行结束之后，AsyncTask2才能执行呢？实际上是结果依据API不同而不同。</p>

<h3>在1.6(Donut)之前:</h3>

<p>在第一版的AsyncTask，任务是串行调度。一个任务执行完成另一个才能执行。由于串行执行任务，使用多个AsyncTask可能会带来有些问题。所以这并不是一个很好的处理异步（尤其是需要将结果作用于UI试图）操作的方法。</p>

<h3>从1.6到2.3(Gingerbread)</h3>

<p>后来Android团队决定让AsyncTask并行来解决1.6之前引起的问题，这个问题是解决了，新的问题又出现了。很多开发者实际上依赖于顺序执行的行为。于是很多并发的问题蜂拥而至。</p>

<h3>3.0（Honeycomb）到现在</h3>

<p>好吧，开发者可能并不喜欢让AsyncTask并行，于是Android团队又把AsyncTask改成了串行。当然这一次的修改并没有完全禁止AsyncTask并行。你可以通过设置executeOnExecutor(Executor)来实现多个AsyncTask并行。关于API文档的描述如下</p>

<blockquote><p>If we want to make sure we have control over the execution, whether it will run serially or parallel, we can check at runtime with this code to make sure it runs parallel:</p></blockquote>

<p>```java
public static void execute(AsyncTask as) {</p>

<pre><code>if (Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.HONEYCOMB_MR1) {
    as.execute();
} else {
    as.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
</code></pre>

<p>}
//(This code does not work for API lvl 1 to 3)
```</p>

<h2>真的需要AsyncTask么</h2>

<p>并非如此，使用AsyncTask虽然可以以简短的代码实现异步操作，但是正如本文提到的，你需要让AsyncTask正常工作的话，需要注意很多条条框框。推荐的一种进行异步操作的技术就是使用Loaders。这个方法从Android 3.0 (Honeycomb)开始引入，在android支持包中也有包含。可以通过查看官方的文档来详细了解<a href="http://developer.android.com/guide/components/loaders.html">Loaders</a>。</p>

<p>本次译文对原文有少部分删减修改处理。</p>

<h2>引用推荐</h2>

<ul>
<li><a href="http://bon-app-etit.blogspot.hk/2013/04/the-dark-side-of-asynctask.html">原文地址(墙外的 Orz)</a></li>
<li><a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.4.4_r1/android/os/AsyncTask.java#AsyncTask">Grepcode AsyncTsk 源码参考</a></li>
<li><a href="http://blog.danlew.net/2014/06/21/the-hidden-pitfalls-of-asynctask/">另一篇介绍AsyncTask陷阱的文章</a></li>
<li><a href="http://www.amazon.cn/gp/product/B009OLU8EE/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009OLU8EE&linkCode=as2&tag=droidyue-23">罗升阳的Android系统源代码情景分析</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009OLU8EE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
</feed>
