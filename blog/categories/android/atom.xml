<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2014-07-13T21:32:19+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[解密:Android设置默认程序]]></title>
    <link href="http://droidyue.com/blog/2014/07/13/set-preferred-application-in-android-chinese-edition/"/>
    <updated>2014-07-13T12:09:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/13/set-preferred-application-in-android-chinese-edition</id>
    <content type="html"><![CDATA[<p>Android作为一个伟大的系统,自然提供了设置默认打开程序的实现.在这篇文章中,我会介绍如何在Android系统中设置默认的程序. 在设置默认程序之前,无非有两种情况,一种是已经有默认的程序,另一种则是没有任何默认程序.</p>

<!--more-->


<h2>检测是否有默认的程序</h2>

<p>检查是必须的,因为结果关乎着我们下一步该怎么做.
```java</p>

<pre><code>public void testGetDefaultActivity() {
    PackageManager pm = mContext.getPackageManager();
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setData(Uri.parse("http://www.google.com"));
    ResolveInfo info = pm.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
    Log.i(VIEW_LOG_TAG, "getDefaultActivity info = " + info + ";pkgName = " + info.activityInfo.packageName);
</code></pre>

<p>}
<code>
其对应的日志输出如下
</code>java
I/View    ( 1145 ): View getDefaultActivity info = ResolveInfo{410e4868 com.android.internal.app.ResolverActivity p=0 o=0 m=0x0};pkgName = android
```
如果没有默认的程序,那么就会显示出默认的就会显示com.android.internal.app.ResolverActivity,那么这个ResolverActivity是什么呢,其实它就是一个选择打开程序的对话框,其庐山真面目应该是这样
<img class="<a" src="href="http://droidyueimg.qiniudn.com/resolveactivity.png">http://droidyueimg.qiniudn.com/resolveactivity.png</a>" title="Android ResolverActivity" ></p>

<p>如果我们设置了傲游浏览器作为我们的默认浏览器,那么默认的程序就应该显示关于傲游浏览器相关的信息. 如下.
<code>java
I/View    ( 1145 ): View getDefaultActivity info = ResolveInfo{410ae1e8 com.mx.browser.MxBrowserActivity p=0 o=0 m=0x208000};pkgName = com.mx.browser
</code>
那么如何判断是否设置了默认的程序呢,上面的方法默认的ResolveInfo,如果info.activityInfo.packageName为android,则没有设置,否则,有默认的程序.
```
public final boolean hasPreferredApplication(final Context context, final Intent intent) {</p>

<pre><code>PackageManager pm = context.getPackageManager();
ResolveInfo info = pm.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
return !"android".equals(info.activityInfo.packageName);
</code></pre>

<p>}
```</p>

<h2>如果有默认程序</h2>

<p>我们需要做的是将现在的默认的程序的默认设置清除.</p>

<p>我们能通过代码直接将默认设置改写成我们的么,实际上是不行的,因为权限的问题. 原因是这样的Android因为基于Linux 内核,Linux有着很棒的用户概念,而Android中每个应用就是一个在Linux内核中的用户.两个级别相同的用户无法删除对方.</p>

<p>所以,我们只能交给用户手动做.当然这也是绝大多数程序的做法.你需要做的就是将使用者带到程序详情页,通过这段代码可以跳转到应用详情页.
```java
public void testStartAppDetails() {</p>

<pre><code>//Use the destination package name
Intent intent = new Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS, Uri.parse("package:com.mx.browser"));
getActivity().startActivity(intent);
</code></pre>

<p>}
```
当跳转到已安装的应用详情页之后,你应该提示用处点击Clear Default 按钮.
<img src="/images/post_images/installed_app_details_clear_default.png"></p>

<p>如果用户从安装详情页回到你的程序,你需要检测是不是用户清理了默认的程序设置,判断依据还是是否有默认的程序设置,如果还有默认的,继续提示需要手动清理其他已设置的程序,直到用户彻底清理完成之后,然后按照下面的没有默认设置程序的情况处理.</p>

<p>注意,存在多次清理的情况,如设置浏览器,先清理了UC默认设置后,可能还需要清理海豚浏览器的情况.</p>

<h2>没有默认的程序.</h2>

<p>如果没有默认的程序,我们就需要设置我们希望的程序作为默认,但是,这页不能在代码中实现,还是需要人为的交互选择才可以.你需要做的就是使用类似如下代码,然后弹出一个提示,告诉用户选择你的程序作为默认的程序.至于提示语你可以充分发挥你的想象力.</p>

<p>```java
public void testStartChooseDialog() {</p>

<pre><code>Intent intent = new Intent();
intent.setAction("android.intent.action.VIEW");
intent.addCategory("android.intent.category.BROWSABLE");
intent.setData(Uri.parse("http://droidyue.com"));
intent.setComponent(new ComponentName("android","com.android.internal.app.ResolverActivity"));
getActivity().startActivity(intent);
</code></pre>

<p>}
```</p>

<h2>取消自己的默认程序设置</h2>

<p>```java
public void testClearDefault() {</p>

<pre><code>PackageManager pm = mContext.getPackageManager();
pm.clearPackagePreferredActivities(mContext.getPackageName());
</code></pre>

<p>}
```</p>

<p>上述方法只能清理自己的默认设置.</p>

<h2>更近一步</h2>

<p>实际上关于默认设置的配置文件存放在/data/system/packages.xml
<code>xml
&lt;preferred-activities&gt;
&lt;item name="com.mx.browser/.MxBrowserActivity" match="200000" set="2"&gt;
&lt;set name="com.android.browser/.BrowserActivity" /&gt;
&lt;set name="com.mx.browser/.MxBrowserActivity" /&gt;
&lt;filter&gt;
&lt;action name="android.intent.action.VIEW" /&gt;
&lt;cat name="android.intent.category.BROWSABLE" /&gt;
&lt;cat name="android.intent.category.DEFAULT" /&gt;
&lt;scheme name="http" /&gt;
&lt;/filter&gt;
&lt;/item&gt;
&lt;/preferred-activities&gt;
</code></p>

<h2>One More Thing</h2>

<ul>
<li>提问:当一个程序程序安装或卸载,系统会做什么</li>
<li><p>回答:当一个程序安装或者卸载,以浏览器为例子,如果你安装了一个傲游浏览器或者卸载了一个UC浏览器,当你从外部程序打开一个链接时,系统不会使用之前的默认程序打开,而是弹出一个选择对话框供你选择.</p></li>
<li><p>提问:什么时候系统会弹出选择打开程序列表</p></li>
<li>回答:经本人测试,实际是这样的,当有一个Intent过来的时候,系统会动态地收集能处理的Activity,然后从/data/system/packages.xml 读取进行比较,如果两者不同,则弹出选择对话框.</li>
</ul>


<h3>Others</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B009OLU8EE/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009OLU8EE&linkCode=as2&tag=droidyue-23">Android系统源代码情景分析</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009OLU8EE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[顶部带进度条的Webview]]></title>
    <link href="http://droidyue.com/blog/2014/07/12/ding-bu-dai-jin-du-tiao-de-webview/"/>
    <updated>2014-07-12T21:34:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/12/ding-bu-dai-jin-du-tiao-de-webview</id>
    <content type="html"><![CDATA[<p>写这篇文章,做份备忘,简单滴展示一个带进度条的Webview示例,进度条位于Webview上面.</p>

<p>示例图如下</p>

<!--more-->


<p><img class="<a" src="href="http://droidyueimg.qiniudn.com/webview_with_progressbar.png">http://droidyueimg.qiniudn.com/webview_with_progressbar.png</a>" title="webview_with_progressbar" ></p>

<h3>主Activity代码</h3>

<p>```java
package com.droidyue.demo.webviewprogressbar;
import android.app.Activity;
import android.os.Bundle;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.webkit.WebChromeClient;
import android.webkit.WebView;
import android.widget.ProgressBar;</p>

<p>import com.droidyue.demo.webviewprogressbar.R;</p>

<p>public class MainActivity extends Activity {</p>

<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    final ProgressBar bar = (ProgressBar)findViewById(R.id.myProgressBar);

    final WebView webView = (WebView)findViewById(R.id.myWebView);
    webView.setWebChromeClient(new WebChromeClient() {

        @Override
        public void onProgressChanged(WebView view, int newProgress) {
            if (newProgress == 100) {
                bar.setVisibility(View.INVISIBLE);
            } else {
                if (View.INVISIBLE == bar.getVisibility()) {
                    bar.setVisibility(View.VISIBLE);
                }
                bar.setProgress(newProgress);
            }
            super.onProgressChanged(view, newProgress);
        }

    });

    findViewById(R.id.myButton).setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View arg0) {
            webView.reload();
        }

    });
    final String url = "http://droidyue.com";
    webView.loadUrl(url);
}


@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
}
</code></pre>

<p>}</p>

<p>```</p>

<h3>布局文件代码</h3>

<p>```xml
&lt;RelativeLayout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:paddingBottom="@dimen/activity_vertical_margin"
android:paddingLeft="@dimen/activity_horizontal_margin"
android:paddingRight="@dimen/activity_horizontal_margin"
android:paddingTop="@dimen/activity_vertical_margin"
tools:context=".MainActivity" &gt;

&lt;Button 
    android:id="@+id/myButton"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Reload"
    /&gt;

&lt;ProgressBar 
    style="?android:attr/progressBarStyleHorizontal"
    android:id="@+id/myProgressBar"
    android:layout_below="@id/myButton"
    android:layout_width="match_parent"
    android:layout_height="5px"
    /&gt;
&lt;WebView 
    android:id="@+id/myWebView"
    android:layout_below="@id/myProgressBar"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    /&gt;
</code></pre>

<p></RelativeLayout></p>

<p><code>
不要忘记在Mainfest加入使用网络权限哟.
</code>xml
&lt;uses-permission android:name=&ldquo;android.permission.INTERNET&rdquo;/>
```</p>

<p>实现很简单,没什么技术含量.备忘而已.</p>

<p>关于如何自定义进度条请参考:<a href="http://winwyf.blog.51cto.com/4561999/857867" target="_blank"><a href="http://winwyf.blog.51cto.com/4561999/857867">http://winwyf.blog.51cto.com/4561999/857867</a></a></p>

<h3>Others</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00ASIN7G8/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00ASIN7G8&linkCode=as2&tag=droidyue-23">精通Android</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00ASIN7G8" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android扫描多媒体文件剖析]]></title>
    <link href="http://droidyue.com/blog/2014/07/12/scan-media-files-in-android-chinese-edition/"/>
    <updated>2014-07-12T19:59:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/12/scan-media-files-in-android-chinese-edition</id>
    <content type="html"><![CDATA[<p>这篇文章从系统源代码分析，讲述如何将程序创建的多媒体文件加入系统的媒体库，如何从媒体库删除，以及大多数程序开发者经常遇到的无法添加到媒体库的问题等。本人将通过对源代码的分析，一一解释这些问题。</p>

<!--more-->


<h2>Android中的多媒体文件扫描机制</h2>

<p>Android提供了一个很棒的程序来处理将多媒体文件加入的媒体库中。这个程序就是MediaProvider，现在我们简单看以下这个程序。首先看一下它的Receiver
```xml</p>

<pre><code>    &lt;receiver android:name="MediaScannerReceiver"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt;
        &lt;/intent-filter&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MEDIA_MOUNTED" /&gt;
            &lt;data android:scheme="file" /&gt;
        &lt;/intent-filter&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MEDIA_UNMOUNTED" /&gt;
            &lt;data android:scheme="file" /&gt;
        &lt;/intent-filter&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MEDIA_SCANNER_SCAN_FILE" /&gt;
            &lt;data android:scheme="file" /&gt;
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
</code></pre>

<p>```</p>

<p>MediaScannerReceiver只接收符合action和数据规则正确的intent。</p>

<h3>MediaScannerReciever如何处理Intent</h3>

<ul>
<li>当且仅当接收到<strong>action android.intent.action.BOOT_COMPLETED</strong>才扫描内部存储（非内置和外置sdcard）</li>
<li>除了action为<strong>android.intent.action.BOOT_COMPLETED</strong> 的以外的intent都必须要有数据传递。</li>
<li>当收到 <strong>Intent.ACTION_MEDIA_MOUNTED</strong> intent，扫描Sdcard</li>
<li>当收到 <strong>Intent.ACTION_MEDIA_SCANNER_SCAN_FILE</strong> intent，检测没有问题，将扫描单个文件。</li>
</ul>


<h3>MediaScannerService如何工作</h3>

<p>实际上MediaScannerReceiver并不是真正处理扫描工作，它会启动一个叫做MediaScannerService的服务。我们继续看MediaProvider的manifest中关于service的部分。
```xml</p>

<pre><code>   &lt;service android:name="MediaScannerService" android:exported="true"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.media.IMediaScannerService" /&gt;
        &lt;/intent-filter&gt;
    &lt;/service&gt;
</code></pre>

<p>```</p>

<h3>MediaScannerService中的scanFile方法</h3>

<p>```java</p>

<pre><code>private Uri scanFile(String path, String mimeType) {
    String volumeName = MediaProvider.EXTERNAL_VOLUME;
    openDatabase(volumeName);
    MediaScanner scanner = createMediaScanner();
    return scanner.scanSingleFile(path, volumeName, mimeType);
}
</code></pre>

<p>```</p>

<h3>MediaScannerService中的scan方法</h3>

<p>```java</p>

<pre><code>private void scan(String[] directories, String volumeName) {
    // don't sleep while scanning
    mWakeLock.acquire();

    ContentValues values = new ContentValues();
    values.put(MediaStore.MEDIA_SCANNER_VOLUME, volumeName);
    Uri scanUri = getContentResolver().insert(MediaStore.getMediaScannerUri(), values);

    Uri uri = Uri.parse("file://" + directories[0]);
    sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_STARTED, uri));

    try {
        if (volumeName.equals(MediaProvider.EXTERNAL_VOLUME)) {
            openDatabase(volumeName);
        }

        MediaScanner scanner = createMediaScanner();
        scanner.scanDirectories(directories, volumeName);
    } catch (Exception e) {
        Log.e(TAG, "exception in MediaScanner.scan()", e);
    }

    getContentResolver().delete(scanUri, null, null);

    sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, uri));
    mWakeLock.release();
}
</code></pre>

<p>```</p>

<h3>MediaScannerService中的createMediaScanner方法</h3>

<p>```java
private MediaScanner createMediaScanner() {</p>

<pre><code>    MediaScanner scanner = new MediaScanner(this);
    Locale locale = getResources().getConfiguration().locale;
    if (locale != null) {
        String language = locale.getLanguage();
        String country = locale.getCountry();
        String localeString = null;
        if (language != null) {
            if (country != null) {
                scanner.setLocale(language + "_" + country);
            } else {
                scanner.setLocale(language);
            }
        }    
    }

    return scanner;
</code></pre>

<p>}
```
从上面可以发现，真正工作的其实是<a href="https://android.googlesource.com/platform/frameworks/base/+/cd92588/media/java/android/media/MediaScanner.java" target="_blank">android.media.MediaScanner.java</a> 具体扫描过程就请点击左侧链接查看。</p>

<h2>如何扫描一个刚创建的文件</h2>

<p>这里介绍两种方式来实现将新创建的文件加入媒体库。</p>

<h3>最简单的方式</h3>

<p>只需要发送一个正确的intent广播到MediaScannerReceiver即可。
```java</p>

<pre><code>String saveAs = "Your_Created_File_Path"
Uri contentUri = Uri.fromFile(new File(saveAs));
Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,contentUri);
getContext().sendBroadcast(mediaScanIntent);
</code></pre>

<p>```
上面的极简方法大多数情况下正常工作，但是有些情况下是不会工作的，稍后的部分会介绍。即使你使用上述方法成功了，还是建议你继续阅读稍后的为什么发广播不成功的部分。</p>

<h3>使用MediaScannerConnection</h3>

<p>```java</p>

<pre><code>public void mediaScan(File file) {
    MediaScannerConnection.scanFile(getActivity(),
            new String[] { file.getAbsolutePath() }, null,
            new OnScanCompletedListener() {
                @Override
                public void onScanCompleted(String path, Uri uri) {
                    Log.v("MediaScanWork", "file " + path
                            + " was scanned seccessfully: " + uri);
                }
            });
}
</code></pre>

<p>```
MediaScannerConnection的scanFile方法从2.2（API 8）开始引入。</p>

<h3>创建一个MediaScannerConnection对象然后调用scanFile方法</h3>

<p>很简单，参考<a href="http://developer.android.com/reference/android/media/MediaScannerConnection.html" target="_blank"><a href="http://developer.android.com/reference/android/media/MediaScannerConnection.html">http://developer.android.com/reference/android/media/MediaScannerConnection.html</a></a></p>

<h3>如何扫描多个文件</h3>

<ul>
<li>发送多个Intent.ACTION_MEDIA_SCANNER_SCAN_FILE广播</li>
<li>使用MediaScannerConnection，传入要加入的路径的数组。</li>
</ul>


<h2>为什么发送MEDIA_SCANNER_SCAN_FILE广播不生效</h2>

<p>关于为什么有些设备上不生效，很多人认为是API原因，其实不是的，这其实和你传入的文件路径有关系。看一下接收者Receiver的onReceive代码。
```java</p>

<pre><code>public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    Uri uri = intent.getData();
    if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
        // scan internal storage
        scan(context, MediaProvider.INTERNAL_VOLUME);
    } else {
        if (uri.getScheme().equals("file")) {
            // handle intents related to external storage
            String path = uri.getPath();
            String externalStoragePath = Environment.getExternalStorageDirectory().getPath();

            Log.d(TAG, "action: " + action + " path: " + path);
            if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
                // scan whenever any volume is mounted
                scan(context, MediaProvider.EXTERNAL_VOLUME);
            } else if (action.equals(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE) &amp;&amp;
                    path != null &amp;&amp; path.startsWith(externalStoragePath + "/")) {
                scanFile(context, path);
            }
        }
    }
}
</code></pre>

<p>```</p>

<p>所有的部分都正确除了传入的路径。因为你可能硬编码了文件路径。因为有一个这样的判断<code>path.startsWith(externalStoragePath + "/")</code>,这里我举一个简单的小例子。
```java</p>

<pre><code>final String saveAs = "/sdcard/" + System.currentTimeMillis() + "_add.png";
Uri contentUri = Uri.fromFile(new File(saveAs));
Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,contentUri);
getContext().sendBroadcast(mediaScanIntent);
Uri uri = mediaScanIntent.getData();
String path = uri.getPath();
String externalStoragePath = Environment.getExternalStorageDirectory().getPath();
Log.i("LOGTAG", "Androidyue onReceive intent= " + mediaScanIntent 
                        + ";path=" + path + ";externalStoragePath=" +
                        externalStoragePath);
</code></pre>

<p><code>
我们看一下输出日志，分析原因。
</code>bash
LOGTAG Androidyue onReceive intent= Intent { act=android.intent.action.MEDIA_SCANNER_SCAN_FILE dat=file:///sdcard/1390136305831_add.png };path=/sdcard/1390136305831_add.png;externalStoragePath=/mnt/sdcard
```
上述输出分析，你发送的广播，action是正确的，数据规则也是正确的，而且你的文件路径也是存在的，<strong>但是</strong>，文件的路径<strong>/sdcard/1390136305831_add.png</strong>并不是以外部存储根路径<strong>/mnt/sdcard/</strong>开头。所以扫描操作没有开始，导致文件没有加入到媒体库。所以，请检查文件的路径。</p>

<h2>如何从多媒体库中移除</h2>

<p>如果我们删除一个多媒体文件的话，也就意味我们还需要将这个文件从媒体库中删除掉。</p>

<h3>能不能简简单单发广播？</h3>

<p>仅仅发一个广播能解决问题么？我倒是希望可以，但是实际上是不工作的，查看如下代码即可明白。
```java</p>

<pre><code>// this function is used to scan a single file
public Uri scanSingleFile(String path, String volumeName, String mimeType) {
    try {
        initialize(volumeName);
        prescan(path, true);

        File file = new File(path);
        if (!file.exists()) {
            return null;
        }

        // lastModified is in milliseconds on Files.
        long lastModifiedSeconds = file.lastModified() / 1000;

        // always scan the file, so we can return the content://media Uri for existing files
        return mClient.doScanFile(path, mimeType, lastModifiedSeconds, file.length(),
                false, true, MediaScanner.isNoMediaPath(path));
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in MediaScanner.scanFile()", e);
        return null;
    }
}
</code></pre>

<p><code>
正如上述代码，会对文件是否存在进行检查，如果文件不存在，直接停止向下执行。所以这样是不行的。那怎么办呢？
</code>java</p>

<pre><code>public void testDeleteFile() {
    String existingFilePath = "/mnt/sdcard/1390116362913_add.png";
    File  existingFile = new File(existingFilePath);
    existingFile.delete();
    ContentResolver resolver = getActivity().getContentResolver();
    resolver.delete(Images.Media.EXTERNAL_CONTENT_URI, Images.Media.DATA + "=?", new String[]{existingFilePath});

}
</code></pre>

<p>```
上述代码是可以工作的，直接从MediaProvider删除即可。
具体的删除代码请参考<a href="http://droidyue.com/blog/2014/02/09/code-snippet-for-media-on-android/" target="_blank">Code Snippet for Media on Android</a></p>

<h2>One More Thing</h2>

<ul>
<li>你可以通过查看/data/data/com.android.providers.media/的external.db文件可以了解更多的信息。</li>
</ul>


<h3>Others</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B009OLU8EE/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009OLU8EE&linkCode=as2&tag=droidyue-23">Android系统源代码情景分析</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009OLU8EE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中检测当前是否为主线程]]></title>
    <link href="http://droidyue.com/blog/2014/07/12/check-main-thread-in-android-chinese-edition/"/>
    <updated>2014-07-12T16:50:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/12/check-main-thread-in-android-chinese-edition</id>
    <content type="html"><![CDATA[<p>如果在Android中判断某个线程是否是主线程？对于这个问题，你可能说根据线程的名字，当然这个可以解决问题，但是这样是最可靠的么？万一某天Google一下子将线程的名字改称其他神马东西呢。</p>

<!-- more -->


<h2>方法揭晓</h2>

<p>下面的方法是最可靠的解决方案。
```java
public static boolean isInMainThread() {</p>

<pre><code>    return Looper.myLooper() == Looper.getMainLooper();
</code></pre>

<p>}
```
实际上，写到这里就基本解决了文章标题的问题了，但是仅仅研究到这里太肤浅了，刨的不够深，所以需要继续，希望你也可以继续读下去。</p>

<h2>刨根问底</h2>

<h3>实验一</h3>

<p>好，现在，我们对这个稳定的方法做一些测试，首先，下面的方法会增加一些调试打印信息。
```java
private boolean isInMainThread() {</p>

<pre><code>Looper myLooper = Looper.myLooper();
Looper mainLooper = Looper.getMainLooper();
Log.i(LOGTAG, "isInMainThread myLooper=" + myLooper 
    + ";mainLooper=" + mainLooper);
return myLooper == mainLooper;
</code></pre>

<p>}
<code>
好，然后我们在主线程中运行一个测试，调用上述方法。比如我们这样调用。
</code>java
Log.i(LOGTAG, &ldquo;testInMainThread inMainThread=&rdquo; + isInMainThread());
<code>
OK，我们看一下输出日志。验证OK。
</code>bash
I/TestInMainThread(32028): isInMainThread myLooper=Looper{40d35ef8};mainLooper=Looper{40d35ef8}
I/TestInMainThread(32028): testInMainThread inMainThread=true
```</p>

<h3>实验二</h3>

<p>现在我们继续在一个没有消息循环的非主线程，进行验证。
```java
new Thread() {</p>

<pre><code>@Override
public void run() {
    Log.i(LOGTAG, "testIn NOT in MainThread isMainThread="
        + isInMainThread());
    super.run();
}
</code></pre>

<p>}.start();
```</p>

<p>正如我们看到的如下日志结果，主线程的Looper（翻译成循环泵，不是很好听）已经被初始化赋值。但是我们新创建的线程的looper还是null。这是因为<strong>Android中的线程默认没有一个和它绑定了的消息循环</strong>（<strong>Threads by default do not have a message loop associated with them. Of course, the method works</strong>）
<code>bash
I/TestInMainThread(32028): isInMainThread myLooper=null;mainLooper=Looper{40d35ef8}
I/TestInMainThread(32028): testIn NOT in MainThread isMainThread=false
</code></p>

<h3>实验三</h3>

<p>继续，我们创建一个绑定了消息循环的线程，根据Android开发者文档说明，以下是一个典型的创建消息循环线程的示例，使用单独prepare（）方法和loop（）方法来创建一个绑定到Looper的Handler。
```java
new Thread() {</p>

<pre><code>private Handler mHandler;
@Override
public void run() {
    Looper.prepare();
    mHandler = new Handler() {
        public void handleMessage(Message msg) {
            // process incoming messages here
        }
    };
    Log.i(LOGTAG, "testInNonMainLooperThread isMainThread=" 
        + isInMainThread());
    Looper.loop();
}
</code></pre>

<p>}.start();
<code>
OK，现在再次检查以下日志，
</code>bash
I/TestInMainThread(32028): isInMainThread myLooper=Looper{40d72c58};mainLooper=Looper{40d35ef8}
I/TestInMainThread(32028): testInNonMainLooperThread isMainThread=false
```
两个Looper都被初始化赋值了，但是他们是不同的对象。</p>

<h2>原理发掘</h2>

<p>但是，这是为什么呢，这里面有什么奥秘呢？ 好，让我们看以下Looper.class
```java</p>

<pre><code>// sThreadLocal.get() will return null unless you've called prepare().
static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();
private static Looper sMainLooper;  // guarded by Looper.class

/**
 * Initialize the current thread as a looper, marking it as an
 * application's main looper. The main looper for your application
 * is created by the Android environment, so you should never need
 * to call this function yourself.  See also: {@link #prepare()}
 */
public static void prepareMainLooper() {
    prepare(false);
    synchronized (Looper.class) {
        if (sMainLooper != null) {
            throw new IllegalStateException("The main Looper has already been prepared.");
        }
        sMainLooper = myLooper();
    }
}

private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException("Only one Looper may be created per thread");
    }
    sThreadLocal.set(new Looper(quitAllowed));
}

/**
 * Return the Looper object associated with the current thread.  
 * Returns null if the calling thread is not associated with a Looper.
 */
public static Looper myLooper() {
    return sThreadLocal.get();
}

 /** Returns the application's main looper, which lives in the main thread of the application.
 */
public static Looper getMainLooper() {
    synchronized (Looper.class) {
        return sMainLooper;
    }
}
</code></pre>

<p>```</p>

<p>对于主线程来说，prepareMainLooper这个方法会被Android运行环境调用，而不是程序显式调用。通过这个方法，主线程的looper被创建，并且将对象引用传递给sMainLooper。所以保证了主线程myLooper()获取到的引用和getMainLooper()获取到的都是同一个引用。</p>

<p>对于没有消息循环的非主线程，默认的当前线程的looper是null，因为你从来没有手动地调用prepare()，所以它和主线程的looper不一样。</p>

<p>对于绑定了消息循环的非主线程，当调用Looper.prepare方法时，主线程的Looper已经由Android运行环境创建，当调用prepare方法后，绑定到这个非主线程的looper被创建，当然，这不可能和主线程的Looper一样。</p>

<p>综上所述，这个方法是可靠的。</p>

<p>引用:</p>

<ul>
<li> <a href="http://developer.android.com/reference/android/os/Looper.html">http://developer.android.com/reference/android/os/Looper.html</a></li>
<li> <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.4.2_r1/android/os/Looper.java/">http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.4.2_r1/android/os/Looper.java/</a></li>
</ul>


<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B009OLU8EE/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009OLU8EE&linkCode=as2&tag=droidyue-23">Android系统源代码情景分析</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009OLU8EE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Webview加载网页时发送HTTP头信息]]></title>
    <link href="http://droidyue.com/blog/2014/07/12/load-url-with-extra-header-in-android-webview-chinese-edition/"/>
    <updated>2014-07-12T08:36:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/12/load-url-with-extra-header-in-android-webview-chinese-edition</id>
    <content type="html"><![CDATA[<p>众所周知，当你点击一个超链接进行跳转时，WebView会自动将当前地址作为Referer（引荐）发给服务器，因此很多服务器端程序通过是否包含referer来控制盗链，所以有些时候，直接输入一个网络地址，可能有问题，那么怎么解决盗链控制问题呢，其实在webview加载时加入一个referer就可以了，如何添加呢？</p>

<!-- more -->


<p>从Android 2.2 （也就是API 8）开始，WebView新增加了一个接口方法，就是为了便于我们加载网页时又想发送其他的HTTP头信息的。</p>

<blockquote><p>public void loadUrl (String url, Map&lt;String, String> additionalHttpHeaders)<br/>
Added in API level 8<br/>
Loads the given URL with the specified additional HTTP headers.<br/>
Parameters<br/>
url the URL of the resource to load<br/>
additionalHttpHeaders   the additional headers to be used in the HTTP request for this URL, specified as a map from name to value. Note that if this map contains any of the headers that are set by default by this WebView, such as those controlling caching, accept types or the User-Agent, their values may be overriden by this WebView&rsquo;s defaults.</p></blockquote>

<p>以下是一个简单的demo，来展示以下如何使用。
```java
public void testLoadURLWithHTTPHeaders() {</p>

<pre><code>final String url = "http://droidyue.com";
WebView webView = new WebView(getActivity());
Map&lt;String,String&gt; extraHeaders = new HashMap&lt;String, String&gt;();
extraHeaders.put("Referer", "http://www.google.com");
webView.loadUrl(url, extraHeaders);
</code></pre>

<p>}
```</p>

<p>同样上面也可以应用到UserAgent等其他HTTP头信息<br/>
<a href="http://droidyue.com/blog/2014/05/27/load-url-with-extra-http-headers-using-webview-in-android/" target="_blank">英文版文章</a></p>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00LF7R8MA/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00LF7R8MA&linkCode=as2&tag=droidyue-23">高性能浏览器网络</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00LF7R8MA" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
</feed>
