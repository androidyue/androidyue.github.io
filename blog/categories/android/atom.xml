<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2015-04-07T21:24:10+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[士别三年，我的最新个人作品]]></title>
    <link href="http://droidyue.com/blog/2015/02/28/my-android-work-akoi/"/>
    <updated>2015-02-28T20:43:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/02/28/my-android-work-akoi</id>
    <content type="html"><![CDATA[<p>这个应用是我的最新的作品，一个解决了自己需求的App。</p>

<h2>这是神马App</h2>

<p>拷译是一款超级便捷的翻译工具，其理念就是拷贝即翻译。通常情况下，我们在阅读外文文章时遇到不懂的单词，常见的步骤就是，复制单词，然后切换到桌面，打开字典，进行翻译，理解了意思之后，然后退回到阅读软件，其实就在这些繁琐的过程中，我们阅读很容易被打断，进而影响阅读外文的效率。拷译则解决了这个问题，在阅读软件中遇到了生词，我们只需要复制一下，然后生词对应的意思就能立刻出来，省去了繁琐的切换，让你专注阅读不分心。</p>

<!--more-->


<h2>高清无码大图</h2>

<p><img class="<a" src="href="http://droidyueimg.qiniudn.com/akoi_ui.png">http://droidyueimg.qiniudn.com/akoi_ui.png</a>">
<img class="<a" src="href="http://droidyueimg.qiniudn.com/akoi_target_language.png">http://droidyueimg.qiniudn.com/akoi_target_language.png</a>">
<img class="<a" src="href="http://droidyueimg.qiniudn.com/akoi_result_new.png">http://droidyueimg.qiniudn.com/akoi_result_new.png</a>"></p>

<h2>等饭时的脑洞</h2>

<p>一个周末的晚上，我去附近的春和饺子馆买饭，为了避免在那里吃堂食吸二手烟，我决定打包带走，去之前使用Pocket离线了一篇关于Java运行时数据区的英文文章，于是边等饭边阅读文章，发现了一个不懂的单词，这时候我的做法是复制单词，按Home键退回桌面，找到词典进入，贴出单词，然后查看答案，再退回到Pocket继续阅读。</p>

<p>此时此刻，程序的优越性体现出来了，当剪切板内容变化是由回调通知的，既然我可以拿到复制的内容，我可以使用一个Web服务API翻译这个内容，然后将这些操作放到Service中，将取到的结果以Toast形式展示不就可以了么。当饭好了之后，提着打包的饭屁颠屁颠地回去了。。。。。</p>

<h2>完成前的瞬间</h2>

<ul>
<li>想法出来之后，吃完晚饭花了两个小时解决了技术问题，做出了一个可用的原型</li>
<li>一周以后，邀请小伙伴设计师大麦讨论问题，讨论结果显示位置和应用的功能。</li>
<li>最近的周末，催大麦给我做启动图标，在三里屯请我吃了顿饭，然后去央视大裤衩附近的他的公司逼着他做图。</li>
</ul>


<h2>为什么加广告</h2>

<p>我确实是在应用里面加了广告了，想必使用QQ手机管家这样的工具都能提示的。</p>

<p>国内版本加入的是<a href="https://www.youmi.net/account/register?r=OTU2Ng==">有米广告</a>,之前一直在用有米广告，感觉很不错，感兴趣的朋友可以试一试。</p>

<p>主要的原因还是增加一点收入，毕竟在帝都公交地铁都涨价了，另外加入的广告属于可以接受的，不存在强制弹出的问题，而且广告并非是时刻展示，只有用户触发类似推荐应用时才出现，属于无干扰的类型。</p>

<h2>下载地址</h2>

<p><img class="<a" src="href="http://droidyueimg.qiniudn.com/akoi_qrcode_download.png">http://droidyueimg.qiniudn.com/akoi_qrcode_download.png</a>"></p>

<h2>特别感谢</h2>

<ul>
<li>大麦 我的御用设计师，帮我做图标。多次往返于宋家庄与西北旺之间，辛苦。</li>
</ul>


<h2>最后的话</h2>

<h3>其他词典有这个功能</h3>

<p>确实，当我有了上面的想法之后，查了一下市场上的应用，确实有几款有这样的功能。但是还是有一些不同的，因为依托了百度翻译的技术，支持的语言相对较多。只做复制翻译操作。</p>

<h3>博客没更新</h3>

<p>确实写这个小应用还是比较花时间的，周末的时间，回到家的时间，零零散散的时间，导致最近博客更新减慢，多有抱歉哈。</p>

<h3>沉默三年</h3>

<p>确实距离上次写应用已经三年了，三年前自己还在大学的时候，写过几个拿不出手的应用，那时候自己找图，写的App一点儿技术含量都没有。现在写这个应用完全是解决自己的需求，如果同时能帮助其他人，那么这个应用也是值得的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中处理Touch Icon的方案]]></title>
    <link href="http://droidyue.com/blog/2015/01/18/deal-with-touch-icon-in-android/"/>
    <updated>2015-01-18T21:23:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/01/18/deal-with-touch-icon-in-android</id>
    <content type="html"><![CDATA[<p>苹果的Touch Icon相对我们都比较熟悉，是苹果为了支持网络应用（或者说网页）添加到桌面需要的图标，有了这些Touch Icon的网页链接更加和Native应用更相像了。由于苹果设备IPod，IPhone,IPad等设备广泛，很多网页都提供了touch icon这种图标资源。由于Android中并没有及早的有一份这样的标准，当我们想把网页添加到桌面时，仍然需要使用苹果的Touch Icon。</p>

<!--more-->


<h2>Touch Icon</h2>

<p>当我们想让一个网页比较完美地添加到桌面，通常情况下我们需要设置一个png图片文件作为apple-touch-icon。比如
<code>html
&lt;link rel="apple-touch-icon" href="http://droidyue.com/custom_icon.png"&gt;
</code>
如果想支持IPhone和IPad，我们需要使用sizes属性来制定多个图片，默认sizes的值为60 x 60。
<code>html
&lt;link rel="apple-touch-icon" href="touch-icon-iphone.png"&gt;
&lt;link rel="apple-touch-icon" sizes="76x76" href="touch-icon-ipad.png"&gt;
&lt;link rel="apple-touch-icon" sizes="120x120" href="touch-icon-iphone-retina.png"&gt;
&lt;link rel="apple-touch-icon" sizes="152x152" href="touch-icon-ipad-retina.png"&gt;
</code>
在IOS7之前，苹果系统会对添加到桌面的图标进行圆角化等视觉上的处理，为了不让其处理，我们可以使用apple-touch-icon-precomposed来作为rel的值实现。</p>

<p>更多关于Touch Icon的信息，可以访问<a href="https://developer.apple.com/library/mac/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html">水果开发者网站</a>了解更多。</p>

<h2>Android中有缺陷的实现</h2>

<p>在Android WebView提供了处理Touch Icon的回调，<code>onReceivedTouchIconUrl(WebView view, String url,boolean precomposed)</code>该方法返回了对我们有用的touch icon的url，和是否为预组合（在IOS中不需要进行视觉处理）。虽然有这些数据，我们可以进行处理，但是这其中是有问题的，就是我们不好确定文件的大小，来选择适合的图片。</p>

<p>举个例子,如下一个网页的源码，其中sizes的顺序不规律
<code>html
&lt;link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://www.qiyipic.com/20130423143600/fix/H5-72x72.png"&gt;
&lt;link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://www.qiyipic.com/20130423143600/fix/H5-114x114.png"&gt;
&lt;link rel="apple-touch-icon-precomposed" sizes="57x57" href="http://www.qiyipic.com/20130423143600/fix/H5-57x57.png"&gt;
&lt;link rel="apple-touch-icon-precomposed"  href="http://www.qiyipic.com/20130423143600/fix/H5-0x0.png"&gt;
</code>
加载网页，onReceivedTouchIconUrl输出的日志
<code>bash
I/MainActivity( 6995): onReceivedTouchIconUrl url=http://www.qiyipic.com/20130423143600/fix/H5-0x0.png;precomposed=true
I/MainActivity( 6995): onReceivedTouchIconUrl url=http://www.qiyipic.com/20130423143600/fix/H5-57x57.png;precomposed=true
I/MainActivity( 6995): onReceivedTouchIconUrl url=http://www.qiyipic.com/20130423143600/fix/H5-114x114.png;precomposed=true
I/MainActivity( 6995): onReceivedTouchIconUrl url=http://www.qiyipic.com/20130423143600/fix/H5-72x72.png;precomposed=true
</code>
从上面的输出来看，基本上是后面（书写）的元素先打印出来，所以这个回调的缺陷如下</p>

<ul>
<li>由于Touch Icon url地址没有硬性规定，不能根据url包含某些尺寸来判断使用哪个icon</li>
<li>由于网页编写touch icon元素相对随意，不能根据onReceivedTouchIconUrl调用先后来决定使用哪个icon</li>
<li>回调中没有sizes属性值，不好确定使用哪个icon</li>
<li>如果我们选取质量最高的图片，然后进行适当压缩处理或许可以解决问题，但是将全部icon下载下来或者根据Head头信息总感觉不怎么好。</li>
</ul>


<h2>改进方法</h2>

<p>既然WebView没有现成的方法满足我们的需求，只好自己来实现。其实实现方法还是比较简单地就是js脚本注入检测网页元素中得touch icon，返回json数据。</p>

<h3>JavaScript方法</h3>

<p>下面的JS代码所做的功能为查找所有为touch icon的link元素，包含正常的还标记为precomposed。然后将这些link元素的属性存入json数据，最后返回给Java代码中对应的回调。
```javascript
var touchIcons = [];
function gatherTouchIcons(elements) {</p>

<pre><code>var normalTouchIconLength = elements.length;
var currentElement;
for (var i =0; i &lt; normalTouchIconLength;i++) {
    currentElement = elements[i];
    var size;
    if (currentElement.hasAttribute('sizes')) {
        size = currentElement.sizes[0];
    } else {
        size = '';
    }
    var info = {'sizes':size, 'rel': currentElement.rel, 'href': currentElement.href};
    touchIcons.push(info);
}
</code></pre>

<p>}</p>

<p>function obtainTouchIcons() {</p>

<pre><code>normalElements = document.querySelectorAll("link[rel='apple-touch-icon']");
precomposedElements = document.querySelectorAll("link[rel='apple-touch-icon-precomposed']");
gatherTouchIcons(normalElements);
gatherTouchIcons(precomposedElements);
var info = JSON.stringify(touchIcons);
window.app_native.onReceivedTouchIcons(document.URL, info);
</code></pre>

<p>}
obtainTouchIcons();
```</p>

<h3>Java代码</h3>

<p>这里为了便于理解还是全部贴出了demo的源码，demo中当网页加载完成之后注入上面的js代码获取touch icon信息，然后返回给java的回调方法中。如果不清楚Java和JavaScript交互，可以访问<a href="http://droidyue.com/blog/2014/09/20/interaction-between-java-and-javascript-in-android/">Android中Java和JavaScript交互</a>了解更多。
```java
package com.example.obtaintouchicon;</p>

<p>import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;</p>

<p>import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.webkit.JavascriptInterface;
import android.webkit.WebChromeClient;
import android.webkit.WebView;
import android.webkit.WebViewClient;</p>

<p>public class MainActivity extends Activity {</p>

<pre><code>protected String LOGTAG = "MainActivity";

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    WebView webView = new WebView(this);
    webView.getSettings().setJavaScriptEnabled(true);
    webView.setWebViewClient(new WebViewClient() {
        @Override
        public void onPageFinished(WebView view, String url) {
            super.onPageFinished(view, url);
            final String touchIconJsCode = getTouchIconJsCode();
            Log.i(LOGTAG , "onPageFinished url = " + url + ";touchIconJsCode=" + touchIconJsCode);
            view.loadUrl("javascript:" + touchIconJsCode);
        }
    });
    webView.addJavascriptInterface(new JsObject(), "app_native");
    webView.loadUrl("http://192.168.1.5:8000/html/touchicon.html");
}


private class JsObject {

    @JavascriptInterface
    public void onReceivedTouchIcons(String url, String json) {
        Log.i(LOGTAG, "onReceivedTouchIcons url=" + url + ";json=" + json);
    }
}

private String getTouchIconJsCode() {
    StringBuilder total = new StringBuilder();
    InputStream inputStream = null;
    BufferedReader bufferReader = null;
    try {
        inputStream = getAssets().open("touchicon.js");
        bufferReader = new BufferedReader(new InputStreamReader(inputStream));
        String line;
        while ((line = bufferReader.readLine()) != null) {
            total.append(line);
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (null != inputStream) {
            try {
                inputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    return total.toString();
}
</code></pre>

<p>}
```</p>

<h3>返回的JSON数据</h3>

<p>```java
[</p>

<pre><code>{
    "sizes":"72x72",
    "rel":"apple-touch-icon-precomposed",
    "href":"http://www.qiyipic.com/20130423143600/fix/H5-72x72.png"
},
{
    "sizes":"114x114",
    "rel":"apple-touch-icon-precomposed",
    "href":"http://www.qiyipic.com/20130423143600/fix/H5-114x114.png"
},
{
    "sizes":"57x57",
    "rel":"apple-touch-icon-precomposed",
    "href":"http://www.qiyipic.com/20130423143600/fix/H5-57x57.png"
},
{
    "sizes":"",
    "rel":"apple-touch-icon-precomposed",
    "href":"http://www.qiyipic.com/20130423143600/fix/H5-0x0.png"
}
</code></pre>

<p>]
```
我们可以对得到的JSON数据按照需要处理。</p>

<h2>Google会改进么</h2>

<p>答案是会，而且已经改进，但Google修改的不是onReceivedTouchIconUrl这个方法，而是Google正在推行自己的一套规则。</p>

<p>在Chrome上，Google增加了这样一个元素，这是Google提供的为网页程序定义元数据的方法。
<code>html
&lt;link rel="manifest" href="manifest.json"&gt;
</code>
在元数据json中，你可以自定义title，起始页，程序是横屏还是竖屏展示。一个简单地json实例如下，这里我们可以看到其中icons中存在多个类似touch icon的图标，src代表图标路径，sizes代表大小，type就是mimetype，density指的是Android中的屏幕密度（这样更加Android化了）。
```java
{
  &ldquo;name&rdquo;: &ldquo;Web Application Manifest Sample&rdquo;,
  &ldquo;icons&rdquo;: [</p>

<pre><code>{
  "src": "launcher-icon-0-75x.png",
  "sizes": "36x36",
  "type": "image/png",
  "density": "0.75"
},
{
  "src": "launcher-icon-1x.png",
  "sizes": "48x48",
  "type": "image/png",
  "density": "1.0"
},
{
  "src": "launcher-icon-1-5x.png",
  "sizes": "72x72",
  "type": "image/png",
  "density": "1.5"
},
{
  "src": "launcher-icon-2x.png",
  "sizes": "96x96",
  "type": "image/png",
  "density": "2.0"
},
{
  "src": "launcher-icon-3x.png",
  "sizes": "144x144",
  "type": "image/png",
  "density": "3.0"
},
{
  "src": "launcher-icon-4x.png",
  "sizes": "192x192",
  "type": "image/png",
  "density": "4.0"
}
</code></pre>

<p>  ],
  &ldquo;start_url&rdquo;: &ldquo;index.html&rdquo;,
  &ldquo;display&rdquo;: &ldquo;standalone&rdquo;,
  &ldquo;orientation&rdquo;: &ldquo;landscape&rdquo;
}
```
关于Google这套新的标准，可以参考<a href="https://developer.chrome.com/multidevice/android/installtohomescreen">Add to Homescreen</a></p>

<p>但是由于目前，这种标准实施率相对比较低，所以我们还是需要使用苹果的touch icon。</p>

<h2>推荐阅读</h2>

<ul>
<li><a href="https://mathiasbynens.be/notes/touch-icons">Everything you always wanted to know about touch icons</a></li>
</ul>


<h2>源码下载</h2>

<ul>
<li><a href="http://pan.baidu.com/s/1dDD3gZZ">http://pan.baidu.com/s/1dDD3gZZ</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中Handler引起的内存泄露]]></title>
    <link href="http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur/"/>
    <updated>2014-12-28T11:24:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur</id>
    <content type="html"><![CDATA[<p>在Android常用编程中，Handler在进行异步操作并处理返回结果时经常被使用。通常我们的代码会这样实现。
```java
public class SampleActivity extends Activity {</p>

<p>  private final Handler mLeakyHandler = new Handler() {</p>

<pre><code>@Override
public void handleMessage(Message msg) {
  // ... 
}
</code></pre>

<p>  }
}
```</p>

<!--more-->


<p>但是，其实上面的代码可能导致内存泄露，当你使用Android lint工具的话，会得到这样的警告</p>

<blockquote><p>In Android, Handler classes should be static or leaks might occur, Messages enqueued on the application thread&rsquo;s MessageQueue also retain their target Handler. If the Handler is an inner class, its outer class will be retained as well. To avoid leaking the outer class, declare the Handler as a static nested class with a WeakReference to its outer class</p></blockquote>

<p>看到这里，可能还是有一些搞不清楚，代码中哪里可能导致内存泄露，又是如何导致内存泄露的呢？那我们就慢慢分析一下。</p>

<p>1.当一个Android应用启动的时候，会自动创建一个供应用主线程使用的Looper实例。Looper的主要工作就是一个一个处理消息队列中的消息对象。在Android中，所有Android框架的事件（比如Activity的生命周期方法调用和按钮点击等）都是放入到消息中，然后加入到Looper要处理的消息队列中，由Looper负责一条一条地进行处理。主线程中的Looper生命周期和当前应用一样长。</p>

<p>2.当一个Handler在主线程进行了初始化之后，我们发送一个target为这个Handler的消息到Looper处理的消息队列时，实际上已经发送的消息已经包含了一个Handler实例的引用，只有这样Looper在处理到这条消息时才可以调用Handler#handleMessage(Message)完成消息的正确处理。</p>

<p>3.在Java中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用。静态的内部类不会持有外部类的引用。关于这一内容可以查看<a href="http://droidyue.com/blog/2014/10/02/the-private-modifier-in-java/">细话Java："失效"的private修饰符</a></p>

<p>确实上面的代码示例有点难以察觉内存泄露，那么下面的例子就非常明显了
```java
public class SampleActivity extends Activity {</p>

<p>  private final Handler mLeakyHandler = new Handler() {</p>

<pre><code>@Override
public void handleMessage(Message msg) {
  // ...
}
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);

// Post a message and delay its execution for 10 minutes.
mLeakyHandler.postDelayed(new Runnable() {
  @Override
  public void run() { /* ... */ }
}, 1000 * 60 * 10);

// Go back to the previous Activity.
finish();
</code></pre>

<p>  }
}
```
分析一下上面的代码，当我们执行了Activity的finish方法，被延迟的消息会在被处理之前存在于主线程消息队列中10分钟，而这个消息中又包含了Handler的引用，而Handler是一个匿名内部类的实例，其持有外面的SampleActivity的引用，所以这导致了SampleActivity无法回收，进行导致SampleActivity持有的很多资源都无法回收，这就是我们常说的内存泄露。</p>

<p>注意上面的new Runnable这里也是匿名内部类实现的，同样也会持有SampleActivity的引用，也会阻止SampleActivity被回收。</p>

<p>要解决这种问题，思路就是不适用非静态内部类，继承Handler时，要么是放在单独的类文件中，要么就是使用静态内部类。因为静态的内部类不会持有外部类的引用，所以不会导致外部类实例的内存泄露。当你需要在静态内部类中调用外部的Activity时，我们可以使用<a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">弱引用</a>来处理。另外关于同样也需要将Runnable设置为静态的成员属性。注意：一个静态的匿名内部类实例不会持有外部类的引用。
修改后不会导致内存泄露的代码如下</p>

<p>```java
public class SampleActivity extends Activity {</p>

<p>  /<em>*
   * Instances of static inner classes do not hold an implicit
   * reference to their outer class.
   </em>/
  private static class MyHandler extends Handler {</p>

<pre><code>private final WeakReference&lt;SampleActivity&gt; mActivity;

public MyHandler(SampleActivity activity) {
  mActivity = new WeakReference&lt;SampleActivity&gt;(activity);
}

@Override
public void handleMessage(Message msg) {
  SampleActivity activity = mActivity.get();
  if (activity != null) {
    // ...
  }
}
</code></pre>

<p>  }</p>

<p>  private final MyHandler mHandler = new MyHandler(this);</p>

<p>  /<em>*
   * Instances of anonymous classes do not hold an implicit
   * reference to their outer class when they are &ldquo;static&rdquo;.
   </em>/
  private static final Runnable sRunnable = new Runnable() {</p>

<pre><code>  @Override
  public void run() { /* ... */ }
</code></pre>

<p>  };</p>

<p>  @Override
  protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);

// Post a message and delay its execution for 10 minutes.
mHandler.postDelayed(sRunnable, 1000 * 60 * 10);

// Go back to the previous Activity.
finish();
</code></pre>

<p>  }
}
```</p>

<p>其实在Android中很多的内存泄露都是由于在Activity中使用了非静态内部类导致的，就像本文提到的一样，所以当我们使用时要非静态内部类时要格外注意，如果其实例的持有对象的生命周期大于其外部类对象，那么就有可能导致内存泄露。个人倾向于使用文章的静态类和弱引用的方法解决这种问题。</p>

<h3>译文信息</h3>

<ul>
<li><a href="http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html">How to Leak a Context: Handlers &amp; Inner Classes</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[应用认领那些事]]></title>
    <link href="http://droidyue.com/blog/2014/12/14/android-yingyong-renling/"/>
    <updated>2014-12-14T19:35:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/12/14/android-yingyong-renling</id>
    <content type="html"><![CDATA[<p>最近公司的一款产品提交国内市场，发现有些国内市场提示需要进行应用认领。原因就是别人（或者市场抓取）已经在我们之前将这个应用提交到了该市场。认领成功后，这个应用就重回你的怀抱了，其实认领很简单，这里讲到的自然是对未签名的包进行签名。由于这样的操作细小琐屑，这样更需要记录一下，免得以后麻烦。</p>

<!--more-->


<h2>如何认领</h2>

<ul>
<li>一般的就是市场提供一个未签名的apk包，认领方进行签名后，上传即可认领成功。</li>
<li>另一种就是提供公司证明，这个我们不讲，也没什么可以讲。</li>
</ul>


<p>通常情况下认领都会有对一个未签名的apk包签名认证这种方式，因为签名是软件发布商所独有的，通过对比测试需认领的包的签名和刚签过名的apk包是否一致，如果一致就认领成功，否则失败。</p>

<h2>对未签名包签名</h2>

<p><code>bash
jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore your_keystore  -storepass your_storepass -keypass your_keypass -signedjar path_of_signed_apk  path_of_unsigned_apk your_alias
</code></p>

<h3>需要替换的值</h3>

<ul>
<li>your_key_store keystore文件路径</li>
<li>your_storepass   store密码</li>
<li>your_keypass    key密码</li>
<li>path_of_signed_apk 签名后apk保存的目录</li>
<li>path_of_unsigned_apk 待签名的apk包</li>
<li>your_alias keystore中的别名</li>
</ul>


<p>注意上面的签名算法sigalg 使用SHA1withRSA或者MD5withRSA都可以。</p>

<h2>验证签名</h2>

<p><code>bash
jarsigner -verify -certs -verbose your_app.apk
</code>
比如我们验证百度金融的apk，会得到类似这样的结果
```bash
19:23 $ jarsigner -verify -certs -verbose BaiduFinance.apk | more</p>

<p>s      61679 Fri Nov 14 19:50:16 CST 2014 META-INF/MANIFEST.MF</p>

<pre><code>  X.509, CN=Baidu, OU=Baidu Inc., O=Baidu Inc., L=Beijing, ST=Beijing, C=CN
  [certificate is valid from 12/6/13 10:19 AM to 11/24/63 10:19 AM]
  [CertPath not validated: Path does not chain with any of the trust anchors]

   61800 Fri Nov 14 19:50:16 CST 2014 META-INF/MCO_BAID.SF
     936 Fri Nov 14 19:50:16 CST 2014 META-INF/MCO_BAID.RSA
</code></pre>

<p>sm      2304 Fri Nov 14 19:49:32 CST 2014 assets/mean/data_mean_24_bank_card
```</p>

<h2>疑难问题</h2>

<h3>No -tsa or -tsacert is provided and this jar is not timestamped</h3>

<p>在签名时加入下面的选项
<code>bash
jarsigner -tsa http://timestamp.digicert.com
</code></p>

<h3>Windows无法打开文件</h3>

<p>有些Windows工具无法打开签名后的apk，如果你的签名没有错误，并且验证过，这种情况请忽略。</p>

<h3>签名认领失败</h3>

<p>如果签名认领失败的话，请检查目前线上的包是否进行了二次打包被别人篡改了签名，如果是的话，需要进行商务上的沟通来解决了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[仿腾讯新闻样式的Toast]]></title>
    <link href="http://droidyue.com/blog/2014/11/29/custom-toast-like-tencent-news-app/"/>
    <updated>2014-11-29T17:21:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/29/custom-toast-like-tencent-news-app</id>
    <content type="html"><![CDATA[<p>厌倦了网易新闻无处不在的喷子，尝试了一下腾讯新闻，果然顿时清净了很多，当然这不是重点。个人感觉腾讯新闻客户端的Toast比较不错，相对于系统默认的Toast，更加能起到提醒的作用。于是反编译了一下，简单分享一下,其实很简单。</p>

<!--more-->


<h2>先看效果</h2>

<p><img class="<a" src="href="http://droidyueimg.qiniudn.com/tencent_toast.png">http://droidyueimg.qiniudn.com/tencent_toast.png</a>">
背景为深灰色，支持设置图片和文字。</p>

<h2>布局文件</h2>

<p>```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;RelativeLayout</p>

<pre><code>android:id="@+id/view_tips_layout" 
android:background="@drawable/tips_bg" 
android:layout_width="wrap_content" 
android:layout_height="wrap_content"
xmlns:android="http://schemas.android.com/apk/res/android"&gt;
&lt;View 
    android:layout_width="160.0dip" 
    android:layout_height="160.0dip" 
    android:layout_centerInParent="true" /&gt;

&lt;LinearLayout 
    android:orientation="vertical" 
    android:layout_width="wrap_content" 
    android:layout_height="wrap_content" 
    android:layout_centerInParent="true"&gt;

    &lt;ImageView 
        android:gravity="center" 
        android:layout_gravity="center" 
        android:id="@+id/tips_icon" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_marginBottom="10.0dip" 
        android:src="@drawable/tips_error" 
        android:contentDescription="@null" /&gt;

    &lt;TextView 
        android:textSize="17.0sp" 
        android:textColor="#ffffffff" 
        android:gravity="center" 
        android:layout_gravity="center" 
        android:id="@+id/tips_msg" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:lineSpacingExtra="3.0dip" /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p></RelativeLayout>
```</p>

<h2>程序代码</h2>

<p><code>java
Toast toast = new Toast(getApplicationContext());
View toastView = LayoutInflater.from(getApplicationContext()).inflate(R.layout.view_tips, null);
((ImageView)toastView.findViewById(R.id.tips_icon)).setImageResource(R.drawable.ic_launcher);
((TextView)toastView.findViewById(R.id.tips_msg)).setText("Error Occurs");
toast.setView(toastView);
toast.setGravity(Gravity.NO_GRAVITY, 0, 0);
toast.show();
</code>
Toast默认的位置为底部水平居中。我们可以通过设置setGravity(int, int, int)来进行设置位置。该方法接受三个参数，一个Gravity常量，一个x（水平）方向上的偏移量，一个y（竖直）方向上的偏移量。</p>

<p>如果我们想让位置向右我们需要增加x方向上的偏移量，如果想让位置向下，增大y方向上的偏移量。</p>

<h2>多说</h2>

<p>我们可以根据自己的需求去设置图片，文字，背景色等样式来定制想要的Toast。</p>

<p>注意，涉及到长度宽度字体大小相关的建议放到dimens文件，便于我们进行设备适配。</p>

<h2>示例下载</h2>

<p><a href="http://pan.baidu.com/s/1kTLxagZ">百度网盘</a></p>
]]></content>
  </entry>
  
</feed>
