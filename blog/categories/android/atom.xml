<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://androidyue.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://androidyue.github.io/"/>
  <updated>2014-06-14T16:00:27+08:00</updated>
  <id>http://androidyue.github.io/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[检查Android是否具有摄像头]]></title>
    <link href="http://androidyue.github.io/blog/2014/06/14/check-camera-in-android/"/>
    <updated>2014-06-14T15:57:00+08:00</updated>
    <id>http://androidyue.github.io/blog/2014/06/14/check-camera-in-android</id>
    <content type="html"><![CDATA[<p>通常我们进行摄像头操作，如扫描二维码需要判断是否有后置摄像头(Rear camera)，比如Nexus 7 一代就没有后置摄像头，这样在尝试使用的时候，我们需要进行判断进行一些提示或者处理。</p>

<p>以下代码为一系列的方法，用来判断是否有前置摄像头（Front Camera），后置摄像头。</p>

<p>```java
private static boolean checkCameraFacing(final int facing) {</p>

<pre><code>if (getSdkVersion() &lt; Build.VERSION_CODES.GINGERBREAD) {
    return false;
}
final int cameraCount = Camera.getNumberOfCameras();
CameraInfo info = new CameraInfo();
for (int i = 0; i &lt; cameraCount; i++) {
    Camera.getCameraInfo(i, info);
    if (facing == info.facing) {
        return true;
    }
}
return false;
</code></pre>

<p>}</p>

<p>public static boolean hasBackFacingCamera() {</p>

<pre><code>final int CAMERA_FACING_BACK = 0;
return checkCameraFacing(CAMERA_FACING_BACK);
</code></pre>

<p>}</p>

<p>public static boolean hasFrontFacingCamera() {</p>

<pre><code>final int CAMERA_FACING_BACK = 1;
return checkCameraFacing(CAMERA_FACING_BACK);
</code></pre>

<p>}</p>

<p>public static int getSdkVersion() {</p>

<pre><code>return android.os.Build.VERSION.SDK_INT;
</code></pre>

<p>}
```
注意：由于getNumberOfCameras以及getCameraInfo均为API 9 引入，所以方法只适用于2.3及其以上。</p>

<p>延伸阅读：<a href="http://developer.android.com/reference/android/hardware/Camera.html">http://developer.android.com/reference/android/hardware/Camera.html</a>
<a href="http://developer.android.com/reference/android/hardware/Camera.CameraInfo.html">http://developer.android.com/reference/android/hardware/Camera.CameraInfo.html</a></p>

<blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android NinePatch Attention]]></title>
    <link href="http://androidyue.github.io/blog/2014/04/26/android-ninepatch-attention/"/>
    <updated>2014-04-26T12:23:00+08:00</updated>
    <id>http://androidyue.github.io/blog/2014/04/26/android-ninepatch-attention</id>
    <content type="html"><![CDATA[<p>I have got many crash report data about using NinePath Drwable. I put a .9.png file into the drawable-xhdpi folder and the file did not exist in any other folder. And I got ResourceNotFoundException. I got this following sayings.</p>

<blockquote><p>A NinePatchDrawable graphic is a stretchable bitmap image, which Android will automatically resize to accommodate the contents of the View in which you have placed it as the background. An example use of a NinePatch is the backgrounds used by standard Android buttons — buttons must stretch to accommodate strings of various lengths. A NinePatch drawable is a standard PNG image that includes an extra 1-pixel-wide border. <strong>It must be saved with the extension .9.png, and saved into the res/drawable/ directory of your project.</strong>
<a href="http://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch">http://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch</a></p></blockquote>

<p>The .9.png files must be saved into the res/drawable directory. Why? I guess the legacy Resouce Loading System implemententation may result in this issue. So at least put one .9.png file into the drawable folder.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fix Notification Switching Position Issue]]></title>
    <link href="http://androidyue.github.io/blog/2014/03/21/fix-notification-switching-position-issue/"/>
    <updated>2014-03-21T22:14:00+08:00</updated>
    <id>http://androidyue.github.io/blog/2014/03/21/fix-notification-switching-position-issue</id>
    <content type="html"><![CDATA[<p>I once faced with a problem. I wrote a piece of code related with notifcation. Everything goes fine except one little issue. I found the ongoing notification switching order. My notification blinked each second.  After Googling I found the reason and resolved the problem.<br/>
In my code I wrote like this
```java</p>

<pre><code>notification.when = System.currentTimeMillis();
</code></pre>

<p><code>
That's was the key point. For the notification the when timestamp should be fixed when an activity starts. And the default value is Now(which is the value of System.currentTimeMillis()).I used **a fixed value** and resovled the problem.
</code>java
notification.when = TIMESTAMP_FIXED;
```
Now This is what Google says</p>

<blockquote><p>A timestamp related to this notification, in milliseconds since the epoch. Default value: Now. Choose a timestamp that will be most relevant to the user. For most finite events, this corresponds to the time the event happened (or will happen, in the case of events that have yet to occur but about which the user is being informed). Indefinite events should be timestamped according to when the activity began. Some examples:</p>

<ul>
<li>Notification of a new chat message should be stamped when the message was received.</li>
<li>Notification of an ongoing file download (with a progress bar, for example) should be stamped when the download started.</li>
<li>Notification of a completed file download should be stamped when the download finished.</li>
<li>Notification of an upcoming meeting should be stamped with the time the meeting will begin (that is, in the future).</li>
<li>Notification of an ongoing stopwatch (increasing timer) should be stamped with the watch&rsquo;s start time.</li>
<li>Notification of an ongoing countdown timer should be stamped with the timer&rsquo;s end time.
Reference from <a href="http://developer.android.com/reference/android/app/Notification.html#when">http://developer.android.com/reference/android/app/Notification.html#when</a>
Written with <a href="https://stackedit.io/">StackEdit</a>.</li>
</ul>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Snippet For Media on Android]]></title>
    <link href="http://androidyue.github.io/blog/2014/02/09/code-snippet-for-media-on-android/"/>
    <updated>2014-02-09T19:37:00+08:00</updated>
    <id>http://androidyue.github.io/blog/2014/02/09/code-snippet-for-media-on-android</id>
    <content type="html"><![CDATA[<p>A few days ago,I have wrote down this post <a href="http://androidyue.github.io/blog/2014/01/19/scan-media-files-in-android/">http://androidyue.github.io/blog/2014/01/19/scan-media-files-in-android/</a>. Now I will paste my code snippet.</p>

<h3>MediaUtils.java</h3>

<p>```java
package com.mx.browser.utils;</p>

<p>import java.io.File;
import java.util.Locale;</p>

<p>import com.mx.utils.FileUtils;
import com.mx.utils.Log;</p>

<p>import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.media.MediaScannerConnection;
import android.media.MediaScannerConnection.OnScanCompletedListener;
import android.net.Uri;
import android.provider.MediaStore.Audio;
import android.provider.MediaStore.Images;
import android.provider.MediaStore.Video;
import android.text.TextUtils;</p>

<p>/<em>*
 * Utility Methods for Media Library Operations
 * @author androidyue
 * Referrer  <a href="http://androidyue.github.io/blog/2014/01/19/scan-media-files-in-android/">http://androidyue.github.io/blog/2014/01/19/scan-media-files-in-android/</a>
 </em>/
public class MediaUtils {</p>

<pre><code>private static final String LOGTAG = "MediaUtils";

/**
 * Scan a media file by sending a broadcast.This is the easiest way.
 * 对方成功接收广播并处理条件  文件必须存在，文件路径必须以Environment.getExternalStorageDirectory().getPath() 的返回值开头
 */
public static void sendScanFileBroadcast(Context context, String filePath) {
        File file = new File(filePath);
        Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.fromFile(file));
        context.sendBroadcast(intent);
}


/**
 * 
 * @param context
 * @param paths File paths to scan 
 * @param mimeTypes mimeTypes in array;it could be null;then 
 * @param callback
 */
public static void scanFiles(Context context, String[] paths, String[] mimeTypes, OnScanCompletedListener callback) {
    if (null != paths &amp;&amp; paths.length != 0) {
        MediaScannerConnection.scanFile(context, paths, mimeTypes, callback);
    } else {
        Log.i(LOGTAG, "scanFiles paths = null or paths.length=0 paths=" + paths);
    }
}

public static void scanFiles(Context context, String[] paths, String[] mimeTypes) {
    scanFiles(context, paths, mimeTypes, null);
}

public static void scanFiles(Context context, String[] paths) {
    scanFiles(context, paths, null);
}

public static int removeImageFromLib(Context context, String filePath) {
    ContentResolver resolver = context.getContentResolver();
    return resolver.delete(Images.Media.EXTERNAL_CONTENT_URI, Images.Media.DATA + "=?", new String[]{filePath});
}

public static int removeAudioFromLib(Context context, String filePath) {
    return context.getContentResolver().delete(Audio.Media.EXTERNAL_CONTENT_URI, 
            Audio.Media.DATA + "=?", new String[] {filePath});
}

public static int removeVideoFromLib(Context context, String filePath) {
    return context.getContentResolver().delete(Video.Media.EXTERNAL_CONTENT_URI, 
            Video.Media.DATA + "=?", new String[] {filePath});

}

public static int removeMediaFromLib(Context context, String filePath) {
    String mimeType = FileUtils.getFileMimeType(filePath);
    int affectedRows = 0;
    if (null != mimeType) {
        mimeType = mimeType.toLowerCase(Locale.US);
        if (isImage(mimeType)) {
            affectedRows = removeImageFromLib(context, filePath);
        } else if (isAudio(mimeType)) {
            affectedRows = removeAudioFromLib(context ,filePath);
        } else if (isVideo(mimeType)) {
            affectedRows = removeVideoFromLib(context, filePath);
        }
    }
    return affectedRows;
}

public static boolean isAudio(String mimeType) {
    return mimeType.startsWith("audio");
}

public static boolean isImage(String mimeType) {
    return mimeType.startsWith("image");
}

public static boolean isVideo(String mimeType) {
    return mimeType.startsWith("video");
}


public static boolean isMediaFile(String filePath) {
    String mimeType = FileUtils.getFileMimeType(filePath);
    return isMediaType(mimeType);
}

public static boolean isMediaType(String mimeType) {
    boolean isMedia = false;
    if (!TextUtils.isEmpty(mimeType)) {
        mimeType = mimeType.toLowerCase(Locale.US);
        isMedia = isImage(mimeType) || isAudio(mimeType) || isVideo(mimeType);
    }
    return isMedia;
}


/**
 * Before using it,please do have a media type check.
 * @param context
 * @param srcPath
 * @param destPath
 * @return
 */
public static int renameMediaFile(Context context, String srcPath, String destPath) {
    removeMediaFromLib(context, srcPath);
    sendScanFileBroadcast(context, destPath);
    return 0;
}
</code></pre>

<p>}</p>

<p>```</p>

<h3>FileUtils.java</h3>

<p>```java</p>

<pre><code>public static String getFileMimeType(String filename) {
    if (TextUtils.isEmpty(filename)) {
        return null;
    }
    int lastDotIndex = filename.lastIndexOf('.');
    String mimetype = MimeTypeMap.getSingleton().getMimeTypeFromExtension(
            filename.substring(lastDotIndex + 1).toLowerCase());
    Log.i(LOGTAG, "getFileMimeType mimeType = " + mimetype);
    return mimetype;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scan Media Files In Android]]></title>
    <link href="http://androidyue.github.io/blog/2014/01/19/scan-media-files-in-android/"/>
    <updated>2014-01-19T19:39:00+08:00</updated>
    <id>http://androidyue.github.io/blog/2014/01/19/scan-media-files-in-android</id>
    <content type="html"><![CDATA[<p>I once tried to use MediaScanner to resolve problems; however it turned out to be a failure. Now I make it.This post is to write down why I failed and how I work it out now. I think it could be deeper that other posts.</p>

<h2>Android Media Scanning Mechanism</h2>

<p>Android provides a great application for developers to add created media files to add them into the library. The application is called MediaProvider. Now let&rsquo;s have a glance of MediaProvider. <br/>
The receiver part of its  manifest
```xml</p>

<pre><code>    &lt;receiver android:name="MediaScannerReceiver"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt;
        &lt;/intent-filter&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MEDIA_MOUNTED" /&gt;
            &lt;data android:scheme="file" /&gt;
        &lt;/intent-filter&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MEDIA_UNMOUNTED" /&gt;
            &lt;data android:scheme="file" /&gt;
        &lt;/intent-filter&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MEDIA_SCANNER_SCAN_FILE" /&gt;
            &lt;data android:scheme="file" /&gt;
        &lt;/intent-filter&gt;
    &lt;/receiver&gt;
</code></pre>

<p>```
The MediaScannerReceiver will receive the above intents with right action and data scheme.</p>

<h3>How the MediaScannerRecieve handles the intent</h3>

<ul>
<li>It will scan internal storage only after receiving the <strong>action android.intent.action.BOOT_COMPLETED</strong></li>
<li>All intent but the <strong>android.intent.action.BOOT_COMPLETED</strong> intent should carry the file scheme data</li>
<li>It will scan external storage when receiving the <strong>Intent.ACTION_MEDIA_MOUNTED</strong> intent.</li>
<li>It will scan the single file when receiving the <strong>Intent.ACTION_MEDIA_SCANNER_SCAN_FILE</strong> intent.

<h3>How the MediaScannerService works</h3>

<p>Actually receiver does not do scanning. It will start a service called MediaScannerService.
The service part of its manifest
<code>xml
    &lt;service android:name="MediaScannerService" android:exported="true"&gt;
         &lt;intent-filter&gt;
             &lt;action android:name="android.media.IMediaScannerService" /&gt;
         &lt;/intent-filter&gt;
     &lt;/service&gt;
</code></p></li>
</ul>


<p>scanFile Method
```java</p>

<pre><code>private Uri scanFile(String path, String mimeType) {
    String volumeName = MediaProvider.EXTERNAL_VOLUME;
    openDatabase(volumeName);
    MediaScanner scanner = createMediaScanner();
    return scanner.scanSingleFile(path, volumeName, mimeType);
}
</code></pre>

<p><code>
scan Method
</code>java</p>

<pre><code>private void scan(String[] directories, String volumeName) {
    // don't sleep while scanning
    mWakeLock.acquire();

    ContentValues values = new ContentValues();
    values.put(MediaStore.MEDIA_SCANNER_VOLUME, volumeName);
    Uri scanUri = getContentResolver().insert(MediaStore.getMediaScannerUri(), values);

    Uri uri = Uri.parse("file://" + directories[0]);
    sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_STARTED, uri));

    try {
        if (volumeName.equals(MediaProvider.EXTERNAL_VOLUME)) {
            openDatabase(volumeName);
        }

        MediaScanner scanner = createMediaScanner();
        scanner.scanDirectories(directories, volumeName);
    } catch (Exception e) {
        Log.e(TAG, "exception in MediaScanner.scan()", e);
    }

    getContentResolver().delete(scanUri, null, null);

    sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, uri));
    mWakeLock.release();
}
</code></pre>

<p><code>
Actually the scan code is not really in the MediaScannerService
</code>java
private MediaScanner createMediaScanner() {</p>

<pre><code>    MediaScanner scanner = new MediaScanner(this);
    Locale locale = getResources().getConfiguration().locale;
    if (locale != null) {
        String language = locale.getLanguage();
        String country = locale.getCountry();
        String localeString = null;
        if (language != null) {
            if (country != null) {
                scanner.setLocale(language + "_" + country);
            } else {
                scanner.setLocale(language);
            }
        }    
    }

    return scanner;
</code></pre>

<p>}
```
It&rsquo;s using the android.media.MediaScanner
<a href="https://android.googlesource.com/platform/frameworks/base/+/cd92588/media/java/android/media/MediaScanner.java">https://android.googlesource.com/platform/frameworks/base/+/cd92588/media/java/android/media/MediaScanner.java</a></p>

<h2>How To Scan A Created File</h2>

<p>Now I am going to introduce two ways to add a created file into the media library.</p>

<h3>The Simplest Method</h3>

<p>Just send a broadcast, as we have posted above. Just send a broadcast intent to MediaScannerReceiver.
```java</p>

<pre><code>String saveAs = "Your_Created_File_Path"
Uri contentUri = Uri.fromFile(new File(saveAs));
Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,contentUri);
getContext().sendBroadcast(mediaScanIntent);
</code></pre>

<p>```
The above method maybe has been seen thousands of times. Actually it should work. However I failed and failed in sending broadcast intent. In the following section. I will point out why the sending broadcast not works. Even though you get well on with sending broadcast,it&rsquo;s strongly recommended to read the Section Why Sending MEDIA_SCANNER_SCAN_FILE broadcast not works.</p>

<h3>Use MediaScannerConnection</h3>

<p>```java</p>

<pre><code>public void mediaScan(File file) {
    MediaScannerConnection.scanFile(getActivity(),
            new String[] { file.getAbsolutePath() }, null,
            new OnScanCompletedListener() {
                @Override
                public void onScanCompleted(String path, Uri uri) {
                    Log.v("MediaScanWork", "file " + path
                            + " was scanned seccessfully: " + uri);
                }
            });
}
</code></pre>

<p>```
the scanFile method is introduced since API 8</p>

<h3>Create an instance and call scanFile (String path, String mimeType)</h3>

<p>It&rsquo;s really easy, just read the post <a href="http://developer.android.com/reference/android/media/MediaScannerConnection.html">http://developer.android.com/reference/android/media/MediaScannerConnection.html</a></p>

<h3>How To Scan Mutiple Files</h3>

<ul>
<li>Sending Mutiple Intent.ACTION_MEDIA_SCANNER_SCAN_FILE broadcast intents.</li>
<li>Use the second method by filled the second params with an array of paths.</li>
</ul>


<h2>Why Sending MEDIA_SCANNER_SCAN_FILE broadcast not works</h2>

<p>Actually someone may think sending ACTION_MEDIA_SCANNER_SCAN_FILE works on some devices but not on other devices. Actually it&rsquo;s. Is it a API limit?<br/>
No, It&rsquo;s has someting to do with your file path.
Take a look at this
```java</p>

<pre><code>public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    Uri uri = intent.getData();
    if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
        // scan internal storage
        scan(context, MediaProvider.INTERNAL_VOLUME);
    } else {
        if (uri.getScheme().equals("file")) {
            // handle intents related to external storage
            String path = uri.getPath();
            String externalStoragePath = Environment.getExternalStorageDirectory().getPath();

            Log.d(TAG, "action: " + action + " path: " + path);
            if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
                // scan whenever any volume is mounted
                scan(context, MediaProvider.EXTERNAL_VOLUME);
            } else if (action.equals(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE) &amp;&amp;
                    path != null &amp;&amp; path.startsWith(externalStoragePath + "/")) {
                scanFile(context, path);
            }
        }
    }
}
</code></pre>

<p><code>
Every part is right except the intent data. I mean the file path. You may hardcode the filepath. This is my example
</code>java</p>

<pre><code>final String saveAs = "/sdcard/" + System.currentTimeMillis() + "_add.png";
Uri contentUri = Uri.fromFile(new File(saveAs));
Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,contentUri);
getContext().sendBroadcast(mediaScanIntent);
Uri uri = mediaScanIntent.getData();
String path = uri.getPath();
String externalStoragePath = Environment.getExternalStorageDirectory().getPath();
Log.i("LOGTAG", "Androidyue onReceive intent= " + mediaScanIntent 
                        + ";path=" + path + ";externalStoragePath=" +
                        externalStoragePath);
</code></pre>

<p><code>
And this is the output log
</code>bash
LOGTAG Androidyue onReceive intent= Intent { act=android.intent.action.MEDIA_SCANNER_SCAN_FILE dat=file:///sdcard/1390136305831_add.png };path=/sdcard/1390136305831_add.png;externalStoragePath=/mnt/sdcard
```
So in the sending broadcast, your action is right, your data schema  OK, your data path not null;but your path  /sdcard/1390136305831_add.png does not <strong>startswith</strong> the externalStoragePath /mnt/sdcard/
And so the scan file is actually <strong>not called</strong>.
In conclusion your hardcoding path results in the failure.</p>

<h2>Remove From Media Library</h2>

<p>If we deleted a file ,it means that we need to remove the file from the media library.</p>

<h3>Simply sending a broadcast?</h3>

<p>Can we simple sending a broadcast to the MediaScannerReceiver? I also wish it could. But actually it does not work.
Look at this code for the explanation.
```java</p>

<pre><code>// this function is used to scan a single file
public Uri scanSingleFile(String path, String volumeName, String mimeType) {
    try {
        initialize(volumeName);
        prescan(path, true);

        File file = new File(path);
        if (!file.exists()) {
            return null;
        }

        // lastModified is in milliseconds on Files.
        long lastModifiedSeconds = file.lastModified() / 1000;

        // always scan the file, so we can return the content://media Uri for existing files
        return mClient.doScanFile(path, mimeType, lastModifiedSeconds, file.length(),
                false, true, MediaScanner.isNoMediaPath(path));
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in MediaScanner.scanFile()", e);
        return null;
    }
}
</code></pre>

<p><code>
As the above code points out, It does have a check before the real scanning.
Then how should I do?
</code>java</p>

<pre><code>public void testDeleteFile() {
    String existingFilePath = "/mnt/sdcard/1390116362913_add.png";
    File  existingFile = new File(existingFilePath);
    existingFile.delete();
    ContentResolver resolver = getActivity().getContentResolver();
    resolver.delete(Images.Media.EXTERNAL_CONTENT_URI, Images.Media.DATA + "=?", new String[]{existingFilePath});

}
</code></pre>

<p>```
The above code works. Just remove from Media Provider</p>

<h2>Special</h2>

<ul>
<li>You could check the external.db or internal.db file under /data/data/com.android.providers.media/ for more detailed information.</li>
</ul>

]]></content>
  </entry>
  
</feed>
