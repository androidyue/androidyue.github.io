<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2016-02-29T19:23:25+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于获取当前Activity的一些思考]]></title>
    <link href="http://droidyue.com/blog/2016/02/21/thinking-of-getting-the-current-activity-in-android/"/>
    <updated>2016-02-21T20:53:00+08:00</updated>
    <id>http://droidyue.com/blog/2016/02/21/thinking-of-getting-the-current-activity-in-android</id>
    <content type="html"><![CDATA[<p>在Android开发过程中，我们有时候需要获取当前的Activity实例，比如弹出Dialog操作，必须要用到这个。关于如何实现由很多种思路，这其中有的简单，有的复杂，这里简单总结一下个人的一些经验吧。</p>

<!--more-->


<h2>反射</h2>

<p>反射是我们经常会想到的方法，思路大概为</p>

<p>  1 获取ActivityThread中所有的ActivityRecord <br/>
  2 从ActivityRecord中获取状态不是<code>pause</code>的Activity并返回</p>

<p>一个使用反射来实现的代码大致如下
```java</p>

<pre><code>public static Activity getActivity() {
    Class activityThreadClass = null;
    try {
        activityThreadClass = Class.forName("android.app.ActivityThread");
        Object activityThread = activityThreadClass.getMethod("currentActivityThread").invoke(null);
        Field activitiesField = activityThreadClass.getDeclaredField("mActivities");
        activitiesField.setAccessible(true);
        Map activities = (Map) activitiesField.get(activityThread);
        for (Object activityRecord : activities.values()) {
            Class activityRecordClass = activityRecord.getClass();
            Field pausedField = activityRecordClass.getDeclaredField("paused");
            pausedField.setAccessible(true);
            if (!pausedField.getBoolean(activityRecord)) {
                Field activityField = activityRecordClass.getDeclaredField("activity");
                activityField.setAccessible(true);
                Activity activity = (Activity) activityField.get(activityRecord);
                return activity;
            }
        }
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } catch (NoSuchMethodException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (InvocationTargetException e) {
        e.printStackTrace();
    } catch (NoSuchFieldException e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>

<p>```</p>

<p>然而这种方法并不是很推荐，主要是有以下的不足：</p>

<ul>
<li>反射通常会比较慢</li>
<li>不稳定性，这个才是不推荐的原因，Android框架代码存在修改的可能性，谁要无法100%保证<code>mActivities</code>，<code>paused</code>固定不变。所以可靠性不是完全可靠。</li>
</ul>


<h2>Activity基类</h2>

<p>既然反射不是很可靠，那么有一种比较可靠的方式，就是使用Activity基类。</p>

<p>在Activity的<code>onResume</code>方法中，将当前的Activity实例保存到一个变量中。
```java
public class BaseActivity extends Activity{</p>

<pre><code>@Override
protected void onResume() {
    super.onResume();
    MyActivityManager.getInstance().setCurrentActivity(this);
}
</code></pre>

<p>}
```</p>

<p>然而，这一种方法也不仅完美，因为这种方法是基于约定的，所以必须每个Activity都继承BaseActivity，如果一旦出现没有继承BaseActivity的就可能有问题。</p>

<h2>回调方法</h2>

<p>介绍了上面两种不是尽善尽美的方法，这里实际上还是有一种更便捷的方法，那就是通过Framework提供的回调来实现。</p>

<p>Android自 API 14开始引入了一个方法，即Application的<code>registerActivityLifecycleCallbacks</code>方法，用来监听所有Activity的生命周期回调，比如<code>onActivityCreated</code>,<code>onActivityResumed</code>等。</p>

<p>So，一个简单的实现如下
```java
public class MyApplication extends Application {</p>

<pre><code>@Override
public void onCreate() {
    super.onCreate();
    registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {
        @Override
        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {

        }

        @Override
        public void onActivityStarted(Activity activity) {

        }

        @Override
        public void onActivityResumed(Activity activity) {
            MyActivityManager.getInstance().setCurrentActivity(activity);
        }

        @Override
        public void onActivityPaused(Activity activity) {

        }

        @Override
        public void onActivityStopped(Activity activity) {

        }

        @Override
        public void onActivitySaveInstanceState(Activity activity, Bundle outState) {

        }

        @Override
        public void onActivityDestroyed(Activity activity) {

        }
    });
}
</code></pre>

<p>}
```</p>

<p>然而，金无足赤人无完人，这种方法唯一的遗憾就是只支持API 14即其以上。不过还在现在大多数设备都满足了这个要求。</p>

<h3>为什么是弱引用</h3>

<p>可能有人会带着疑问看到这里，MyActivityManager是个什么鬼，好，我们现在看一下这个类的实现
```java
public class MyActivityManager {</p>

<pre><code>private static MyActivityManager sInstance = new MyActivityManager();
private WeakReference&lt;Activity&gt; sCurrentActivityWeakRef;


private MyActivityManager() {

}

public static MyActivityManager getInstance() {
    return sInstance;
}

public Activity getCurrentActivity() {
    Activity currentActivity = null;
    if (sCurrentActivityWeakRef != null) {
        currentActivity = sCurrentActivityWeakRef.get();
    }
    return currentActivity;
}

public void setCurrentActivity(Activity activity) {
    sCurrentActivityWeakRef = new WeakReference&lt;Activity&gt;(activity);
}
</code></pre>

<p>}
```</p>

<p>这个类，实现了当前Activity的设置和获取。</p>

<p>那么为什么要使用弱引用持有Activity实例呢？</p>

<p>其实最主要的目的就是避免内存泄露，因为使用默认的强引用会导致Activity实例无法释放，导致内存泄露的出现。详细了解弱引用，请参考本文<a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">译文：理解Java中的弱引用</a></p>

<h2>Demo源码</h2>

<ul>
<li><a href="https://github.com/androidyue/GetCurrentActivityDemo">GetCurrentActivityDemo</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[聊一聊Android 6.0的运行时权限]]></title>
    <link href="http://droidyue.com/blog/2016/01/17/understanding-marshmallow-runtime-permission/"/>
    <updated>2016-01-17T20:40:00+08:00</updated>
    <id>http://droidyue.com/blog/2016/01/17/understanding-marshmallow-runtime-permission</id>
    <content type="html"><![CDATA[<p>Android 6.0，代号棉花糖，自发布伊始，其主要的特征运行时权限就很受关注。因为这一特征不仅改善了用户对于应用的使用体验，还使得应用开发者在实践开发中需要做出改变。</p>

<p>没有深入了解运行时权限的开发者通常会有很多疑问，比如什么是运行时权限，哪些是运行时的权限，我的应用是不是会在6.0系统上各种崩溃呢，如何才能支持运行时权限机制呢。本文讲尝试回答这一些问题，希望读者阅读完成之后，都能找到较为完美的答案。</p>

<!--more-->


<h2>权限一刀切</h2>

<p>在6.0以前的系统，都是权限一刀切的处理方式，<strong>只要用户安装，Manifest申请的权限都会被赋予，并且安装后权限也撤销不了</strong>。<br/>
这种情况下，当我们从Google Play安装一个应用，在安装之前会得到这样的权限提示信息。</p>

<p><img src="http://7jpolu.com1.z0.glb.clouddn.com/pre-marshmallow-permission.jpg" alt="Permission" /></p>

<p>当上述对话框弹出后，用户只有两种选择：</p>

<ul>
<li>我信任你，即使有敏感权限</li>
<li>你一个**应用，要这个权限干嘛，我还是不安装了。</li>
</ul>


<p>所以，这种一刀切的处理方式还是有弊端的，我们没有办法只允许某些权限或者拒绝某些权限。</p>

<h2>棉花糖运行时权限</h2>

<p>从棉花糖开始，Android系统引入了新的权限机制，即本文要讲的运行时权限。</p>

<p>何为运行时权限呢？举个栗子，以某个需要拍照的应用为例，当运行时权限生效时，其Camera权限不是在安装后赋予，而是在应用运行的时候进行请求权限（比如当用户按下”相机拍照“按钮后）看到的效果则是这样的</p>

<p><img src="http://7jpolu.com1.z0.glb.clouddn.com/marshmallow-permission.png" alt="Requesting Camera Permission" /></p>

<p>接下来，对于Camera权限的处理完全权交给用户。是不是有点像苹果系统的处理呢，不要说这是抄袭，暂且称为师夷长技以制夷。</p>

<h2>权限的分组</h2>

<p>Android中有很多权限，但并非所有的权限都是敏感权限，于是6.0系统就对权限进行了分类，一般为下述几类</p>

<ul>
<li>正常(Normal Protection)权限</li>
<li>危险(Dangerous)权限</li>
<li>特殊(Particular)权限</li>
<li>其他权限（一般很少用到）</li>
</ul>


<h2>正常权限</h2>

<p>正常权限具有如下的几个特点</p>

<ul>
<li>对用户隐私没有较大影响或者不会打来安全问题。</li>
<li>安装后就赋予这些权限，<strong>不需要显示提醒用户，用户也不能取消这些权限</strong>。</li>
</ul>


<h3>正常权限列表</h3>

<p><code>java
ACCESS_LOCATION_EXTRA_COMMANDS
ACCESS_NETWORK_STATE
ACCESS_NOTIFICATION_POLICY
ACCESS_WIFI_STATE
BLUETOOTH
BLUETOOTH_ADMIN
BROADCAST_STICKY
CHANGE_NETWORK_STATE
CHANGE_WIFI_MULTICAST_STATE
CHANGE_WIFI_STATE
DISABLE_KEYGUARD
EXPAND_STATUS_BAR
GET_PACKAGE_SIZE
INTERNET
KILL_BACKGROUND_PROCESSES
MODIFY_AUDIO_SETTINGS
NFC
READ_SYNC_SETTINGS
READ_SYNC_STATS
RECEIVE_BOOT_COMPLETED
REORDER_TASKS
REQUEST_INSTALL_PACKAGES
SET_TIME_ZONE
SET_WALLPAPER
SET_WALLPAPER_HINTS
TRANSMIT_IR
USE_FINGERPRINT
VIBRATE
WAKE_LOCK
WRITE_SYNC_SETTINGS
SET_ALARM
INSTALL_SHORTCUT
UNINSTALL_SHORTCUT
</code>
上述的权限基本设计的是关于网络，蓝牙，时区，快捷方式等方面，只要在Manifest指定了这些权限，就会被授予，并且不能撤销。</p>

<h2>特殊权限</h2>

<p>这里讲特殊权限提前讲一下，因为这个相对来说简单一些。</p>

<p>特殊权限，顾名思义，就是一些特别敏感的权限，在Android系统中，主要由两个</p>

<ul>
<li>SYSTEM_ALERT_WINDOW，设置悬浮窗，进行一些黑科技</li>
<li>WRITE_SETTINGS  修改系统设置</li>
</ul>


<p>关于上面两个特殊权限的授权，做法是使用<code>startActivityForResult</code>启动授权界面来完成。</p>

<h3>请求SYSTEM_ALERT_WINDOW</h3>

<p>```java
private static final int REQUEST_CODE = 1;
private  void requestAlertWindowPermission() {</p>

<pre><code>Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);
intent.setData(Uri.parse("package:" + getPackageName()));
startActivityForResult(intent, REQUEST_CODE);
</code></pre>

<p>}</p>

<p>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {</p>

<pre><code>super.onActivityResult(requestCode, resultCode, data);
if (requestCode == REQUEST_CODE) {
    if (Settings.canDrawOverlays(this)) {
        Log.i(LOGTAG, "onActivityResult granted");
    }
}
</code></pre>

<p>}
```</p>

<p>上述代码需要注意的是</p>

<ul>
<li>使用Action <code>Settings.ACTION_MANAGE_OVERLAY_PERMISSION</code>启动隐式Intent</li>
<li>使用<code>"package:" + getPackageName()</code>携带App的包名信息</li>
<li>使用<code>Settings.canDrawOverlays</code>方法判断授权结果</li>
</ul>


<h3>请求WRITE_SETTINGS</h3>

<p>```java
private static final int REQUEST_CODE_WRITE_SETTINGS = 2;
private void requestWriteSettings() {</p>

<pre><code>Intent intent = new Intent(Settings.ACTION_MANAGE_WRITE_SETTINGS);
intent.setData(Uri.parse("package:" + getPackageName()));
startActivityForResult(intent, REQUEST_CODE_WRITE_SETTINGS );
</code></pre>

<p>}
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {</p>

<pre><code>super.onActivityResult(requestCode, resultCode, data);
if (requestCode == REQUEST_CODE_WRITE_SETTINGS) {
    if (Settings.System.canWrite(this)) {
        Log.i(LOGTAG, "onActivityResult write settings granted" );
    }
}
</code></pre>

<p>}
```</p>

<p>上述代码需要注意的是</p>

<ul>
<li>使用Action <code>Settings.ACTION_MANAGE_WRITE_SETTINGS</code> 启动隐式Intent</li>
<li>使用<code>"package:" + getPackageName()</code>携带App的包名信息</li>
<li>使用<code>Settings.System.canWrite</code>方法检测授权结果</li>
</ul>


<p>注意：关于这两个特殊权限，一般不建议应用申请。</p>

<h2>危险权限</h2>

<p>危险权限实际上才是运行时权限主要处理的对象，这些权限可能引起隐私问题或者影响其他程序运行。Android中的危险权限可以归为以下几个分组：</p>

<ul>
<li>CALENDAR</li>
<li>CAMERA</li>
<li>CONTACTS</li>
<li>LOCATION</li>
<li>MICROPHONE</li>
<li>PHONE</li>
<li>SENSORS</li>
<li>SMS</li>
<li>STORAGE</li>
</ul>


<p>各个权限分组与其具体的权限，可以参考下图：</p>

<p><img src="http://ww4.sinaimg.cn/large/6a195423jw1ezwpc11cs0j20hr0majwm.jpg" alt="Permission Groups and detailed permissions" /></p>

<h2>必须要支持运行时权限么</h2>

<p>目前应用实际上是可以不需要支持运行时权限的，但是最终肯定还是需要支持的，只是时间问题而已。</p>

<p>想要不支持运行时权限机制很简单，只需要将<code>targetSdkVersion</code>设置低于23就可以了，意思是告诉系统，我还没有完全在API 23（6.0）上完全搞定，不要给我启动新的特性。</p>

<h2>不支持运行时权限会崩溃么</h2>

<p>可能会，但不是那种一上来就噼里啪啦崩溃不断的那种。</p>

<p>如果你的应用将<code>targetSdkVersion</code>设置低于23，那么在6.0的系统上不会为这个应用开启运行时权限机制，即按照以前的一刀切方式处理。</p>

<h3>然而有点糟糕的是</h3>

<p>6.0系统提供了一个应用权限管理界面，界面长得是这样的</p>

<p><img class="<a" src="href="http://ww2.sinaimg.cn/large/6a195423jw1ezwqnmjhcdj20u01hc40k.jpg">http://ww2.sinaimg.cn/large/6a195423jw1ezwqnmjhcdj20u01hc40k.jpg</a>" width="300"></p>

<p>既然是可以管理，用户就能取消权限，当一个不支持运行时权限的应用某项权限被取消时</p>

<p><img class="<a" src="href="http://ww4.sinaimg.cn/large/6a195423jw1ezwqaftmpgj20u01hc77e.jpg">http://ww4.sinaimg.cn/large/6a195423jw1ezwqaftmpgj20u01hc77e.jpg</a>" width="300"></p>

<p>系统会弹出一个对话框提醒撤销的危害，如果用户执意撤销，会带来如下的反应</p>

<ul>
<li>如果你的程序正在运行，则会被杀掉。</li>
<li>当你的应用再次运行时，可能出现崩溃</li>
</ul>


<p>为什么会可能崩溃的，比如下面这段代码
<code>
TelephonyManager telephonyManager = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);
String deviceId = telephonyManager.getDeviceId();
if (deviceId.equals(mLastDeviceId)) {//This may cause NPE
  //do something
}
</code>
如果用户撤消了获取DeviceId的权限，那么再次运行时,deviceId就是null，如果程序后续处理不当，就会出现崩溃。</p>

<h2>该来的还得来</h2>

<p>6.0的运行时权限，我们最终都是要支持的，通常我们需要使用如下的API</p>

<ul>
<li><strong>int checkSelfPermission(String permission)</strong> 用来检测应用是否已经具有权限</li>
<li><strong>void requestPermissions(String[] permissions, int requestCode)</strong>  进行请求单个或多个权限</li>
<li><strong>void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults)</strong> 用户对请求作出响应后的回调</li>
</ul>


<p>以一个请求Camera权限为例
```java</p>

<pre><code>@Override
public void onClick(View v) {
    if (!(checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED)) {
        requestCameraPermission();
    }
}

private static final int REQUEST_PERMISSION_CAMERA_CODE = 1;
private void requestCameraPermission() {
    requestPermissions(new String[]{Manifest.permission.CAMERA}, REQUEST_PERMISSION_CAMERA_CODE);
}

@Override
public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    if (requestCode == REQUEST_PERMISSION_CAMERA_CODE) {
        int grantResult = grantResults[0];
        boolean granted = grantResult == PackageManager.PERMISSION_GRANTED;
        Log.i(LOGTAG, "onRequestPermissionsResult granted=" + granted);
    }
}
</code></pre>

<p>```</p>

<p>通常情况下，我们会得到这样的一个对话框</p>

<p><img class="<a" src="href="http://ww1.sinaimg.cn/large/6a195423jw1ezwtttfjp1j20u01hc0vr.jpg">http://ww1.sinaimg.cn/large/6a195423jw1ezwtttfjp1j20u01hc0vr.jpg</a>" width="300"></p>

<p><strong>当用户选择允许，我们就可以在onRequestPermissionsResult方法中进行响应的处理，比如打开摄像头</strong><br/>
<strong>当用户拒绝，你的应用可能就开始危险了</strong></p>

<p>当我们再次尝试申请权限时，弹出的对话框和之前有点不一样了，主要表现为多了一个checkbox。如下图</p>

<p><img class="<a" src="href="http://ww1.sinaimg.cn/large/6a195423jw1ezwtz1ljjgj20u01hcad8.jpg">http://ww1.sinaimg.cn/large/6a195423jw1ezwtz1ljjgj20u01hcad8.jpg</a>" width="300"></p>

<p>当用户勾选了”不再询问“拒绝后，你的程序基本这个权限就Game Over了。</p>

<p>不过，你还有一丝希望，那就是再出现上述的对话框之前做一些说明信息，比如你使用这个权限的目的（一定要坦白）。</p>

<p>shouldShowRequestPermissionRationale这个API可以帮我们判断接下来的对话框是否包含”不再询问“选择框。</p>

<h3>一个标准的流程</h3>

<p>```java
if (!(checkSelfPermission(Manifest.permission.READ_CONTACTS) == PackageManager.PERMISSION_GRANTED)) {
  if (shouldShowRequestPermissionRationale(Manifest.permission.READ_CONTACTS)) {</p>

<pre><code>  Toast.makeText(this, "Please grant the permission this time", Toast.LENGTH_LONG).show();
}
requestReadContactsPermission();
</code></pre>

<p>} else {
  Log.i(LOGTAG, &ldquo;onClick granted&rdquo;);
}
```</p>

<h3>如何批量申请</h3>

<p>批量申请权限很简单，只需要字符串数组放置多个权限即可。如请求代码
```java
private static final int REQUEST_CODE = 1;
private void requestMultiplePermissions() {</p>

<pre><code>String[] permissions = {Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_PHONE_STATE};
requestPermissions(permissions, REQUEST_CODE);
</code></pre>

<p>}
```
对应的界面效果是
<img src="http://ww2.sinaimg.cn/large/6a195423jw1ezxulzbeu2j20iq0ggt9y.jpg" alt="Multiple Requesting Permissions" /></p>

<p>注意：间隔较短的多个权限申请建议设置成单次多个权限申请形式，避免弹出多个对话框，造成不太好的视觉效果。</p>

<h3>申请这么多权限岂不是很累</h3>

<p>其实你不需要每个权限都去显式申请，举一个例子，如果你的应用授权了读取联系人的权限，那么你的应用也是被赋予了写入联系人的权限。因为读取联系人和写入联系人这两个权限都属于联系人权限分组，所以一旦组内某个权限被允许，该组的其他权限也是被允许的。</p>

<h2>注意事项</h2>

<h3>API问题</h3>

<p>由于checkSelfPermission和requestPermissions从API 23才加入，低于23版本，需要在运行时判断 或者使用Support Library v4中提供的方法</p>

<ul>
<li>ContextCompat.checkSelfPermission</li>
<li>ActivityCompat.requestPermissions</li>
<li>ActivityCompat.shouldShowRequestPermissionRationale</li>
</ul>


<h3>多系统问题</h3>

<p>当我们支持了6.0必须也要支持4.4，5.0这些系统，所以需要在很多情况下，需要有两套处理。比如Camera权限
```java
if (isMarshmallow()) {</p>

<pre><code>requestPermission();//然后在回调中处理
</code></pre>

<p>} else {</p>

<pre><code>useCamera();//低于6.0直接使用Camera
</code></pre>

<p>}
```</p>

<h2>两个权限</h2>

<p>运行时权限对于应用影响比较大的权限有两个，他们分别是</p>

<ul>
<li>READ_PHONE_STATE</li>
<li>WRITE_EXTERNAL_STORAGE/READ_EXTERNAL_STORAGE</li>
</ul>


<p>其中READ_PHONE_STATE用来获取deviceID，即IMEI号码。这是很多统计依赖计算设备唯一ID的参考。如果新的权限导致读取不到，避免导致统计的异常。建议在完全支持运行时权限之前，将对应的值写入到App本地数据中，对于新安装的，可以采取其他策略减少对统计的影响。</p>

<p>WRITE_EXTERNAL_STORAGE/READ_EXTERNAL_STORAGE这两个权限和外置存储（即sdcard）有关，对于下载相关的应用这一点还是比较重要的，我们应该尽可能的说明和引导用户授予该权限。</p>

<h2>些许建议</h2>

<ul>
<li>不要使用多余的权限，新增权限时要慎重</li>
<li>使用Intent来替代某些权限，如拨打电话（和你的产品经理PK去吧）</li>
<li>对于使用权限获取的某些值，比如deviceId，尽量本地存储，下次访问直接使用本地的数据值</li>
<li>注意，由于用户可以撤销某些权限，所以不要使用应用本地的标志位来记录是否获取到某权限。</li>
</ul>


<h2>注意</h2>

<p>即使支持了运行时权限，也要在Manifest声明，因为市场应用会根据这个信息和硬件设备进行匹配，决定你的应用是否在该设备上显示。</p>

<h2>是否支持运行时权限</h2>

<p>个人觉得Marshmallow的运行时权限对于用户来说绝对是一个好东西，但是目前想要支持需要做的事情还是比较多的。</p>

<p>对于一个有很多依赖的宿主应用，想要做到支持还是有一些工作量的，因为你的权限申请受制于依赖。</p>

<p>建议在短期内暂时可以不考虑支持该运行时权限机制,等时机成熟或者简单易用的第三方库完善之后再支持也未尝不可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修复Android中Navigation Bar遮挡PopupWindow的问题]]></title>
    <link href="http://droidyue.com/blog/2016/01/10/android-navigation-bar-popupwindow-issue/"/>
    <updated>2016-01-10T14:41:00+08:00</updated>
    <id>http://droidyue.com/blog/2016/01/10/android-navigation-bar-popupwindow-issue</id>
    <content type="html"><![CDATA[<p>最近遇到了一个问题，关于Navigation Bar遮挡PopupWindow的问题，问题不难，粗略做一点总结。</p>

<!--more-->


<h2>现象描述</h2>

<ul>
<li>问题应该出现在5.0 Lollipop版本及以上</li>
<li>遮挡的现象如下图,Navigation Bar位于了PopupWindow的上层，明显是一种问题。</li>
</ul>


<p><img src="http://7jpolu.com1.z0.glb.clouddn.com/navigation_issue.png" alt="Android Navigation Bar Issue" /></p>

<h2>我的实现代码</h2>

<p>```java
private void showPopupWindow() {</p>

<pre><code>if (mPopupWindow == null) {
    View contentView = LayoutInflater.from(this).inflate(R.layout.popup_window_content, null);
    mPopupWindow = new PopupWindow(contentView, LinearLayout.LayoutParams.MATCH_PARENT,500, true);
    mPopupWindow.setBackgroundDrawable(new BitmapDrawable());
}
mPopupWindow.showAtLocation(findViewById(R.id.contentContainer), Gravity.BOTTOM, 0,0);
</code></pre>

<p>}
```
<strong>其实和具体的实现代码没有关系</strong>，重点是修改主题style。</p>

<h2>修改style</h2>

<p>修改v21/styles.xml(如没有，可以创建),将<code>android:windowDrawsSystemBarBackgrounds</code>修改为<code>false</code>。</p>

<p>```xml</p>



<p>```</p>

<h2>修改好的效果</h2>

<p><img src="http://7jpolu.com1.z0.glb.clouddn.com/navigation_bar_good.png" alt="Good PopupWindow" /></p>

<h2>更佳的方法</h2>

<p>感谢来自Github的网友提出了一个更优秀的方案。很简单，设置如下代码即可
<code>java
popupWindow.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
</code>
注意：这个方法不会影响到状态栏的颜色改变，而第一种方法会。</p>

<h2>demo源码</h2>

<p><a href="https://github.com/androidyue/Navigation-Bar-Issue-Demo">Navigation Bar Issue Demo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Android中工作者线程的思考]]></title>
    <link href="http://droidyue.com/blog/2015/12/20/worker-thread-in-android/"/>
    <updated>2015-12-20T10:47:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/12/20/worker-thread-in-android</id>
    <content type="html"><![CDATA[<h2>版权说明</h2>

<p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/android-worker-thread">http://www.infoq.com/cn/articles/android-worker-thread</a> 如需转载，请与 InfoQ 中文站联系。</p>

<h2>摘要</h2>

<p>在Android开发过程中，我们经常使用工作者线程，如AsyncTask和线程池。然而我们经常使用的这些工作者线程存在哪些不易察觉的问题呢，关于工作者线程有哪些优化呢，文本将逐一介绍并回答这些问题。</p>

<p>本文系2015 北京 GDG Devfest分享内容文章。</p>

<p>在Android中，我们或多或少使用了工作者线程，比如Thread，AsyncTask，HandlerThread，甚至是自己创建的线程池，使用工作者线程我们可以将耗时的操作从主线程中移走。然而在Android系统中为什么存在工作者线程呢，常用的工作者线程有哪些不易察觉的问题呢，关于工作者线程有哪些优化的方面呢，本文将一一解答这些问题。</p>

<!--more-->


<h2>工作者线程的存在原因</h2>

<ul>
<li>因为Android的UI单线程模型，所有的UI相关的操作都需要在主线程(UI线程)执行</li>
<li>Android中各大组件的生命周期回调都是位于主线程中，使得主线程的职责更重</li>
<li>如果不使用工作者线程为主线程分担耗时的任务，会造成应用卡顿，严重时可能出现ANR(Application Not Responding),即程序未响应。</li>
</ul>


<p>因而，在Android中使用工作者线程显得势在必行，如一开始提到那样，在Android中工作者线程有很多，接下来我们将围绕AsyncTask，HandlerThread等深入研究。</p>

<h2>AsyncTask</h2>

<p>AsyncTask是Android框架提供给开发者的一个辅助类，使用该类我们可以轻松的处理异步线程与主线程的交互，由于其便捷性，在Android工程中，AsyncTask被广泛使用。然而AsyncTask并非一个完美的方案，使用它往往会存在一些问题。接下来将逐一列举AsyncTask不容易被开发者察觉的问题。</p>

<h3>AsyncTask与内存泄露</h3>

<p>内存泄露是Android开发中常见的问题，只要开发者稍有不慎就有可能导致程序产生内存泄露，严重时甚至可能导致OOM(OutOfMemory，即内存溢出错误)。AsyncTask也不例外，也有可能造成内存泄露。</p>

<p>以一个简单的场景为例：
在Activity中，通常我们这样使用AsyncTask
```java
//In Activity
new AsyncTask&lt;String, Void, Void>() {</p>

<pre><code>@Override
protected Void doInBackground(String... params) {
    //some code
    return null;
}
</code></pre>

<p>}.execute(&ldquo;hello world&rdquo;);
<code>``
上述代码使用的匿名内存类创建AsyncTask实例，然而在Java中，</code>非静态内存类会隐式持有外部类的实例引用`，上面例子AsyncTask创建于Activity中，因而会隐式持有Activity的实例引用。</p>

<p>而在AsyncTask内部实现中,mFuture同样使用匿名内部类创建对象，而mFuture会作为执行任务加入到任务执行器中。
```
private final WorkerRunnable&lt;Params, Result> mWorker;
public AsyncTask() {</p>

<pre><code>mFuture = new FutureTask&lt;Result&gt;(mWorker) {
    @Override
    protected void done() {
        //some code
    }
};
</code></pre>

<p>}
<code>
而mFuture加入任务执行器，实际上是放入了一个静态成员变量SERIAL_EXECUTOR指向的对象SerialExecutor的一个ArrayDeque类型的集合中。
</code>java
public static final Executor SERIAL_EXECUTOR = new SerialExecutor();
private static class SerialExecutor implements Executor {</p>

<pre><code>    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();

public synchronized void execute(final Runnable r) {
    mTasks.offer(new Runnable() {
        public void run() {
            //fake code
            r.run();
        }
    });
}
</code></pre>

<p>}
```</p>

<p>当任务处于排队状态，则Activity实例引用被静态常量SERIAL_EXECUTOR 间接持有。</p>

<p>在通常情况下，当设备发生屏幕旋转事件，当前的Activity被销毁，新的Activity被创建，以此完成对布局的重新加载。</p>

<p>而本例中，当屏幕旋转时，处于排队的AsyncTask由于其对Activity实例的引用关系，导致这个Activity不能被销毁，其对应的内存不能被GC回收，因而就出现了内存泄露问题。</p>

<p>关于如何避免内存泄露，我们可以使用静态内部类 + 弱引用的形式解决。</p>

<h3>cancel的问题</h3>

<p>AsyncTask作为任务，是支持调用者取消任务的，即允许我们使用AsyncTask.canncel()方法取消提交的任务。然而其实cancel并非真正的起作用。</p>

<p>首先，我们看一下cancel方法：
```java
public final boolean cancel(boolean mayInterruptIfRunning) {</p>

<pre><code>mCancelled.set(true);
return mFuture.cancel(mayInterruptIfRunning);
</code></pre>

<p>}
<code>``
cancel方法接受一个boolean类型的参数，名称为</code>mayInterruptIfRunning`，意思是是否可以打断正在执行的任务。</p>

<p>当我们调用cancel(false)，不打断正在执行的任务，对应的结果是</p>

<ul>
<li>处于doInBackground中的任务不受影响，继续执行</li>
<li>任务结束时不会去调用<code>onPostExecute</code>方法，而是执行<code>onCancelled</code>方法</li>
</ul>


<p>当我们调用cancel(true)，表示打断正在执行的任务，会出现如下情况：</p>

<ul>
<li>如果doInBackground方法处于阻塞状态，如调用Thread.sleep,wait等方法，则会抛出InterruptedException。</li>
<li>对于某些情况下，有可能无法打断正在执行的任务</li>
</ul>


<p>如下，就是一个cancel方法无法打断正在执行的任务的例子
```
AsyncTask&lt;String,Void,Void> task = new AsyncTask&lt;String, Void, Void>() {</p>

<pre><code>@Override
protected Void doInBackground(String... params) {
    boolean loop = true;
    while(loop) {
        Log.i(LOGTAG, "doInBackground after interrupting the loop");
    }
    return null;
}
</code></pre>

<p>}</p>

<p>task.execute(&ldquo;hello world&rdquo;);
try {</p>

<pre><code>Thread.sleep(2000);//确保AsyncTask任务执行
task.cancel(true);
</code></pre>

<p>} catch (InterruptedException e) {</p>

<pre><code>e.printStackTrace();
</code></pre>

<p>}
<code>``
上面的例子，如果想要使cancel正常工作需要在循环中，需要在循环条件里面同时检测</code>isCancelled()`才可以。</p>

<h3>串行带来的问题</h3>

<p>Android团队关于AsyncTask执行策略进行了多次修改，修改大致如下：
  * 自最初引入到Donut(1.6)之前，任务串行执行
  * 从Donut到GINGERBREAD_MR1(2.3.4),任务被修改成了并行执行
  * 从HONEYCOMB（3.0）至今，任务恢复至串行，但可以设置<code>executeOnExecutor()</code>实现并行执行。</p>

<p>然而AsyncTask的串行实际执行起来是这样的逻辑</p>

<ul>
<li>由串行执行器控制任务的初始分发</li>
<li>并行执行器一次执行单个任务，并启动下一个</li>
</ul>


<p>在AsyncTask中，并发执行器实际为ThreadPoolExecutor的实例，其CORE_POOL_SIZE为当前设备CPU数量+1，MAXIMUM_POOL_SIZE值为CPU数量的2倍 + 1。</p>

<p>以一个四核手机为例，当我们持续调用AsyncTask任务过程中</p>

<ul>
<li>在AsyncTask线程数量小于CORE_POOL_SIZE(5个)时，会启动新的线程处理任务，不重用之前空闲的线程</li>
<li>当数量超过CORE_POOL_SIZE(5个)，才开始重用之前的线程处理任务</li>
</ul>


<p>但是由于AsyncTask属于默认线性执行任务，导致并发执行器总是处于某一个线程工作的状态，因而造成了ThreadPool中其他线程的浪费。同时由于AsyncTask中并不存在allowCoreThreadTimeOut(boolean)的调用，所以ThreadPool中的核心线程即使处于空闲状态也不会销毁掉。</p>

<h2>Executors</h2>

<p>Executors是Java API中一个快速创建线程池的工具类，然而在它里面也是存在问题的。</p>

<p>以Executors中获取一个固定大小的线程池方法为例
```java
public static ExecutorService newFixedThreadPool(int nThreads) {</p>

<pre><code>return new ThreadPoolExecutor(nThreads, nThreads,0L, 
    TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());
</code></pre>

<p>}
```
在上面代码实现中，CORE_POOL_SIZE和MAXIMUM_POOL_SIZE都是同样的值，如果把nThreads当成核心线程数，则无法保证最大并发，而如果当做最大并发线程数，则会造成线程的浪费。因而Executors这样的API导致了我们无法在最大并发数和线程节省上做到平衡。</p>

<p>为了达到最大并发数和线程节省的平衡，建议自行创建ThreadPoolExecutor，根据业务和设备信息确定CORE_POOL_SIZE和MAXIMUM_POOL_SIZE的合理值。</p>

<h2>HandlerThread</h2>

<p>HandlerThread是Android中提供特殊的线程类，使用这个类我们可以轻松创建一个带有Looper的线程，同时利用Looper我们可以结合Handler实现任务的控制与调度。以Handler的post方法为例，我们可以封装一个轻量级的任务处理器
```java
private Handler mHandler;
private LightTaskManager() {</p>

<pre><code>HandlerThread workerThread = new HandlerThread("LightTaskThread");
workerThread.start();
mHandler = new Handler(workerThread.getLooper());
</code></pre>

<p>}</p>

<p>public void post(Runnable run) {</p>

<pre><code>mHandler.post(run);
</code></pre>

<p>}</p>

<p>public void postAtFrontOfQueue(Runnable runnable) {</p>

<pre><code>mHandler.postAtFrontOfQueue(runnable);
</code></pre>

<p>}</p>

<p>public void postDelayed(Runnable runnable, long delay) {</p>

<pre><code>mHandler.postDelayed(runnable, delay);
</code></pre>

<p>}</p>

<p>public void postAtTime(Runnable runnable, long time) {</p>

<pre><code>mHandler.postAtTime(runnable, time);
</code></pre>

<p>}
```
在本例中，我们可以按照如下规则提交任务</p>

<ul>
<li>post 提交优先级一般的任务</li>
<li>postAtFrontOfQueue 将优先级较高的任务加入到队列前端</li>
<li>postAtTime 指定时间提交任务</li>
<li>postDelayed 延后提交优先级较低的任务</li>
</ul>


<p>上面的轻量级任务处理器利用HandlerThread的单一线程 + 任务队列的形式，可以处理类似本地IO（文件或数据库读取）的轻量级任务。在具体的处理场景下，可以参考如下做法：</p>

<ul>
<li>对于本地IO读取，并显示到界面，建议使用postAtFrontOfQueue</li>
<li>对于本地IO写入，不需要通知界面，建议使用postDelayed</li>
<li>一般操作，可以使用post</li>
</ul>


<h2>线程优先级调整</h2>

<p>在Android应用中，将耗时任务放入异步线程是一个不错的选择，那么为异步线程调整应有的优先级则是一件锦上添花的事情。众所周知，线程的并行通过CPU的时间片切换实现，对线程优先级调整，最主要的策略就是降低异步线程的优先级，从而使得主线程获得更多的CPU资源。</p>

<p>Android中的线程优先级和Linux系统进程优先级有些类似，其值都是从-20至19。其中Android中，开发者可以控制的优先级有：</p>

<ul>
<li><code>THREAD_PRIORITY_DEFAULT</code>，默认的线程优先级，值为0</li>
<li><code>THREAD_PRIORITY_LOWEST</code>，最低的线程级别，值为19</li>
<li><code>THREAD_PRIORITY_BACKGROUND</code> 后台线程建议设置这个优先级，值为10</li>
<li><code>THREAD_PRIORITY_MORE_FAVORABLE</code> 相对<code>THREAD_PRIORITY_DEFAULT</code>稍微优先，值为-1</li>
<li><code>THREAD_PRIORITY_LESS_FAVORABLE</code> 相对<code>THREAD_PRIORITY_DEFAULT</code>稍微落后一些，值为1</li>
</ul>


<p>为线程设置优先级也比较简单，通用的做法是在run方法体的开始部分加入下列代码
<code>java
android.os.Process.setThreadPriority(priority);
</code></p>

<p>通常设置优先级的规则如下：</p>

<ul>
<li>一般的工作者线程，设置成<code>THREAD_PRIORITY_BACKGROUND</code></li>
<li>对于优先级很低的线程，可以设置<code>THREAD_PRIORITY_LOWEST</code></li>
<li>其他特殊需求，视业务应用具体的优先级</li>
</ul>


<h2>总结</h2>

<p>在Android中工作者线程如此普遍，然而潜在的问题也不可避免，建议在开发者使用工作者线程时，从工作者线程的数量和优先级等方面进行审视，做到较为合理的使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 中 SQLite 性能优化]]></title>
    <link href="http://droidyue.com/blog/2015/12/13/android-sqlite-tuning/"/>
    <updated>2015-12-13T17:38:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/12/13/android-sqlite-tuning</id>
    <content type="html"><![CDATA[<p>数据库是应用开发中常用的技术，在Android应用中也不例外。Android默认使用了SQLite数据库，在应用程序开发中，我们使用最多的无外乎增删改查。纵使操作简单，也有可能出现查找数据缓慢，插入数据耗时等情况，如果出现了这种问题，我们就需要考虑对数据库操作进行优化了。本文将介绍一些实用的数据库优化操作，希望可以帮助大家更好地在开发过程中使用数据库。</p>

<!--more-->


<h2>建立索引</h2>

<p>很多时候，我们都听说，想要查找快速就建立索引。这句话没错，数据表的索引类似于字典中的拼音索引或者部首索引。</p>

<h3>索引的解释</h3>

<p>重温一下我们小时候查字典的过程：</p>

<ul>
<li>对于已经知道拼音的字，比如<code>中</code>这个字，我们只需要在拼音索引里面找到<code>zhong</code>，就可以确定这个字在词典中的页码。</li>
<li>对于不知道拼音的字，比如<code>欗</code>这个字，我们只需要在部首索引里面查找这个字，就能找到确定这个字在词典中的页码。</li>
</ul>


<p>没错，索引做的事情就是这么简单，使得我们不需要查找整个数据表就可以实现快速访问。</p>

<h3>建立索引</h3>

<p>创建索引的基本语法如下
<code>
CREATE INDEX index_name ON table_name;
</code></p>

<p>创建单列索引
<code>
CREATE INDEX index_name ON table_name (column_name);
</code></p>

<h3>索引真的好么</h3>

<p>毋庸置疑，索引加速了我们检索数据表的速度。然而正如西方谚语 &ldquo;There are two sides of a coin"，索引亦有缺点：</p>

<ul>
<li>对于增加，更新和删除来说，使用了索引会变慢，比如你想要删除字典中的一个字，那么你同时也需要删除这个字在拼音索引和部首索引中的信息。</li>
<li>建立索引会增加数据库的大小，比如字典中的拼音索引和部首索引实际上是会增加字典的页数，让字典变厚的。</li>
<li>为数据量比较小的表建立索引，往往会事倍功半。</li>
</ul>


<p>所以使用索引需要考虑实际情况进行利弊权衡，对于查询操作量级较大，业务对要求查询要求较高的，还是推荐使用索引的。</p>

<h2>编译SQL语句</h2>

<p>SQLite想要执行操作，需要将程序中的sql语句编译成对应的SQLiteStatement，比如<code>select * from record</code>这一句，被执行100次就需要编译100次。对于批量处理插入或者更新的操作，我们可以使用显式编译来做到重用SQLiteStatement。</p>

<p>想要做到重用SQLiteStatement也比较简单，基本如下：</p>

<ul>
<li>编译sql语句获得SQLiteStatement对象，参数使用<code>?</code>代替</li>
<li>在循环中对SQLiteStatement对象进行具体数据绑定，bind方法中的index从1开始，不是0</li>
</ul>


<p>请参考如下简单的使用代码
```java
private void insertWithPreCompiledStatement(SQLiteDatabase db) {</p>

<pre><code>String sql = "INSERT INTO " + TableDefine.TABLE_RECORD + "( " + TableDefine.COLUMN_INSERT_TIME + ") VALUES(?)";
SQLiteStatement  statement = db.compileStatement(sql);
int count = 0;
while (count &lt; 100) {
    count++;
    statement.clearBindings();
    statement.bindLong(1, System.currentTimeMillis());
    statement.executeInsert();
}
</code></pre>

<p>}
```</p>

<h2>显式使用事务</h2>

<p>在Android中，无论是使用SQLiteDatabase的insert,delete等方法还是execSQL都开启了事务，来确保每一次操作都具有原子性，使得结果要么是操作之后的正确结果，要么是操作之前的结果。</p>

<p>然而事务的实现是依赖于名为rollback journal文件，借助这个临时文件来完成原子操作和回滚功能。既然属于文件，就符合Unix的文件范型(Open-Read/Write-Close)，因而对于批量的修改操作会出现反复打开文件读写再关闭的操作。然而好在，我们可以显式使用事务，将批量的数据库更新带来的journal文件打开关闭降低到1次。</p>

<p>具体的实现代码如下：</p>

<p>```java
private void insertWithTransaction(SQLiteDatabase db) {</p>

<pre><code>int count = 0;
ContentValues values = new ContentValues();
try {
    db.beginTransaction();
    while (count++ &lt; 100) {
        values.put(TableDefine.COLUMN_INSERT_TIME, System.currentTimeMillis());
        db.insert(TableDefine.TABLE_RECORD, null, values);
    }
    db.setTransactionSuccessful();
} catch (Exception e) {
    e.printStackTrace();
} finally {
    db.endTransaction();
}
</code></pre>

<p>}
```</p>

<p>上面的代码中，如果没有异常抛出，我们则认为事务成功，调用<code>db.setTransactionSuccessful();</code>确保操作真实生效。如果在此过程中出现异常，则批量数据一条也不会插入现有的表中。</p>

<h2>查询数据优化</h2>

<p>对于查询的优化，除了建立索引以外，有以下几点微优化的建议</p>

<h3>按需获取数据列信息</h3>

<p>通常情况下，我们处于自己省时省力的目的，对于查找使用类似这样的代码
```java
private void badQuery(SQLiteDatabase db) {</p>

<pre><code>db.query(TableDefine.TABLE_RECORD, null, null, null, null, null, null) ;
</code></pre>

<p>}
```
其中上面方法的第二个参数类型为String[]，意思是返回结果参考的colum信息，传递null表明需要获取全部的column数据。这里建议大家传递真实需要的字符串数据对象表明需要的列信息，这样做效率会有所提升。</p>

<h3>提前获取列索引</h3>

<p>当我们需要遍历cursor时，我们通常的做法是这样
```java
private void badQueryWithLoop(SQLiteDatabase db) {</p>

<pre><code>Cursor cursor = db.query(TableDefine.TABLE_RECORD, new String[]{TableDefine.COLUMN_INSERT_TIME}, null, null, null, null, null) ;
while (cursor.moveToNext()) {
    long insertTime = cursor.getLong(cursor.getColumnIndex(TableDefine.COLUMN_INSERT_TIME));
}
</code></pre>

<p>}
<code>
但是如果我们将获取ColumnIndex的操作提到循环之外，效果会更好一些，修改后的代码如下：
</code>java
private void goodQueryWithLoop(SQLiteDatabase db) {</p>

<pre><code>Cursor cursor = db.query(TableDefine.TABLE_RECORD, new String[]{TableDefine.COLUMN_INSERT_TIME}, null, null, null, null, null) ;
int insertTimeColumnIndex = cursor.getColumnIndex(TableDefine.COLUMN_INSERT_TIME);
while (cursor.moveToNext()) {
    long insertTime = cursor.getLong(insertTimeColumnIndex);
}
cursor.close();
</code></pre>

<p>}
```</p>

<h2>ContentValues的容量调整</h2>

<p>SQLiteDatabase提供了方便的ContentValues简化了我们处理列名与值的映射，ContentValues内部采用了HashMap来存储Key-Value数据，ContentValues的初始容量是8，如果当添加的数据超过8之前，则会进行双倍扩容操作，因此建议对ContentValues填入的内容进行估量，设置合理的初始化容量，减少不必要的内部扩容操作。</p>

<h2>及时关闭Cursor</h2>

<p>使用数据库，比较常见的就是忘记关闭Cursor。关于如何发现未关闭的Cursor，我们可以使用StrictMode，详细请戳这里<a href="http://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode/">Android性能调优利器StrictMode</a></p>

<h2>耗时异步化</h2>

<p>数据库的操作，属于本地IO，通常比较耗时，如果处理不好，很容易导致<a href="http://droidyue.com/blog/2015/07/18/anr-in-android/">ANR</a>,因此建议将这些耗时操作放入异步线程中处理，这里推荐一个单线程 + 任务队列形式处理的<a href="http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/">HandlerThread</a>实现异步化。</p>

<h2>源码下载</h2>

<p>示例源码，存放在Github，地址为<a href="https://github.com/androidyue/AndroidSQLiteTuningDemo">AndroidSQLiteTuningDemo</a></p>
]]></content>
  </entry>
  
</feed>
