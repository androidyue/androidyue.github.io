<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2014-12-22T23:18:09+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[应用认领那些事]]></title>
    <link href="http://droidyue.com/blog/2014/12/14/android-yingyong-renling/"/>
    <updated>2014-12-14T19:35:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/12/14/android-yingyong-renling</id>
    <content type="html"><![CDATA[<p>最近公司的一款产品提交国内市场，发现有些国内市场提示需要进行应用认领。原因就是别人（或者市场抓取）已经在我们之前将这个应用提交到了该市场。认领成功后，这个应用就重回你的怀抱了，其实认领很简单，这里讲到的自然是对未签名的包进行签名。由于这样的操作细小琐屑，这样更需要记录一下，免得以后麻烦。</p>

<!--more-->


<h2>如何认领</h2>

<ul>
<li>一般的就是市场提供一个未签名的apk包，认领方进行签名后，上传即可认领成功。</li>
<li>另一种就是提供公司证明，这个我们不讲，也没什么可以讲。</li>
</ul>


<p>通常情况下认领都会有对一个未签名的apk包签名认证这种方式，因为签名是软件发布商所独有的，通过对比测试需认领的包的签名和刚签过名的apk包是否一致，如果一致就认领成功，否则失败。</p>

<h2>对未签名包签名</h2>

<p><code>bash
jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore your_keystore  -storepass your_storepass -keypass your_keypass -signedjar path_of_signed_apk  path_of_unsigned_apk your_alias
</code></p>

<h3>需要替换的值</h3>

<ul>
<li>your_key_store keystore文件路径</li>
<li>your_storepass   store密码</li>
<li>your_keypass    key密码</li>
<li>path_of_signed_apk 签名后apk保存的目录</li>
<li>path_of_unsigned_apk 待签名的apk包</li>
<li>your_alias keystore中的别名</li>
</ul>


<p>注意上面的签名算法sigalg 使用SHA1withRSA或者MD5withRSA都可以。</p>

<h2>验证签名</h2>

<p><code>bash
jarsigner -verify -certs -verbose your_app.apk
</code>
比如我们验证百度金融的apk，会得到类似这样的结果
```bash
19:23 $ jarsigner -verify -certs -verbose BaiduFinance.apk | more</p>

<p>s      61679 Fri Nov 14 19:50:16 CST 2014 META-INF/MANIFEST.MF</p>

<pre><code>  X.509, CN=Baidu, OU=Baidu Inc., O=Baidu Inc., L=Beijing, ST=Beijing, C=CN
  [certificate is valid from 12/6/13 10:19 AM to 11/24/63 10:19 AM]
  [CertPath not validated: Path does not chain with any of the trust anchors]

   61800 Fri Nov 14 19:50:16 CST 2014 META-INF/MCO_BAID.SF
     936 Fri Nov 14 19:50:16 CST 2014 META-INF/MCO_BAID.RSA
</code></pre>

<p>sm      2304 Fri Nov 14 19:49:32 CST 2014 assets/mean/data_mean_24_bank_card
```</p>

<h2>疑难问题</h2>

<h3>No -tsa or -tsacert is provided and this jar is not timestamped</h3>

<p>在签名时加入下面的选项
<code>bash
jarsigner -tsa http://timestamp.digicert.com
</code></p>

<h3>Windows无法打开文件</h3>

<p>有些Windows工具无法打开签名后的apk，如果你的签名没有错误，并且验证过，这种情况请忽略。</p>

<h3>签名认领失败</h3>

<p>如果签名认领失败的话，请检查目前线上的包是否进行了二次打包被别人篡改了签名，如果是的话，需要进行商务上的沟通来解决了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[仿腾讯新闻样式的Toast]]></title>
    <link href="http://droidyue.com/blog/2014/11/29/custom-toast-like-tencent-news-app/"/>
    <updated>2014-11-29T17:21:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/29/custom-toast-like-tencent-news-app</id>
    <content type="html"><![CDATA[<p>厌倦了网易新闻无处不在的喷子，尝试了一下腾讯新闻，果然顿时清净了很多，当然这不是重点。个人感觉腾讯新闻客户端的Toast比较不错，相对于系统默认的Toast，更加能起到提醒的作用。于是反编译了一下，简单分享一下,其实很简单。</p>

<!--more-->


<h2>先看效果</h2>

<p><img class="<a" src="href="http://droidyueimg.qiniudn.com/tencent_toast.png">http://droidyueimg.qiniudn.com/tencent_toast.png</a>">
背景为深灰色，支持设置图片和文字。</p>

<h2>布局文件</h2>

<p>```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;RelativeLayout</p>

<pre><code>android:id="@+id/view_tips_layout" 
android:background="@drawable/tips_bg" 
android:layout_width="wrap_content" 
android:layout_height="wrap_content"
xmlns:android="http://schemas.android.com/apk/res/android"&gt;
&lt;View 
    android:layout_width="160.0dip" 
    android:layout_height="160.0dip" 
    android:layout_centerInParent="true" /&gt;

&lt;LinearLayout 
    android:orientation="vertical" 
    android:layout_width="wrap_content" 
    android:layout_height="wrap_content" 
    android:layout_centerInParent="true"&gt;

    &lt;ImageView 
        android:gravity="center" 
        android:layout_gravity="center" 
        android:id="@+id/tips_icon" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_marginBottom="10.0dip" 
        android:src="@drawable/tips_error" 
        android:contentDescription="@null" /&gt;

    &lt;TextView 
        android:textSize="17.0sp" 
        android:textColor="#ffffffff" 
        android:gravity="center" 
        android:layout_gravity="center" 
        android:id="@+id/tips_msg" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:lineSpacingExtra="3.0dip" /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p></RelativeLayout>
```</p>

<h2>程序代码</h2>

<p><code>java
Toast toast = new Toast(getApplicationContext());
View toastView = LayoutInflater.from(getApplicationContext()).inflate(R.layout.view_tips, null);
((ImageView)toastView.findViewById(R.id.tips_icon)).setImageResource(R.drawable.ic_launcher);
((TextView)toastView.findViewById(R.id.tips_msg)).setText("Error Occurs");
toast.setView(toastView);
toast.setGravity(Gravity.NO_GRAVITY, 0, 0);
toast.show();
</code>
Toast默认的位置为底部水平居中。我们可以通过设置setGravity(int, int, int)来进行设置位置。该方法接受三个参数，一个Gravity常量，一个x（水平）方向上的偏移量，一个y（竖直）方向上的偏移量。</p>

<p>如果我们想让位置向右我们需要增加x方向上的偏移量，如果想让位置向下，增大y方向上的偏移量。</p>

<h2>多说</h2>

<p>我们可以根据自己的需求去设置图片，文字，背景色等样式来定制想要的Toast。</p>

<p>注意，涉及到长度宽度字体大小相关的建议放到dimens文件，便于我们进行设备适配。</p>

<h2>示例下载</h2>

<p><a href="http://pan.baidu.com/s/1kTLxagZ">百度网盘</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google为何这样设计OnSharedPreferenceChangeListener]]></title>
    <link href="http://droidyue.com/blog/2014/11/29/why-onsharedpreferencechangelistener-was-not-called/"/>
    <updated>2014-11-29T16:41:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/29/why-onsharedpreferencechangelistener-was-not-called</id>
    <content type="html"><![CDATA[<p>之前使用OnSharedPreferenceChangeListener，遇到了点小问题，就是有些时候OnSharedPreferenceChangeListener没有被触发。最近花了点时间研究了一下，小做整理。本文将会介绍监听器不被触发的原因，解决方法，以及其中隐含的一些技术细节。</p>

<!--more-->


<h2>问题再现</h2>

<p>OnSharedPreferenceChangeListener是Android中SharedPreference文件发生变化的监听器。通常我们想要进行监听，会实现如下的代码。
```java
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>PreferenceManager.getDefaultSharedPreferences(getApplicationContext())
    .registerOnSharedPreferenceChangeListener(new OnSharedPreferenceChangeListener() {
    @Override
    public void onSharedPreferenceChanged(
        SharedPreferences sharedPreferences, String key) {
        Log.i(LOGTAG, "testOnSharedPreferenceChangedWrong key =" + key);
    }
});
</code></pre>

<p>}
```
这种写法看上去没有什么问题，而且很多时候开始几次onSharedPreferenceChanged方法也可以被调用。但是过一段时间（简单demo不容易出现，但是使用DDMS中的gc会立刻导致接下来的问题），你会发现前面的方法突然不再被调用，进而影响到程序的处理。</p>

<h2>原因剖析</h2>

<p>简而言之，就是你注册的监听器被移除掉了。<br/>
首先我们先了解一下registerOnSharedPreferenceChangeListener注册的实现。
```
private final WeakHashMap&lt;OnSharedPreferenceChangeListener, Object> mListeners =</p>

<pre><code>        new WeakHashMap&lt;OnSharedPreferenceChangeListener, Object&gt;();
</code></pre>

<p>//some code goes here
public void More &hellip;registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {</p>

<pre><code>synchronized(this) {
    mListeners.put(listener, mContent);
}
</code></pre>

<p>}
```
从上面的代码可以得知，一个OnSharedPreferenceChangeListener对象实际上是放到了一个WeakHashMap的容器中，执行完示例中的onCreate方法，这个监听器对象很快就会成为垃圾回收的目标，由于放在WeakHashMap中作为key不会阻止垃圾回收，所以当监听器对象被回收之后，这个监听器也会从mListeners中移除。所以就造成了onSharedPreferenceChanged不会被调用。</p>

<p>关于WeakHashMap相关，请阅读<a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">译文：理解Java中的弱引用</a>进而更多了解。</p>

<h2>如何解决</h2>

<h3>改为对象成员变量（推荐）</h3>

<p>将监听器作为Activity的一个成员变量，在Activity的onResume进行注册，在onPause时进行注销。推荐在这两个Activity生命周期中进行处理，尤其是当SharedPreference值发生变化后，对Activity展示的UI进行处理操作的情况。这种方法是最推荐的解决方案。
```java
private OnSharedPreferenceChangeListener mListener = new OnSharedPreferenceChangeListener() {</p>

<pre><code>@Override
public void onSharedPreferenceChanged(
    SharedPreferences sharedPreferences, String key) {
    Log.i(LOGTAG, "instance variable key=" + key);
}
</code></pre>

<p>};</p>

<p>@Override
protected void onResume() {</p>

<pre><code>PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).registerOnSharedPreferenceChangeListener(mListener);
super.onResume();
</code></pre>

<p>}</p>

<p>@Override
protected void onPause() {</p>

<pre><code>PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).unregisterOnSharedPreferenceChangeListener(mListener);
super.onPause();
</code></pre>

<p>}
```</p>

<h3>改为静态变量（不推荐）</h3>

<p>如下，将一个指向匿名的内部类对象的变量sListener使用static修饰，这个内部类对象则不会持有外部类的引用。<br/>
但是这种做法并不推荐，因为一个静态变量和与外部实例不相关，我们很难和外部实例进行一些操作。
```java
private static OnSharedPreferenceChangeListener sListener = new OnSharedPreferenceChangeListener() {</p>

<pre><code>@Override
public void onSharedPreferenceChanged(
    SharedPreferences sharedPreferences, String key) {
    Log.i(LOGTAG, "static variable key=" + key);
}
</code></pre>

<p>};
```</p>

<h2>为什么这样设计</h2>

<p>可能会有人认为这是系统设计的猫腻或者bug，其实不然，这正是Android设计人员的高明之处。</p>

<p>正如我们示例的代码一样，将一个（隐式的）局部变量添加到监听器容器中，如果该容器只是一个普通的HashMap，这样会导致内存泄露，因为该容器还有局部变量指向的对象，该对象又隐式持有外部Activity的对象，导致Activity无法被销毁。关于非静态内部类持有隐式持有外部类引用，请参考<a href="http://droidyue.com/blog/2014/10/02/the-private-modifier-in-java/">细话Java："失效"的private修饰符</a></p>

<p>除此之外，因为局部变量无法在其所在方法外部访问，这样就导致了我们只可以使用方法中使用局部变量就行注册，在合适的时机却无法使用局部变量进行注销。</p>

<h2>三本帮助深入研究Java的书</h2>

<ul>
<li><a href="http://www.amazon.cn/gp/product/0137142528/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=0137142528&amp;linkCode=as2&amp;tag=droidyue-23">Java Performance</a></li>
<li><a href="http://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011F7WU4&amp;linkCode=as2&amp;tag=droidyue-23">Java编程思想(第4版)</a></li>
<li><a href="http://www.amazon.cn/gp/product/B001PTGR52/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001PTGR52&amp;linkCode=as2&amp;tag=droidyue-23">Sun 公司核心技术丛书:Effective Java中文版(第2版)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中WebView拦截替换网络请求数据]]></title>
    <link href="http://droidyue.com/blog/2014/11/23/block-web-resource-in-webview/"/>
    <updated>2014-11-23T21:54:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/23/block-web-resource-in-webview</id>
    <content type="html"><![CDATA[<p>Android中处理网页时我们必然用到WebView,这里我们有这样一个需求，我们想让WebView在处理网络请求的时候将某些请求拦截替换成某些特殊的资源。具体一点儿说，在WebView加载 <code>http://m.sogou.com</code> 时，会加载一个logo图片，我们的需求就是将这个logo图片换成另一张图片。</p>

<!--more-->


<h3>shouldInterceptRequest</h3>

<p>好在Android中的WebView比较强大，从API 11(Android 3.0)开始， shouldInterceptRequest被引入就是为了解决这一类的问题。</p>

<p>shouldInterceptRequest这个回调可以通知主程序WebView处理的资源（css,js,image等）请求，并允许主程序进行处理后返回数据。如果主程序返回的数据为null，WebView会自行请求网络加载资源，否则使用主程序提供的数据。注意这个回调发生在非UI线程中,所以进行UI系统相关的操作是不可以的。</p>

<p>shouldInterceptRequest有两种重载。</p>

<ul>
<li><strong>public WebResourceResponse shouldInterceptRequest (WebView view, String url)</strong> 从API 11开始引入，API 21弃用</li>
<li><strong>public WebResourceResponse shouldInterceptRequest (WebView view, WebResourceRequest request)</strong> 从API 21开始引入</li>
</ul>


<p>本次例子暂时使用第一种，即shouldInterceptRequest (WebView view, String url)。</p>

<h3>示例代码</h3>

<p>```java
WebView webView = new WebView(this);
webView.setWebViewClient(new WebViewClient() {</p>

<pre><code>@Override
public WebResourceResponse shouldInterceptRequest(WebView view, String url) {
    Log.i(LOGTAG, "shouldInterceptRequest url=" + url + ";threadInfo" + Thread.currentThread());
    WebResourceResponse response = null;
    if (url.contains("logo")) {
        try {
            InputStream localCopy = getAssets().open("droidyue.png");
            response = new WebResourceResponse("image/png", "UTF-8", localCopy);
        } catch (IOException e) {
            e.printStackTrace();
        }       
    }
    return response;
}   
</code></pre>

<p>});
setContentView(webView);
webView.loadUrl(&ldquo;<a href="http://m.sogou.com">http://m.sogou.com</a>&rdquo;);
```
其中WebResourceResponse需要设定三个属性，MIME类型，数据编码，数据(InputStream流形式)。</p>

<h3>示例下载</h3>

<ul>
<li><a href="http://pan.baidu.com/s/1ntOaHoH">百度云盘</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[点击网页链接调用Android程序]]></title>
    <link href="http://droidyue.com/blog/2014/11/23/start-android-application-when-click-a-link/"/>
    <updated>2014-11-23T15:58:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/23/start-android-application-when-click-a-link</id>
    <content type="html"><![CDATA[<p>最近前端同事问了我一个问题，如何让网页链接实现启动Android的应用，网上有说重写WebView相关的shouldOverrideUrlLoading方法，但是这种理论上能实现，因为你的网页不是仅仅被你自己的webview来浏览，你需要做的是让市面上的浏览器支持才行。</p>

<p>这里利用零碎的时间整理一下。主要涉及到的问题就是关于Intent在字符串形式和Intent对象之间的转换。如果你是一位前端工程师，请让你的Anroid开发小伙伴来看这篇文章，一同解决问题。</p>

<!--more-->


<h2>两种表现形式</h2>

<p>Intent是Android开发中常见的API。在处理Android组件中，有着必不可少的作用。Intent可以以两种方式存在。</p>

<ul>
<li>Intent对象。用于在程序中处理，在处理Android组件时使用。</li>
<li>字符串形式的URI。 用于在非程序代码中，如网页中进行使用等。</li>
</ul>


<p>而这里我们解决我们上面问题的就是后者，字符串形式的Intent。</p>

<h2>Intent对象转成字符串URI</h2>

<p>Intent提供了两种将对象转换成字符串URI，一个是推荐的<code>public String toUri (int flags)</code>，
在API 4加入，将Intent对象转换成字符串形式的URI。字符串形式的URI可以包含Intent的data,action,categories, type, flags, package, component和extras。
<code>java
Intent intent = new Intent();
ComponentName comp = new ComponentName("com.mx.app.mxhaha", "com.mx.app.MxMainActivity");
intent.setComponent(comp);
Log.i(LOGTAG, "intent.uri=" + intent.toUri(Intent.URI_INTENT_SCHEME));
</code>
生成的字符串URI为
<code>
intent:#Intent;component=com.mx.app.mxhaha/com.mx.app.MxMainActivity;end
</code></p>

<p>另一个方法是<code>public String toURI ()</code>，
这是一个弃用的方法，因为它生成的字符串以<strong>#</strong>开头，<strong>放在链接上会被当成锚点</strong>。不建议使用使用这个方法。</p>

<p>上面的Intent对象使用toUri转换成
```</p>

<h1>Intent;component=com.mx.app.mxhaha/com.mx.app.MxMainActivity;end</h1>

<p>```</p>

<h2>字符串URI转成Intent对象</h2>

<h3>getIntent(String uri)</h3>

<p>这个方法只适用于处理以#开头的URI，而且在其方法内部实际上是调用的<code>parseUri(uri, 0)</code>来实现的。这个方法已经被比较为弃用，不推荐使用。</p>

<h3>getIntentOld(String uri)</h3>

<p>getIntentOld既可以支持#开头的URI转换成Intent对象，如果uri不是Intent的字符串形式，那么也会返回一个Intent，只是其data部分为uri，action为android.intent.action.VIEW。</p>

<h3>parseUri(String uri, int flags)</h3>

<p>这个是最完整的转换方法。接收uri和flag作为参数。支持将字符串形式的URI转成Intent对象.</p>

<p>以下为一个既可以解析<strong>intent:</strong>开头的URI也可以解析<strong>#Intent</strong>开头的URI的方法。
```java
public static Intent parseIntent(String url) {</p>

<pre><code>Intent intent = null;
// Parse intent URI into Intent Object
int flags = 0;
boolean isIntentUri = false;
if (url.startsWith("intent:")) {
    isIntentUri = true;
    flags = Intent.URI_INTENT_SCHEME;
} else if (url.startsWith("#Intent;")) {
    isIntentUri = true;
}
if (isIntentUri) {
    try {
        intent = Intent.parseUri(url, flags);
    } catch (URISyntaxException e) {
        e.printStackTrace();
    }
}
return intent;
</code></pre>

<p>}
```</p>

<h2>多说一下</h2>

<p>对于Intent字符串形式URI在网页链接中的应用，不同的浏览器实现程度不一致。目前<a href="http://www.maxthon.cn/">傲游浏览器Android版</a>由我已经完全实现这一功能。希望其他的浏览器也可以实现一下这个功能。</p>
]]></content>
  </entry>
  
</feed>
