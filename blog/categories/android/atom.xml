<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://androidyue.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://androidyue.github.io/"/>
  <updated>2014-06-15T17:10:18+08:00</updated>
  <id>http://androidyue.github.io/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android中系统设置中的清除数据究竟会清除哪些数据]]></title>
    <link href="http://androidyue.github.io/blog/2014/06/15/what-will-be-removed-if-you-click-clear-data-button-in-system-application-item/"/>
    <updated>2014-06-15T17:07:00+08:00</updated>
    <id>http://androidyue.github.io/blog/2014/06/15/what-will-be-removed-if-you-click-clear-data-button-in-system-application-item</id>
    <content type="html"><![CDATA[<p>What will be removed If you click Clear Data Button in the System Application</p>

<p>今天中的一个story突然提到了系统设置中的清理数据，后来开始思考究竟系统的应用的这个清理功能，究竟会清理那些数据。
于是开始研究，以com.mx.browser为例，思路大概为首先为/data/data/com.mx.browser下的每一个文件夹下建立一个标志文件，这里为1.txt，然后执行清理数据操作，最后对比结果。
首先，进行清楚数据之前的的各个文件夹的情况。
<code>bash
/data/data/com.mx.browser # ls
lib
files
databases
shared_prefs
app_thumbnails
cache
app_webIcons
app_appcache
app_databases
app_geolocation
</code></p>

<p>为每个文件夹下创建一个标志（同时验证是否删除文件夹的情况）
<code>bash
/data/data/com.mx.browser # touch lib/1.txt
/data/data/com.mx.browser # touch files/1.txt
/data/data/com.mx.browser # touch databases/1.txt
/data/data/com.mx.browser # touch shared_prefs/1.txt
/data/data/com.mx.browser # touch app_thumbnails/1.txt
/data/data/com.mx.browser # touch cache/1.txt
/data/data/com.mx.browser # touch app_webIcons/1.txt
/data/data/com.mx.browser # touch app_appcache/1.txt
/data/data/com.mx.browser # touch app_databases/1.txt
/data/data/com.mx.browser # touch app_geolocation/1.txt
</code>
执行清理数据操作。
查看执行清理数据操作后的结果。
<code>bash
/data/data/com.mx.browser # ls
lib
/data/data/com.mx.browser #
</code></p>

<p>查看lib情况
<code>bash
/data/data/com.mx.browser # cd lib/
/data/data/com.mx.browser/lib # ls
1.txt
/data/data/com.mx.browser/lib #
</code></p>

<p>总上所述，发现系统中的设置，应用中的清理数据，会清理掉除去lib文件夹（含内部文件）的文件及文件夹。
p.s./sdcard/Android/data/这个目录也是和包名相关的，但是系统中的清理数据不会清理掉这个目录中的相关信息。</p>

<blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[检查Android是否具有摄像头]]></title>
    <link href="http://androidyue.github.io/blog/2014/06/14/check-camera-in-android/"/>
    <updated>2014-06-14T15:57:00+08:00</updated>
    <id>http://androidyue.github.io/blog/2014/06/14/check-camera-in-android</id>
    <content type="html"><![CDATA[<p>通常我们进行摄像头操作，如扫描二维码需要判断是否有后置摄像头(Rear camera)，比如Nexus 7 一代就没有后置摄像头，这样在尝试使用的时候，我们需要进行判断进行一些提示或者处理。</p>

<p>以下代码为一系列的方法，用来判断是否有前置摄像头（Front Camera），后置摄像头。</p>

<p>```java
private static boolean checkCameraFacing(final int facing) {</p>

<pre><code>if (getSdkVersion() &lt; Build.VERSION_CODES.GINGERBREAD) {
    return false;
}
final int cameraCount = Camera.getNumberOfCameras();
CameraInfo info = new CameraInfo();
for (int i = 0; i &lt; cameraCount; i++) {
    Camera.getCameraInfo(i, info);
    if (facing == info.facing) {
        return true;
    }
}
return false;
</code></pre>

<p>}</p>

<p>public static boolean hasBackFacingCamera() {</p>

<pre><code>final int CAMERA_FACING_BACK = 0;
return checkCameraFacing(CAMERA_FACING_BACK);
</code></pre>

<p>}</p>

<p>public static boolean hasFrontFacingCamera() {</p>

<pre><code>final int CAMERA_FACING_BACK = 1;
return checkCameraFacing(CAMERA_FACING_BACK);
</code></pre>

<p>}</p>

<p>public static int getSdkVersion() {</p>

<pre><code>return android.os.Build.VERSION.SDK_INT;
</code></pre>

<p>}
```
注意：由于getNumberOfCameras以及getCameraInfo均为API 9 引入，所以方法只适用于2.3及其以上。</p>

<p>延伸阅读：<a href="http://developer.android.com/reference/android/hardware/Camera.html">http://developer.android.com/reference/android/hardware/Camera.html</a>
<a href="http://developer.android.com/reference/android/hardware/Camera.CameraInfo.html">http://developer.android.com/reference/android/hardware/Camera.CameraInfo.html</a></p>

<blockquote><p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android NinePatch Attention]]></title>
    <link href="http://androidyue.github.io/blog/2014/04/26/android-ninepatch-attention/"/>
    <updated>2014-04-26T12:23:00+08:00</updated>
    <id>http://androidyue.github.io/blog/2014/04/26/android-ninepatch-attention</id>
    <content type="html"><![CDATA[<p>I have got many crash report data about using NinePath Drwable. I put a .9.png file into the drawable-xhdpi folder and the file did not exist in any other folder. And I got ResourceNotFoundException. I got this following sayings.</p>

<blockquote><p>A NinePatchDrawable graphic is a stretchable bitmap image, which Android will automatically resize to accommodate the contents of the View in which you have placed it as the background. An example use of a NinePatch is the backgrounds used by standard Android buttons — buttons must stretch to accommodate strings of various lengths. A NinePatch drawable is a standard PNG image that includes an extra 1-pixel-wide border. <strong>It must be saved with the extension .9.png, and saved into the res/drawable/ directory of your project.</strong>
<a href="http://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch">http://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch</a></p></blockquote>

<p>The .9.png files must be saved into the res/drawable directory. Why? I guess the legacy Resouce Loading System implemententation may result in this issue. So at least put one .9.png file into the drawable folder.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fix Notification Switching Position Issue]]></title>
    <link href="http://androidyue.github.io/blog/2014/03/21/fix-notification-switching-position-issue/"/>
    <updated>2014-03-21T22:14:00+08:00</updated>
    <id>http://androidyue.github.io/blog/2014/03/21/fix-notification-switching-position-issue</id>
    <content type="html"><![CDATA[<p>I once faced with a problem. I wrote a piece of code related with notifcation. Everything goes fine except one little issue. I found the ongoing notification switching order. My notification blinked each second.  After Googling I found the reason and resolved the problem.<br/>
In my code I wrote like this
```java</p>

<pre><code>notification.when = System.currentTimeMillis();
</code></pre>

<p><code>
That's was the key point. For the notification the when timestamp should be fixed when an activity starts. And the default value is Now(which is the value of System.currentTimeMillis()).I used **a fixed value** and resovled the problem.
</code>java
notification.when = TIMESTAMP_FIXED;
```
Now This is what Google says</p>

<blockquote><p>A timestamp related to this notification, in milliseconds since the epoch. Default value: Now. Choose a timestamp that will be most relevant to the user. For most finite events, this corresponds to the time the event happened (or will happen, in the case of events that have yet to occur but about which the user is being informed). Indefinite events should be timestamped according to when the activity began. Some examples:</p>

<ul>
<li>Notification of a new chat message should be stamped when the message was received.</li>
<li>Notification of an ongoing file download (with a progress bar, for example) should be stamped when the download started.</li>
<li>Notification of a completed file download should be stamped when the download finished.</li>
<li>Notification of an upcoming meeting should be stamped with the time the meeting will begin (that is, in the future).</li>
<li>Notification of an ongoing stopwatch (increasing timer) should be stamped with the watch&rsquo;s start time.</li>
<li>Notification of an ongoing countdown timer should be stamped with the timer&rsquo;s end time.
Reference from <a href="http://developer.android.com/reference/android/app/Notification.html#when">http://developer.android.com/reference/android/app/Notification.html#when</a>
Written with <a href="https://stackedit.io/">StackEdit</a>.</li>
</ul>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Snippet For Media on Android]]></title>
    <link href="http://androidyue.github.io/blog/2014/02/09/code-snippet-for-media-on-android/"/>
    <updated>2014-02-09T19:37:00+08:00</updated>
    <id>http://androidyue.github.io/blog/2014/02/09/code-snippet-for-media-on-android</id>
    <content type="html"><![CDATA[<p>A few days ago,I have wrote down this post <a href="http://androidyue.github.io/blog/2014/01/19/scan-media-files-in-android/">http://androidyue.github.io/blog/2014/01/19/scan-media-files-in-android/</a>. Now I will paste my code snippet.</p>

<h3>MediaUtils.java</h3>

<p>```java
package com.mx.browser.utils;</p>

<p>import java.io.File;
import java.util.Locale;</p>

<p>import com.mx.utils.FileUtils;
import com.mx.utils.Log;</p>

<p>import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.media.MediaScannerConnection;
import android.media.MediaScannerConnection.OnScanCompletedListener;
import android.net.Uri;
import android.provider.MediaStore.Audio;
import android.provider.MediaStore.Images;
import android.provider.MediaStore.Video;
import android.text.TextUtils;</p>

<p>/<em>*
 * Utility Methods for Media Library Operations
 * @author androidyue
 * Referrer  <a href="http://androidyue.github.io/blog/2014/01/19/scan-media-files-in-android/">http://androidyue.github.io/blog/2014/01/19/scan-media-files-in-android/</a>
 </em>/
public class MediaUtils {</p>

<pre><code>private static final String LOGTAG = "MediaUtils";

/**
 * Scan a media file by sending a broadcast.This is the easiest way.
 * 对方成功接收广播并处理条件  文件必须存在，文件路径必须以Environment.getExternalStorageDirectory().getPath() 的返回值开头
 */
public static void sendScanFileBroadcast(Context context, String filePath) {
        File file = new File(filePath);
        Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.fromFile(file));
        context.sendBroadcast(intent);
}


/**
 * 
 * @param context
 * @param paths File paths to scan 
 * @param mimeTypes mimeTypes in array;it could be null;then 
 * @param callback
 */
public static void scanFiles(Context context, String[] paths, String[] mimeTypes, OnScanCompletedListener callback) {
    if (null != paths &amp;&amp; paths.length != 0) {
        MediaScannerConnection.scanFile(context, paths, mimeTypes, callback);
    } else {
        Log.i(LOGTAG, "scanFiles paths = null or paths.length=0 paths=" + paths);
    }
}

public static void scanFiles(Context context, String[] paths, String[] mimeTypes) {
    scanFiles(context, paths, mimeTypes, null);
}

public static void scanFiles(Context context, String[] paths) {
    scanFiles(context, paths, null);
}

public static int removeImageFromLib(Context context, String filePath) {
    ContentResolver resolver = context.getContentResolver();
    return resolver.delete(Images.Media.EXTERNAL_CONTENT_URI, Images.Media.DATA + "=?", new String[]{filePath});
}

public static int removeAudioFromLib(Context context, String filePath) {
    return context.getContentResolver().delete(Audio.Media.EXTERNAL_CONTENT_URI, 
            Audio.Media.DATA + "=?", new String[] {filePath});
}

public static int removeVideoFromLib(Context context, String filePath) {
    return context.getContentResolver().delete(Video.Media.EXTERNAL_CONTENT_URI, 
            Video.Media.DATA + "=?", new String[] {filePath});

}

public static int removeMediaFromLib(Context context, String filePath) {
    String mimeType = FileUtils.getFileMimeType(filePath);
    int affectedRows = 0;
    if (null != mimeType) {
        mimeType = mimeType.toLowerCase(Locale.US);
        if (isImage(mimeType)) {
            affectedRows = removeImageFromLib(context, filePath);
        } else if (isAudio(mimeType)) {
            affectedRows = removeAudioFromLib(context ,filePath);
        } else if (isVideo(mimeType)) {
            affectedRows = removeVideoFromLib(context, filePath);
        }
    }
    return affectedRows;
}

public static boolean isAudio(String mimeType) {
    return mimeType.startsWith("audio");
}

public static boolean isImage(String mimeType) {
    return mimeType.startsWith("image");
}

public static boolean isVideo(String mimeType) {
    return mimeType.startsWith("video");
}


public static boolean isMediaFile(String filePath) {
    String mimeType = FileUtils.getFileMimeType(filePath);
    return isMediaType(mimeType);
}

public static boolean isMediaType(String mimeType) {
    boolean isMedia = false;
    if (!TextUtils.isEmpty(mimeType)) {
        mimeType = mimeType.toLowerCase(Locale.US);
        isMedia = isImage(mimeType) || isAudio(mimeType) || isVideo(mimeType);
    }
    return isMedia;
}


/**
 * Before using it,please do have a media type check.
 * @param context
 * @param srcPath
 * @param destPath
 * @return
 */
public static int renameMediaFile(Context context, String srcPath, String destPath) {
    removeMediaFromLib(context, srcPath);
    sendScanFileBroadcast(context, destPath);
    return 0;
}
</code></pre>

<p>}</p>

<p>```</p>

<h3>FileUtils.java</h3>

<p>```java</p>

<pre><code>public static String getFileMimeType(String filename) {
    if (TextUtils.isEmpty(filename)) {
        return null;
    }
    int lastDotIndex = filename.lastIndexOf('.');
    String mimetype = MimeTypeMap.getSingleton().getMimeTypeFromExtension(
            filename.substring(lastDotIndex + 1).toLowerCase());
    Log.i(LOGTAG, "getFileMimeType mimeType = " + mimetype);
    return mimetype;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
