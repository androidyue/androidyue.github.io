<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2014-07-18T00:24:28+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自定义控件进阶:declare-styleable重用attr]]></title>
    <link href="http://droidyue.com/blog/2014/07/16/better-in-android-include-attrs-in-declare-stylable/"/>
    <updated>2014-07-16T19:37:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/16/better-in-android-include-attrs-in-declare-stylable</id>
    <content type="html"><![CDATA[<p>最近接触了Android自定义控件,涉及到自定义xml中得属性(attribute),其实也很简单,但是写着写着,发现代码不完美了,就是在attrs.xml这个文件中,发现属性冗余,于是就想有没有类似属性继承或者include之类的方法.本文将就declare-stylable中属性重用记录一下.</p>

<!--more-->


<h2>不完美的代码</h2>

<p>```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<resources></p>

<pre><code>&lt;declare-styleable name="ExTextView"&gt;
   &lt;attr name="enableOnPad" format="boolean" /&gt;
   &lt;attr name="supportDeviceType" format="reference"/&gt;
&lt;/declare-styleable&gt;

&lt;declare-styleable name="ExEditText"&gt;
   &lt;attr name="enableOnPad" format="boolean" /&gt;
   &lt;attr name="supportDeviceType" format="reference"/&gt;  
&lt;/declare-styleable&gt;
</code></pre>

<p></resources>
```
如上面代码,在ExTextView和ExEditText这个stylable中有着重复的属性申明.虽然上面可以工作,但是总感觉写的不专业,于是寻找优化方法.</p>

<h2>这样可以么</h2>

<p>尝试着为declare-stylable指定一个parent,如下代码
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<resources></p>

<pre><code>&lt;declare-styleable name="ExTextView"&gt;
   &lt;attr name="enableOnPad" format="boolean" /&gt;
   &lt;attr name="supportDeviceType" format="reference"/&gt;
&lt;/declare-styleable&gt;

&lt;declare-styleable name="ExEditText" parent="ExTextView"&gt;

&lt;/declare-styleable&gt;
</code></pre>

<p></resources>
```
attrs.xml没有报告语法错误.但是当我使用<strong>R.styleable.ExEditText_supportDeviceType</strong>时候,R文件却没有生成,重新清理了工程还是不生效,不知道是否为adt插件的问题.其他人也遇到了这样的问题. <strong>这个方法目前是不行的</strong>.</p>

<h2>终极答案</h2>

<p>实际上我们可以在declare-stylable之前,申明要多次使用的属性,在declare-stylable节点内部,只需调用即可.具体代码如下.
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<resources></p>

<pre><code>&lt;attr name="enableOnPad" format="boolean" /&gt;
&lt;attr name="supportDeviceType" format="reference"/&gt;

&lt;declare-styleable name="ExTextView"&gt;
    &lt;attr name="enableOnPad"/&gt;
    &lt;attr name="supportDeviceType"/&gt;
&lt;/declare-styleable&gt;

&lt;declare-styleable name="ExEditText"&gt;
    &lt;attr name="enableOnPad"/&gt;
    &lt;attr name="supportDeviceType"/&gt;    
&lt;/declare-styleable&gt;
</code></pre>

<p></resources>
```
每次引用attr后,建议清理一下工程,确保R文件重新生成.</p>

<h2>延伸阅读</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/18827875/how-to-declare-several-stylable-attributes-with-the-same-name-for-different-tags">http://stackoverflow.com/questions/18827875/how-to-declare-several-stylable-attributes-with-the-same-name-for-different-tags</a></li>
</ul>


<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B009OLU8EE/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009OLU8EE&linkCode=as2&tag=droidyue-23">Android系统源代码情景分析</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009OLU8EE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android支持动态申请权限么]]></title>
    <link href="http://droidyue.com/blog/2014/07/16/does-android-support-granting-permission-dynamiclly/"/>
    <updated>2014-07-16T18:52:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/16/does-android-support-granting-permission-dynamiclly</id>
    <content type="html"><![CDATA[<p>作为Android开发者,为程序增加权限是在正常不过的事情了,做法必然是在mainifest中,写入类似这样<code>&lt;uses-permission android:name="android.permission.INTERNET" /&gt;</code>的信息. 以静态申请的形式来完成. 于是这里我想抛出一个问题,Android平台支持动态申请权限么.</p>

<!--more-->


<p>相信很多人回答都是不支持,当然这个答案是对的,但是为什么不支持呢,知其然更要知其所以然.了解其原因还是相当有必要的.</p>

<h2>原因列举</h2>

<ul>
<li><p>Android没有提供动态申请权限的机制.</p></li>
<li><p>目前的静态申请可以将权限安全隐患放在程序安装之前一次提示搞定,而如果动态申请,就会时不时弹出申请框.这样的用户体验太差了.</p></li>
<li><p>一些权限申请需要依赖于设备的feature(特性),使用静态申请可以明确知道设备需要的特性,Google Play根据程序需要的特性和目标设备具有的特性来决定该设备是否被展示和安装.而动态申请无法明确知道需要的feature.可能导致可以展示的应用无法安装.</p></li>
<li><p>可能会带来安全隐患问题.</p></li>
</ul>


<h2>延伸阅读</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/4838779/get-android-permission-dynamiclly">http://stackoverflow.com/questions/4838779/get-android-permission-dynamiclly</a></li>
<li><a href="http://stackoverflow.com/questions/7517171/is-there-any-way-to-ask-permission-programmatically">http://stackoverflow.com/questions/7517171/is-there-any-way-to-ask-permission-programmatically</a></li>
</ul>


<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B009OLU8EE/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009OLU8EE&linkCode=as2&tag=droidyue-23">Android系统源代码情景分析</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009OLU8EE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你造么,Android中程序的停止状态]]></title>
    <link href="http://droidyue.com/blog/2014/07/14/look-inside-android-package-stop-state-since-honeycomb-mr1/"/>
    <updated>2014-07-14T19:46:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/14/look-inside-android-package-stop-state-since-honeycomb-mr1</id>
    <content type="html"><![CDATA[<p>很多人遇到过广播收不到的问题,比如Google Play推广安装广播没有收到等,诸如这些问题,又都是什么原因呢,这篇文章将进行回答.</p>

<p>从Android 3.1(HoneyComb) 也就是API 12开始,Android引入了一套新的启动控制,这就是程序的停止状态.那让我们看一下Google对于程序的停止状态的描述.</p>

<!--more-->


<h2>什么是程序的停止状态</h2>

<blockquote><p>Starting from Android 3.1, the system&rsquo;s package manager keeps track of applications that are in a stopped state and provides a means of controlling their launch from background processes and other applications.</p>

<p>从Android 3.1开始,系统的包管理器开始跟踪处理停止状态的程序.并且提供了方法来控制从后台进程或者其他程序对它们的启动.</p>

<p>Note that an application&rsquo;s stopped state is not the same as an Activity&rsquo;s stopped state. The system manages those two stopped states separately.</p>

<p>注意 程序的停止状态和Activity的停止状态不同,系统会单独处理这两种状态.</p>

<p>The platform defines two new intent flags that let a sender specify whether the Intent should be allowed to activate components in stopped application.
Android平台提供了两个intent flags,用来让发送广播的一方决定广播是否需要同时发送给已经停止的程序.</p>

<p>FLAG_INCLUDE_STOPPED_PACKAGES — Include intent filters of stopped applications in the list of potential targets to resolve against.
将已经支持的程序加入到能处理intent的目标处理者.</p>

<p>FLAG_EXCLUDE_STOPPED_PACKAGES — Exclude intent filters of stopped applications from the list of potential targets.
在能处理intent的目标处理者中不包含已经停止的程序.</p></blockquote>

<p>当如果intnet中没有或者设置了上面两个flag,在目标处理者中是包含已经处于停止的程序.但是注意,系统会为所有的广播intent增加FLAG_EXCLUDE_STOPPED_PACKAGES这个flag.</p>

<h2>为什么Android要引入这一状态</h2>

<p>Note that the system adds FLAG_EXCLUDE_STOPPED_PACKAGES to all broadcast intents. It does this to prevent broadcasts from background services from inadvertently or unnecessarily launching components of stoppped applications. A background service or application can override this behavior by adding the FLAG_INCLUDE_STOPPED_PACKAGES flag to broadcast intents that should be allowed to activate stopped applications.</p>

<p>需要注意的是,系统会默认地对所有的广播intent增加一个FLAG_EXCLUDE_STOPPED_PACKAGES的flag,这样做的目的是为了阻止来自后台服务的广播不慎或者启动处于停止状态的程序的不必要的组件.</p>

<p>通常的intnet广播,处于停止状态的程序的receiver是无法接受到的.那么怎么才能让这些停止状态的程序接受到呢?可以这样做,在后台服务或者应用中发送广播时,增加一个FLAG_INCLUDE_STOPPED_PACKAGES 的flag,意思是包含处于停止状态的程序.这样就可以激活停止状态的程序.</p>

<p>正如上述引用指出,系统默认阻止广播intent发送给处于停止状态的程序包,实际上这是为了保证安全和省电需要.比如说网络变化的广播,如果某些程序注册监听,并且它在得到广播时,做一系列的网络操作,这样必然是很耗能源的.</p>

<h2>激活状态和停止状态的切换</h2>

<p>当程序第一次安装并且没有启动,或者用户手动从程序管理将其停止后,程序都会处于停止状态.</p>

<h3>如何变为停止状态</h3>

<ul>
<li>在设置应用管理中的应用详情页点击强制停止</li>
<li>使用adb shell    <code>adb shell am force-stop package-name</code></li>
<li>使用ActivityManager的隐藏方法forceStopPackages,并且向manifest加入申请权限&lt;uses-permission android:name=&ldquo;android.permission.FORCE_STOP_PACKAGES&rdquo;/></li>
</ul>


<h3>如何脱离停止状态</h3>

<ul>
<li>手动启动程序</li>
<li>使用adb激活应用组件,如activity或者receiver</li>
</ul>


<h2>发送广播intent给处于停止状态的应用</h2>

<ul>
<li>在Java代码发送Intent时,加入flag FLAG_INCLUDE_STOPPED_PACKAGES</li>
<li>如果使用adb,同样是加入FLAG_INCLUDE_STOPPED_PACKAGES(其具体值为32),如<strong>adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -f 32</strong></li>
</ul>


<h2>检查是否处于停止状态</h2>

<ul>
<li>进入设置&mdash;应用管理&mdash;某个应用的详细页,如果强制停止按钮不可用,则说明程序已经处于停止状态.</li>
<li>进入设备终端,查看系统文件<strong>cat /data/system/packages-stopped.xml</strong></li>
</ul>


<h2>问答环节</h2>

<ul>
<li>提问:如果我的程序没有activity只有一个receiver,我改如何激活才能接收到正常的广播intent呢</li>
<li><p>回答:实际上,如果是上面所述的情况,该应用在安装之后不是处于停止状态,因为它没有任何用户可以直接点击的行为去将它移除停止状态.你可以正常接收广播intent,除非你人为地将它强制停止.</p></li>
<li><p>提问:系统的程序刚安装会处于停止状态么?</p></li>
<li><p>回答:系统的程序通常会存放在 /system/app目录下,在一开始安装之后不会处于停止状态.</p></li>
<li><p>提问:Google Play的推广广播据说是在程序安装完成之后发送,是不是3.1之后受影响么</p></li>
<li>回答:不受影响的.Google文档说INSTALL_REFERRER会在程序安装完成之后发送,据实际查看日志观察,从3.1之后,是在程序安装后第一次打开时发送.</li>
</ul>


<h2>引用参考</h2>

<p><a href="http://developer.android.com/about/versions/android-3.1.html" target="_blank">Android 3.1 Hignlight</a></p>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00EOIDFX8/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00EOIDFX8&linkCode=as2&tag=droidyue-23">Android开发权威指南</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00EOIDFX8" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B007PMPHJA/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B007PMPHJA&linkCode=as2&tag=droidyue-23">Android框架揭秘</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B007PMPHJA" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解密:Android设置默认程序]]></title>
    <link href="http://droidyue.com/blog/2014/07/13/set-preferred-application-in-android-chinese-edition/"/>
    <updated>2014-07-13T12:09:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/13/set-preferred-application-in-android-chinese-edition</id>
    <content type="html"><![CDATA[<p>Android作为一个伟大的系统,自然提供了设置默认打开程序的实现.在这篇文章中,我会介绍如何在Android系统中设置默认的程序. 在设置默认程序之前,无非有两种情况,一种是已经有默认的程序,另一种则是没有任何默认程序.</p>

<!--more-->


<h2>检测是否有默认的程序</h2>

<p>检查是必须的,因为结果关乎着我们下一步该怎么做.
```java</p>

<pre><code>public void testGetDefaultActivity() {
    PackageManager pm = mContext.getPackageManager();
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setData(Uri.parse("http://www.google.com"));
    ResolveInfo info = pm.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
    Log.i(VIEW_LOG_TAG, "getDefaultActivity info = " + info + ";pkgName = " + info.activityInfo.packageName);
</code></pre>

<p>}
<code>
其对应的日志输出如下
</code>java
I/View    ( 1145 ): View getDefaultActivity info = ResolveInfo{410e4868 com.android.internal.app.ResolverActivity p=0 o=0 m=0x0};pkgName = android
```
如果没有默认的程序,那么就会显示出默认的就会显示com.android.internal.app.ResolverActivity,那么这个ResolverActivity是什么呢,其实它就是一个选择打开程序的对话框,其庐山真面目应该是这样
<img class="<a" src="href="http://droidyueimg.qiniudn.com/resolveactivity.png">http://droidyueimg.qiniudn.com/resolveactivity.png</a>" title="Android ResolverActivity" ></p>

<p>如果我们设置了傲游浏览器作为我们的默认浏览器,那么默认的程序就应该显示关于傲游浏览器相关的信息. 如下.
<code>java
I/View    ( 1145 ): View getDefaultActivity info = ResolveInfo{410ae1e8 com.mx.browser.MxBrowserActivity p=0 o=0 m=0x208000};pkgName = com.mx.browser
</code>
那么如何判断是否设置了默认的程序呢,上面的方法默认的ResolveInfo,如果info.activityInfo.packageName为android,则没有设置,否则,有默认的程序.
```
public final boolean hasPreferredApplication(final Context context, final Intent intent) {</p>

<pre><code>PackageManager pm = context.getPackageManager();
ResolveInfo info = pm.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
return !"android".equals(info.activityInfo.packageName);
</code></pre>

<p>}
```</p>

<h2>如果有默认程序</h2>

<p>我们需要做的是将现在的默认的程序的默认设置清除.</p>

<p>我们能通过代码直接将默认设置改写成我们的么,实际上是不行的,因为权限的问题. 原因是这样的Android因为基于Linux 内核,Linux有着很棒的用户概念,而Android中每个应用就是一个在Linux内核中的用户.两个级别相同的用户无法删除对方.</p>

<p>所以,我们只能交给用户手动做.当然这也是绝大多数程序的做法.你需要做的就是将使用者带到程序详情页,通过这段代码可以跳转到应用详情页.
```java
public void testStartAppDetails() {</p>

<pre><code>//Use the destination package name
Intent intent = new Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS, Uri.parse("package:com.mx.browser"));
getActivity().startActivity(intent);
</code></pre>

<p>}
```
当跳转到已安装的应用详情页之后,你应该提示用处点击Clear Default 按钮.
<img src="/images/post_images/installed_app_details_clear_default.png"></p>

<p>如果用户从安装详情页回到你的程序,你需要检测是不是用户清理了默认的程序设置,判断依据还是是否有默认的程序设置,如果还有默认的,继续提示需要手动清理其他已设置的程序,直到用户彻底清理完成之后,然后按照下面的没有默认设置程序的情况处理.</p>

<p>注意,存在多次清理的情况,如设置浏览器,先清理了UC默认设置后,可能还需要清理海豚浏览器的情况.</p>

<h2>没有默认的程序.</h2>

<p>如果没有默认的程序,我们就需要设置我们希望的程序作为默认,但是,这页不能在代码中实现,还是需要人为的交互选择才可以.你需要做的就是使用类似如下代码,然后弹出一个提示,告诉用户选择你的程序作为默认的程序.至于提示语你可以充分发挥你的想象力.</p>

<p>```java
public void testStartChooseDialog() {</p>

<pre><code>Intent intent = new Intent();
intent.setAction("android.intent.action.VIEW");
intent.addCategory("android.intent.category.BROWSABLE");
intent.setData(Uri.parse("http://droidyue.com"));
intent.setComponent(new ComponentName("android","com.android.internal.app.ResolverActivity"));
getActivity().startActivity(intent);
</code></pre>

<p>}
```</p>

<h2>取消自己的默认程序设置</h2>

<p>```java
public void testClearDefault() {</p>

<pre><code>PackageManager pm = mContext.getPackageManager();
pm.clearPackagePreferredActivities(mContext.getPackageName());
</code></pre>

<p>}
```</p>

<p>上述方法只能清理自己的默认设置.</p>

<h2>更近一步</h2>

<p>实际上关于默认设置的配置文件存放在/data/system/packages.xml
<code>xml
&lt;preferred-activities&gt;
&lt;item name="com.mx.browser/.MxBrowserActivity" match="200000" set="2"&gt;
&lt;set name="com.android.browser/.BrowserActivity" /&gt;
&lt;set name="com.mx.browser/.MxBrowserActivity" /&gt;
&lt;filter&gt;
&lt;action name="android.intent.action.VIEW" /&gt;
&lt;cat name="android.intent.category.BROWSABLE" /&gt;
&lt;cat name="android.intent.category.DEFAULT" /&gt;
&lt;scheme name="http" /&gt;
&lt;/filter&gt;
&lt;/item&gt;
&lt;/preferred-activities&gt;
</code></p>

<h2>One More Thing</h2>

<ul>
<li>提问:当一个程序程序安装或卸载,系统会做什么</li>
<li><p>回答:当一个程序安装或者卸载,以浏览器为例子,如果你安装了一个傲游浏览器或者卸载了一个UC浏览器,当你从外部程序打开一个链接时,系统不会使用之前的默认程序打开,而是弹出一个选择对话框供你选择.</p></li>
<li><p>提问:什么时候系统会弹出选择打开程序列表</p></li>
<li>回答:经本人测试,实际是这样的,当有一个Intent过来的时候,系统会动态地收集能处理的Activity,然后从/data/system/packages.xml 读取进行比较,如果两者不同,则弹出选择对话框.</li>
</ul>


<h3>Others</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B009OLU8EE/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009OLU8EE&linkCode=as2&tag=droidyue-23">Android系统源代码情景分析</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009OLU8EE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[顶部带进度条的Webview]]></title>
    <link href="http://droidyue.com/blog/2014/07/12/ding-bu-dai-jin-du-tiao-de-webview/"/>
    <updated>2014-07-12T21:34:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/12/ding-bu-dai-jin-du-tiao-de-webview</id>
    <content type="html"><![CDATA[<p>写这篇文章,做份备忘,简单滴展示一个带进度条的Webview示例,进度条位于Webview上面.</p>

<p>示例图如下</p>

<!--more-->


<p><img class="<a" src="href="http://droidyueimg.qiniudn.com/webview_with_progressbar.png">http://droidyueimg.qiniudn.com/webview_with_progressbar.png</a>" title="webview_with_progressbar" ></p>

<h3>主Activity代码</h3>

<p>```java
package com.droidyue.demo.webviewprogressbar;
import android.app.Activity;
import android.os.Bundle;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.webkit.WebChromeClient;
import android.webkit.WebView;
import android.widget.ProgressBar;</p>

<p>import com.droidyue.demo.webviewprogressbar.R;</p>

<p>public class MainActivity extends Activity {</p>

<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    final ProgressBar bar = (ProgressBar)findViewById(R.id.myProgressBar);

    final WebView webView = (WebView)findViewById(R.id.myWebView);
    webView.setWebChromeClient(new WebChromeClient() {

        @Override
        public void onProgressChanged(WebView view, int newProgress) {
            if (newProgress == 100) {
                bar.setVisibility(View.INVISIBLE);
            } else {
                if (View.INVISIBLE == bar.getVisibility()) {
                    bar.setVisibility(View.VISIBLE);
                }
                bar.setProgress(newProgress);
            }
            super.onProgressChanged(view, newProgress);
        }

    });

    findViewById(R.id.myButton).setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View arg0) {
            webView.reload();
        }

    });
    final String url = "http://droidyue.com";
    webView.loadUrl(url);
}


@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
}
</code></pre>

<p>}</p>

<p>```</p>

<h3>布局文件代码</h3>

<p>```xml
&lt;RelativeLayout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:paddingBottom="@dimen/activity_vertical_margin"
android:paddingLeft="@dimen/activity_horizontal_margin"
android:paddingRight="@dimen/activity_horizontal_margin"
android:paddingTop="@dimen/activity_vertical_margin"
tools:context=".MainActivity" &gt;

&lt;Button 
    android:id="@+id/myButton"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Reload"
    /&gt;

&lt;ProgressBar 
    style="?android:attr/progressBarStyleHorizontal"
    android:id="@+id/myProgressBar"
    android:layout_below="@id/myButton"
    android:layout_width="match_parent"
    android:layout_height="5px"
    /&gt;
&lt;WebView 
    android:id="@+id/myWebView"
    android:layout_below="@id/myProgressBar"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    /&gt;
</code></pre>

<p></RelativeLayout></p>

<p><code>
不要忘记在Mainfest加入使用网络权限哟.
</code>xml
&lt;uses-permission android:name=&ldquo;android.permission.INTERNET&rdquo;/>
```</p>

<p>实现很简单,没什么技术含量.备忘而已.</p>

<p>关于如何自定义进度条请参考:<a href="http://winwyf.blog.51cto.com/4561999/857867" target="_blank"><a href="http://winwyf.blog.51cto.com/4561999/857867">http://winwyf.blog.51cto.com/4561999/857867</a></a></p>

<h3>Others</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00ASIN7G8/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00ASIN7G8&linkCode=as2&tag=droidyue-23">精通Android</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00ASIN7G8" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
</feed>
