<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2014-07-20T12:20:30+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android修复通知栏跳动的问题]]></title>
    <link href="http://droidyue.com/blog/2014/07/20/fix-notification-switching-position-issue-chinese-edition/"/>
    <updated>2014-07-20T11:59:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/20/fix-notification-switching-position-issue-chinese-edition</id>
    <content type="html"><![CDATA[<p>曾经遇到过这样的问题，在我的代码中使用了通知栏，一切都正常，但是就是正在进行的通知栏中属于我的程序的那一条总是上下跳来跳去，一闪一闪的。感觉用户体验很不好，于是Google一下，找到了解决方法。</p>

<!-- more -->


<p>在我的代码，我是这样写的。
```java</p>

<pre><code>notification.when = System.currentTimeMillis();
</code></pre>

<p><code>
这就是问题的关键，对于通知来说，when这个属性值应该在activity一启动的时候就应该固定。如果没有固定，就会使用默认的值，默认的值就是当前的时间，即`System.currentTimeMillis()`的值。因此使用一个自定义的固定值就可以解决问题。
</code>java
final long TIMESTAMP_FIXED = 1234567890l;
notification.when = TIMESTAMP_FIXED;
```
以下如Google介绍如何使用notification的when的说明。</p>

<blockquote><p>A timestamp related to this notification, in milliseconds since the epoch. Default value: Now. Choose a timestamp that will be most relevant to the user. For most finite events, this corresponds to the time the event happened (or will happen, in the case of events that have yet to occur but about which the user is being informed). Indefinite events should be timestamped according to when the activity began. Some examples:</p>

<ul>
<li>Notification of a new chat message should be stamped when the message was received.</li>
<li>Notification of an ongoing file download (with a progress bar, for example) should be stamped when the download started.</li>
<li>Notification of a completed file download should be stamped when the download finished.</li>
<li>Notification of an upcoming meeting should be stamped with the time the meeting will begin (that is, in the future).</li>
<li>Notification of an ongoing stopwatch (increasing timer) should be stamped with the watch&rsquo;s start time.</li>
<li>Notification of an ongoing countdown timer should be stamped with the timer&rsquo;s end time.</li>
</ul>
</blockquote>

<h3>Reference</h3>

<ul>
<li><a href="http://developer.android.com/reference/android/app/Notification.html#when">http://developer.android.com/reference/android/app/Notification.html#when</a></li>
</ul>


<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00J91AF9C/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00J91AF9C&linkCode=as2&tag=droidyue-23">打造高质量Android应用:Android开发必知的50个诀窍</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00J91AF9C" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B00D2ID4PK/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00D2ID4PK&linkCode=as2&tag=droidyue-23">深入理解Java虚拟机:JVM高级特性与最佳实践</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00D2ID4PK" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你真的懂么:Android中删除Preference]]></title>
    <link href="http://droidyue.com/blog/2014/07/18/remove-a-preference-from-the-screen/"/>
    <updated>2014-07-18T20:50:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/18/remove-a-preference-from-the-screen</id>
    <content type="html"><![CDATA[<p>Android的设置界面实现比较简单,有时甚至只需要使用一个简单的xml文件即可.声明简单,但是如何从PreferenceScreen或者PreferenceCategory中删除一个Preference会简单么.为什么有些人写的就无法删除成功呢?本文将从Android源码实现来分析一下.</p>

<!--more-->


<h2>声明文件</h2>

<p>```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;PreferenceScreen xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>android:key="root"&gt;

&lt;PreferenceCategory 
    android:key="theme" 
    android:title="Theme"
    android:summary="Theme Settings"
    &gt;
    &lt;CheckBoxPreference
        android:key="holo_theme"
        android:title="Holo Theme"
        android:summary="Use Holo Theme"
        /&gt;

&lt;/PreferenceCategory&gt;

&lt;CheckBoxPreference
    android:key="rmcache"
    android:title="Auto Clear Cache"
    android:summary="Enable Auto Clear Cache "
    /&gt;
</code></pre>

<p></PreferenceScreen>
```</p>

<h2>层级关系</h2>

<p>{%img <a href="http://droidyueimg.qiniudn.com/preference_family_tree.png">http://droidyueimg.qiniudn.com/preference_family_tree.png</a> preferece family tree %}</p>

<h2>删除Preference</h2>

<ul>
<li><p>删除key为rmcache的Preference,这个Preference是PreferenceScreen root的子节点.
<code>java
PreferenceScreen screen = getPreferenceScreen();
CheckBoxPreference autoClearCheckboxPref = (CheckBoxPreference) screen.findPreference("rmcache");
screen.removePreference(autoClearCheckboxPref);
</code></p></li>
<li><p>删除key为holo_theme的Preference,其为PreferenceScreen root的孙子节点,非直接关系.
<code>java
PreferenceCategory themePrefCategory = (PreferenceCategory) screen.findPreference("theme");
CheckBoxPreference holoCheckboxPref = (CheckBoxPreference)themePrefCategory.findPreference("holo_theme");
themePrefCategory.removePreference(holoCheckboxPref);
</code></p>

<h2>为什么删除失败</h2>

很多人出现了删除失败的问题,主要原因是使用了非父亲节点来删除,比如这样
<code>java
PreferenceScreen screen = getPreferenceScreen();
CheckBoxPreference holoCheckboxPref = (CheckBoxPreference)screen.findPreference("holo_theme");
screen.removePreference(holoCheckboxPref);
</code>
PreferenceGroup删除实现,其实PreferenceScreen和PreferenceCategory都是PreferenceGroup的子类.
```java
/**

<ul>
<li>Removes a {@link Preference} from this group.</li>
<li></li>
<li>@param preference The preference to remove.</li>
<li>@return Whether the preference was found and removed.
*/
public boolean removePreference(Preference preference) {
 final boolean returnValue = removePreferenceInt(preference);
 notifyHierarchyChanged();
 return returnValue;
}</li>
</ul>


<p>private boolean removePreferenceInt(Preference preference) {
    synchronized(this) {
        preference.onPrepareForRemoval();
        return mPreferenceList.remove(preference);
    }
}
```
而mPreferenceList中存放的都是当前PreferenceGroup的直接子Preference.</p></li>
</ul>


<h2>findPreference实现</h2>

<p>findPreference查找不仅仅限于直接子Preference,会遍历其所有的子Preference.</p>

<p>所以代码中同样有root PreferenceGroup和直接父PreferenceGroup引用时,通常后者效率会高.
```java</p>

<pre><code>/**
 * Finds a {@link Preference} based on its key. If two {@link Preference}
 * share the same key (not recommended), the first to appear will be
 * returned (to retrieve the other preference with the same key, call this
 * method on the first preference). If this preference has the key, it will
 * not be returned.
 * &lt;p&gt;
 * This will recursively search for the preference into children that are
 * also {@link PreferenceGroup PreferenceGroups}.
 * 
 * @param key The key of the preference to retrieve.
 * @return The {@link Preference} with the key, or null.
 */
public Preference findPreference(CharSequence key) {
    if (TextUtils.equals(getKey(), key)) {
        return this;
    }
    final int preferenceCount = getPreferenceCount();
    for (int i = 0; i &lt; preferenceCount; i++) {
        final Preference preference = getPreference(i);
        final String curKey = preference.getKey();

        if (curKey != null &amp;&amp; curKey.equals(key)) {
            return preference;
        }

        if (preference instanceof PreferenceGroup) {
            final Preference returnedPreference = ((PreferenceGroup)preference)
                    .findPreference(key);
            if (returnedPreference != null) {
                return returnedPreference;
            }
        }
    }

    return null;
}
</code></pre>

<p>```</p>

<h2>findPreference和removePreference实现比较</h2>

<p>为什么findPreference遍历所有的子节点,而removePreference不会,只会删除直接子Preference</p>

<h3>原因有以下几点:</h3>

<ul>
<li>findPreference支持遍历查找,减少了声明诸多的中间PreferenceGroup代码.而findPreference属于常用接口方法.</li>
<li>removePreference调用较少.</li>
<li>当存在key相同的Preference时,如果removePreference不限定直接子Preference,那么无法准确删除哪一个.</li>
</ul>


<hr />

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00CJ368JS/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00CJ368JS&linkCode=as2&tag=droidyue-23">Android的设计与实现</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00CJ368JS" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B009OLU8EE/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009OLU8EE&linkCode=as2&tag=droidyue-23">Android系统源代码情景分析</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009OLU8EE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义控件进阶:declare-styleable重用attr]]></title>
    <link href="http://droidyue.com/blog/2014/07/16/better-in-android-include-attrs-in-declare-stylable/"/>
    <updated>2014-07-16T19:37:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/16/better-in-android-include-attrs-in-declare-stylable</id>
    <content type="html"><![CDATA[<p>最近接触了Android自定义控件,涉及到自定义xml中得属性(attribute),其实也很简单,但是写着写着,发现代码不完美了,就是在attrs.xml这个文件中,发现属性冗余,于是就想有没有类似属性继承或者include之类的方法.本文将就declare-stylable中属性重用记录一下.</p>

<!--more-->


<h2>不完美的代码</h2>

<p>```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<resources></p>

<pre><code>&lt;declare-styleable name="ExTextView"&gt;
   &lt;attr name="enableOnPad" format="boolean" /&gt;
   &lt;attr name="supportDeviceType" format="reference"/&gt;
&lt;/declare-styleable&gt;

&lt;declare-styleable name="ExEditText"&gt;
   &lt;attr name="enableOnPad" format="boolean" /&gt;
   &lt;attr name="supportDeviceType" format="reference"/&gt;  
&lt;/declare-styleable&gt;
</code></pre>

<p></resources>
```
如上面代码,在ExTextView和ExEditText这个stylable中有着重复的属性申明.虽然上面可以工作,但是总感觉写的不专业,于是寻找优化方法.</p>

<h2>这样可以么</h2>

<p>尝试着为declare-stylable指定一个parent,如下代码
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<resources></p>

<pre><code>&lt;declare-styleable name="ExTextView"&gt;
   &lt;attr name="enableOnPad" format="boolean" /&gt;
   &lt;attr name="supportDeviceType" format="reference"/&gt;
&lt;/declare-styleable&gt;

&lt;declare-styleable name="ExEditText" parent="ExTextView"&gt;

&lt;/declare-styleable&gt;
</code></pre>

<p></resources>
```
attrs.xml没有报告语法错误.但是当我使用<strong>R.styleable.ExEditText_supportDeviceType</strong>时候,R文件却没有生成,重新清理了工程还是不生效,不知道是否为adt插件的问题.其他人也遇到了这样的问题. <strong>这个方法目前是不行的</strong>.</p>

<h2>终极答案</h2>

<p>实际上我们可以在declare-stylable之前,申明要多次使用的属性,在declare-stylable节点内部,只需调用即可.具体代码如下.
```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<resources></p>

<pre><code>&lt;attr name="enableOnPad" format="boolean" /&gt;
&lt;attr name="supportDeviceType" format="reference"/&gt;

&lt;declare-styleable name="ExTextView"&gt;
    &lt;attr name="enableOnPad"/&gt;
    &lt;attr name="supportDeviceType"/&gt;
&lt;/declare-styleable&gt;

&lt;declare-styleable name="ExEditText"&gt;
    &lt;attr name="enableOnPad"/&gt;
    &lt;attr name="supportDeviceType"/&gt;    
&lt;/declare-styleable&gt;
</code></pre>

<p></resources>
```
每次引用attr后,建议清理一下工程,确保R文件重新生成.</p>

<h2>延伸阅读</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/18827875/how-to-declare-several-stylable-attributes-with-the-same-name-for-different-tags">http://stackoverflow.com/questions/18827875/how-to-declare-several-stylable-attributes-with-the-same-name-for-different-tags</a></li>
</ul>


<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B009OLU8EE/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009OLU8EE&linkCode=as2&tag=droidyue-23">Android系统源代码情景分析</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009OLU8EE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android支持动态申请权限么]]></title>
    <link href="http://droidyue.com/blog/2014/07/16/does-android-support-granting-permission-dynamiclly/"/>
    <updated>2014-07-16T18:52:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/16/does-android-support-granting-permission-dynamiclly</id>
    <content type="html"><![CDATA[<p>作为Android开发者,为程序增加权限是在正常不过的事情了,做法必然是在mainifest中,写入类似这样<code>&lt;uses-permission android:name="android.permission.INTERNET" /&gt;</code>的信息. 以静态申请的形式来完成. 于是这里我想抛出一个问题,Android平台支持动态申请权限么.</p>

<!--more-->


<p>相信很多人回答都是不支持,当然这个答案是对的,但是为什么不支持呢,知其然更要知其所以然.了解其原因还是相当有必要的.</p>

<h2>原因列举</h2>

<ul>
<li><p>Android没有提供动态申请权限的机制.</p></li>
<li><p>目前的静态申请可以将权限安全隐患放在程序安装之前一次提示搞定,而如果动态申请,就会时不时弹出申请框.这样的用户体验太差了.</p></li>
<li><p>一些权限申请需要依赖于设备的feature(特性),使用静态申请可以明确知道设备需要的特性,Google Play根据程序需要的特性和目标设备具有的特性来决定该设备是否被展示和安装.而动态申请无法明确知道需要的feature.可能导致可以展示的应用无法安装.</p></li>
<li><p>可能会带来安全隐患问题.</p></li>
</ul>


<h2>延伸阅读</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/4838779/get-android-permission-dynamiclly">http://stackoverflow.com/questions/4838779/get-android-permission-dynamiclly</a></li>
<li><a href="http://stackoverflow.com/questions/7517171/is-there-any-way-to-ask-permission-programmatically">http://stackoverflow.com/questions/7517171/is-there-any-way-to-ask-permission-programmatically</a></li>
</ul>


<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B009OLU8EE/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009OLU8EE&linkCode=as2&tag=droidyue-23">Android系统源代码情景分析</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009OLU8EE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你造么,Android中程序的停止状态]]></title>
    <link href="http://droidyue.com/blog/2014/07/14/look-inside-android-package-stop-state-since-honeycomb-mr1/"/>
    <updated>2014-07-14T19:46:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/14/look-inside-android-package-stop-state-since-honeycomb-mr1</id>
    <content type="html"><![CDATA[<p>很多人遇到过广播收不到的问题,比如Google Play推广安装广播没有收到等,诸如这些问题,又都是什么原因呢,这篇文章将进行回答.</p>

<p>从Android 3.1(HoneyComb) 也就是API 12开始,Android引入了一套新的启动控制,这就是程序的停止状态.那让我们看一下Google对于程序的停止状态的描述.</p>

<!--more-->


<h2>什么是程序的停止状态</h2>

<blockquote><p>Starting from Android 3.1, the system&rsquo;s package manager keeps track of applications that are in a stopped state and provides a means of controlling their launch from background processes and other applications.</p>

<p>从Android 3.1开始,系统的包管理器开始跟踪处理停止状态的程序.并且提供了方法来控制从后台进程或者其他程序对它们的启动.</p>

<p>Note that an application&rsquo;s stopped state is not the same as an Activity&rsquo;s stopped state. The system manages those two stopped states separately.</p>

<p>注意 程序的停止状态和Activity的停止状态不同,系统会单独处理这两种状态.</p>

<p>The platform defines two new intent flags that let a sender specify whether the Intent should be allowed to activate components in stopped application.
Android平台提供了两个intent flags,用来让发送广播的一方决定广播是否需要同时发送给已经停止的程序.</p>

<p>FLAG_INCLUDE_STOPPED_PACKAGES — Include intent filters of stopped applications in the list of potential targets to resolve against.
将已经支持的程序加入到能处理intent的目标处理者.</p>

<p>FLAG_EXCLUDE_STOPPED_PACKAGES — Exclude intent filters of stopped applications from the list of potential targets.
在能处理intent的目标处理者中不包含已经停止的程序.</p></blockquote>

<p>当如果intnet中没有或者设置了上面两个flag,在目标处理者中是包含已经处于停止的程序.但是注意,系统会为所有的广播intent增加FLAG_EXCLUDE_STOPPED_PACKAGES这个flag.</p>

<h2>为什么Android要引入这一状态</h2>

<p>Note that the system adds FLAG_EXCLUDE_STOPPED_PACKAGES to all broadcast intents. It does this to prevent broadcasts from background services from inadvertently or unnecessarily launching components of stoppped applications. A background service or application can override this behavior by adding the FLAG_INCLUDE_STOPPED_PACKAGES flag to broadcast intents that should be allowed to activate stopped applications.</p>

<p>需要注意的是,系统会默认地对所有的广播intent增加一个FLAG_EXCLUDE_STOPPED_PACKAGES的flag,这样做的目的是为了阻止来自后台服务的广播不慎或者启动处于停止状态的程序的不必要的组件.</p>

<p>通常的intnet广播,处于停止状态的程序的receiver是无法接受到的.那么怎么才能让这些停止状态的程序接受到呢?可以这样做,在后台服务或者应用中发送广播时,增加一个FLAG_INCLUDE_STOPPED_PACKAGES 的flag,意思是包含处于停止状态的程序.这样就可以激活停止状态的程序.</p>

<p>正如上述引用指出,系统默认阻止广播intent发送给处于停止状态的程序包,实际上这是为了保证安全和省电需要.比如说网络变化的广播,如果某些程序注册监听,并且它在得到广播时,做一系列的网络操作,这样必然是很耗能源的.</p>

<h2>激活状态和停止状态的切换</h2>

<p>当程序第一次安装并且没有启动,或者用户手动从程序管理将其停止后,程序都会处于停止状态.</p>

<h3>如何变为停止状态</h3>

<ul>
<li>在设置应用管理中的应用详情页点击强制停止</li>
<li>使用adb shell    <code>adb shell am force-stop package-name</code></li>
<li>使用ActivityManager的隐藏方法forceStopPackages,并且向manifest加入申请权限&lt;uses-permission android:name=&ldquo;android.permission.FORCE_STOP_PACKAGES&rdquo;/></li>
</ul>


<h3>如何脱离停止状态</h3>

<ul>
<li>手动启动程序</li>
<li>使用adb激活应用组件,如activity或者receiver</li>
</ul>


<h2>发送广播intent给处于停止状态的应用</h2>

<ul>
<li>在Java代码发送Intent时,加入flag FLAG_INCLUDE_STOPPED_PACKAGES</li>
<li>如果使用adb,同样是加入FLAG_INCLUDE_STOPPED_PACKAGES(其具体值为32),如<strong>adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -f 32</strong></li>
</ul>


<h2>检查是否处于停止状态</h2>

<ul>
<li>进入设置&mdash;应用管理&mdash;某个应用的详细页,如果强制停止按钮不可用,则说明程序已经处于停止状态.</li>
<li>进入设备终端,查看系统文件<strong>cat /data/system/packages-stopped.xml</strong></li>
</ul>


<h2>问答环节</h2>

<ul>
<li>提问:如果我的程序没有activity只有一个receiver,我改如何激活才能接收到正常的广播intent呢</li>
<li><p>回答:实际上,如果是上面所述的情况,该应用在安装之后不是处于停止状态,因为它没有任何用户可以直接点击的行为去将它移除停止状态.你可以正常接收广播intent,除非你人为地将它强制停止.</p></li>
<li><p>提问:系统的程序刚安装会处于停止状态么?</p></li>
<li><p>回答:系统的程序通常会存放在 /system/app目录下,在一开始安装之后不会处于停止状态.</p></li>
<li><p>提问:Google Play的推广广播据说是在程序安装完成之后发送,是不是3.1之后受影响么</p></li>
<li>回答:不受影响的.Google文档说INSTALL_REFERRER会在程序安装完成之后发送,据实际查看日志观察,从3.1之后,是在程序安装后第一次打开时发送.</li>
</ul>


<h2>引用参考</h2>

<p><a href="http://developer.android.com/about/versions/android-3.1.html" target="_blank">Android 3.1 Hignlight</a></p>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00EOIDFX8/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00EOIDFX8&linkCode=as2&tag=droidyue-23">Android开发权威指南</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00EOIDFX8" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B007PMPHJA/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B007PMPHJA&linkCode=as2&tag=droidyue-23">Android框架揭秘</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B007PMPHJA" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
</feed>
