<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2015-01-19T23:04:08+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android中处理Touch Icon的方案]]></title>
    <link href="http://droidyue.com/blog/2015/01/18/deal-with-touch-icon-in-android/"/>
    <updated>2015-01-18T21:23:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/01/18/deal-with-touch-icon-in-android</id>
    <content type="html"><![CDATA[<p>苹果的Touch Icon相对我们都比较熟悉，是苹果为了支持网络应用（或者说网页）添加到桌面需要的图标，有了这些Touch Icon的网页链接更加和Native应用更相像了。由于苹果设备IPod，IPhone,IPad等设备广泛，很多网页都提供了touch icon这种图标资源。由于Android中并没有及早的有一份这样的标准，当我们想把网页添加到桌面时，仍然需要使用苹果的Touch Icon。</p>

<!--more-->


<h2>Touch Icon</h2>

<p>当我们想让一个网页比较完美地添加到桌面，通常情况下我们需要设置一个png图片文件作为apple-touch-icon。比如
<code>html
&lt;link rel="apple-touch-icon" href="http://droidyue.com/custom_icon.png"&gt;
</code>
如果想支持IPhone和IPad，我们需要使用sizes属性来制定多个图片，默认sizes的值为60 x 60。
<code>html
&lt;link rel="apple-touch-icon" href="touch-icon-iphone.png"&gt;
&lt;link rel="apple-touch-icon" sizes="76x76" href="touch-icon-ipad.png"&gt;
&lt;link rel="apple-touch-icon" sizes="120x120" href="touch-icon-iphone-retina.png"&gt;
&lt;link rel="apple-touch-icon" sizes="152x152" href="touch-icon-ipad-retina.png"&gt;
</code>
在IOS7之前，苹果系统会对添加到桌面的图标进行圆角化等视觉上的处理，为了不让其处理，我们可以使用apple-touch-icon-precomposed来作为rel的值实现。</p>

<p>更多关于Touch Icon的信息，可以访问<a href="https://developer.apple.com/library/mac/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html">水果开发者网站</a>了解更多。</p>

<h2>Android中有缺陷的实现</h2>

<p>在Android WebView提供了处理Touch Icon的回调，<code>onReceivedTouchIconUrl(WebView view, String url,boolean precomposed)</code>该方法返回了对我们有用的touch icon的url，和是否为预组合（在IOS中不需要进行视觉处理）。虽然有这些数据，我们可以进行处理，但是这其中是有问题的，就是我们不好确定文件的大小，来选择适合的图片。</p>

<p>举个例子,如下一个网页的源码，其中sizes的顺序不规律
<code>html
&lt;link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://www.qiyipic.com/20130423143600/fix/H5-72x72.png"&gt;
&lt;link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://www.qiyipic.com/20130423143600/fix/H5-114x114.png"&gt;
&lt;link rel="apple-touch-icon-precomposed" sizes="57x57" href="http://www.qiyipic.com/20130423143600/fix/H5-57x57.png"&gt;
&lt;link rel="apple-touch-icon-precomposed"  href="http://www.qiyipic.com/20130423143600/fix/H5-0x0.png"&gt;
</code>
加载网页，onReceivedTouchIconUrl输出的日志
<code>bash
I/MainActivity( 6995): onReceivedTouchIconUrl url=http://www.qiyipic.com/20130423143600/fix/H5-0x0.png;precomposed=true
I/MainActivity( 6995): onReceivedTouchIconUrl url=http://www.qiyipic.com/20130423143600/fix/H5-57x57.png;precomposed=true
I/MainActivity( 6995): onReceivedTouchIconUrl url=http://www.qiyipic.com/20130423143600/fix/H5-114x114.png;precomposed=true
I/MainActivity( 6995): onReceivedTouchIconUrl url=http://www.qiyipic.com/20130423143600/fix/H5-72x72.png;precomposed=true
</code>
从上面的输出来看，基本上是后面（书写）的元素先打印出来，所以这个回调的缺陷如下</p>

<ul>
<li>由于Touch Icon url地址没有硬性规定，不能根据url包含某些尺寸来判断使用哪个icon</li>
<li>由于网页编写touch icon元素相对随意，不能根据onReceivedTouchIconUrl调用先后来决定使用哪个icon</li>
<li>回调中没有sizes属性值，不好确定使用哪个icon</li>
<li>如果我们选取质量最高的图片，然后进行适当压缩处理或许可以解决问题，但是将全部icon下载下来或者根据Head头信息总感觉不怎么好。</li>
</ul>


<h2>改进方法</h2>

<p>既然WebView没有现成的方法满足我们的需求，只好自己来实现。其实实现方法还是比较简单地就是js脚本注入检测网页元素中得touch icon，返回json数据。</p>

<h3>JavaScript方法</h3>

<p>下面的JS代码所做的功能为查找所有为touch icon的link元素，包含正常的还标记为precomposed。然后将这些link元素的属性存入json数据，最后返回给Java代码中对应的回调。
```javascript
var touchIcons = [];
function gatherTouchIcons(elements) {</p>

<pre><code>var normalTouchIconLength = elements.length;
var currentElement;
for (var i =0; i &lt; normalTouchIconLength;i++) {
    currentElement = elements[i];
    var size;
    if (currentElement.hasAttribute('sizes')) {
        size = currentElement.sizes[0];
    } else {
        size = '';
    }
    var info = {'sizes':size, 'rel': currentElement.rel, 'href': currentElement.href};
    touchIcons.push(info);
}
</code></pre>

<p>}</p>

<p>function obtainTouchIcons() {</p>

<pre><code>normalElements = document.querySelectorAll("link[rel='apple-touch-icon']");
precomposedElements = document.querySelectorAll("link[rel='apple-touch-icon-precomposed']");
gatherTouchIcons(normalElements);
gatherTouchIcons(precomposedElements);
var info = JSON.stringify(touchIcons);
window.app_native.onReceivedTouchIcons(document.URL, info);
</code></pre>

<p>}
obtainTouchIcons();
```</p>

<h3>Java代码</h3>

<p>这里为了便于理解还是全部贴出了demo的源码，demo中当网页加载完成之后注入上面的js代码获取touch icon信息，然后返回给java的回调方法中。如果不清楚Java和JavaScript交互，可以访问<a href="http://droidyue.com/blog/2014/09/20/interaction-between-java-and-javascript-in-android/">Android中Java和JavaScript交互</a>了解更多。
```java
package com.example.obtaintouchicon;</p>

<p>import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;</p>

<p>import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.webkit.JavascriptInterface;
import android.webkit.WebChromeClient;
import android.webkit.WebView;
import android.webkit.WebViewClient;</p>

<p>public class MainActivity extends Activity {</p>

<pre><code>protected String LOGTAG = "MainActivity";

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    WebView webView = new WebView(this);
    webView.getSettings().setJavaScriptEnabled(true);
    webView.setWebViewClient(new WebViewClient() {
        @Override
        public void onPageFinished(WebView view, String url) {
            super.onPageFinished(view, url);
            final String touchIconJsCode = getTouchIconJsCode();
            Log.i(LOGTAG , "onPageFinished url = " + url + ";touchIconJsCode=" + touchIconJsCode);
            view.loadUrl("javascript:" + touchIconJsCode);
        }
    });
    webView.addJavascriptInterface(new JsObject(), "app_native");
    webView.loadUrl("http://192.168.1.5:8000/html/touchicon.html");
}


private class JsObject {

    @JavascriptInterface
    public void onReceivedTouchIcons(String url, String json) {
        Log.i(LOGTAG, "onReceivedTouchIcons url=" + url + ";json=" + json);
    }
}

private String getTouchIconJsCode() {
    StringBuilder total = new StringBuilder();
    InputStream inputStream = null;
    BufferedReader bufferReader = null;
    try {
        inputStream = getAssets().open("touchicon.js");
        bufferReader = new BufferedReader(new InputStreamReader(inputStream));
        String line;
        while ((line = bufferReader.readLine()) != null) {
            total.append(line);
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (null != inputStream) {
            try {
                inputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    return total.toString();
}
</code></pre>

<p>}
```</p>

<h3>返回的JSON数据</h3>

<p>```java
[</p>

<pre><code>{
    "sizes":"72x72",
    "rel":"apple-touch-icon-precomposed",
    "href":"http://www.qiyipic.com/20130423143600/fix/H5-72x72.png"
},
{
    "sizes":"114x114",
    "rel":"apple-touch-icon-precomposed",
    "href":"http://www.qiyipic.com/20130423143600/fix/H5-114x114.png"
},
{
    "sizes":"57x57",
    "rel":"apple-touch-icon-precomposed",
    "href":"http://www.qiyipic.com/20130423143600/fix/H5-57x57.png"
},
{
    "sizes":"",
    "rel":"apple-touch-icon-precomposed",
    "href":"http://www.qiyipic.com/20130423143600/fix/H5-0x0.png"
}
</code></pre>

<p>]
```
我们可以对得到的JSON数据按照需要处理。</p>

<h2>Google会改进么</h2>

<p>答案是会，而且已经改进，但Google修改的不是onReceivedTouchIconUrl这个方法，而是Google正在推行自己的一套规则。</p>

<p>在Chrome上，Google增加了这样一个元素，这是Google提供的为网页程序定义元数据的方法。
<code>html
&lt;link rel="manifest" href="manifest.json"&gt;
</code>
在元数据json中，你可以自定义title，起始页，程序是横屏还是竖屏展示。一个简单地json实例如下，这里我们可以看到其中icons中存在多个类似touch icon的图标，src代表图标路径，sizes代表大小，type就是mimetype，density指的是Android中的屏幕密度（这样更加Android化了）。
```java
{
  &ldquo;name&rdquo;: &ldquo;Web Application Manifest Sample&rdquo;,
  &ldquo;icons&rdquo;: [</p>

<pre><code>{
  "src": "launcher-icon-0-75x.png",
  "sizes": "36x36",
  "type": "image/png",
  "density": "0.75"
},
{
  "src": "launcher-icon-1x.png",
  "sizes": "48x48",
  "type": "image/png",
  "density": "1.0"
},
{
  "src": "launcher-icon-1-5x.png",
  "sizes": "72x72",
  "type": "image/png",
  "density": "1.5"
},
{
  "src": "launcher-icon-2x.png",
  "sizes": "96x96",
  "type": "image/png",
  "density": "2.0"
},
{
  "src": "launcher-icon-3x.png",
  "sizes": "144x144",
  "type": "image/png",
  "density": "3.0"
},
{
  "src": "launcher-icon-4x.png",
  "sizes": "192x192",
  "type": "image/png",
  "density": "4.0"
}
</code></pre>

<p>  ],
  &ldquo;start_url&rdquo;: &ldquo;index.html&rdquo;,
  &ldquo;display&rdquo;: &ldquo;standalone&rdquo;,
  &ldquo;orientation&rdquo;: &ldquo;landscape&rdquo;
}
```
关于Google这套新的标准，可以参考<a href="https://developer.chrome.com/multidevice/android/installtohomescreen">Add to Homescreen</a></p>

<p>但是由于目前，这种标准实施率相对比较低，所以我们还是需要使用苹果的touch icon。</p>

<h2>推荐阅读</h2>

<ul>
<li><a href="https://mathiasbynens.be/notes/touch-icons">Everything you always wanted to know about touch icons</a></li>
</ul>


<h2>源码下载</h2>

<ul>
<li><a href="http://pan.baidu.com/s/1dDD3gZZ">http://pan.baidu.com/s/1dDD3gZZ</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中Handler引起的内存泄露]]></title>
    <link href="http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur/"/>
    <updated>2014-12-28T11:24:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur</id>
    <content type="html"><![CDATA[<p>在Android常用编程中，Handler在进行异步操作并处理返回结果时经常被使用。通常我们的代码会这样实现。
```java
public class SampleActivity extends Activity {</p>

<p>  private final Handler mLeakyHandler = new Handler() {</p>

<pre><code>@Override
public void handleMessage(Message msg) {
  // ... 
}
</code></pre>

<p>  }
}
```</p>

<!--more-->


<p>但是，其实上面的代码可能导致内存泄露，当你使用Android lint工具的话，会得到这样的警告</p>

<blockquote><p>In Android, Handler classes should be static or leaks might occur, Messages enqueued on the application thread&rsquo;s MessageQueue also retain their target Handler. If the Handler is an inner class, its outer class will be retained as well. To avoid leaking the outer class, declare the Handler as a static nested class with a WeakReference to its outer class</p></blockquote>

<p>看到这里，可能还是有一些搞不清楚，代码中哪里可能导致内存泄露，又是如何导致内存泄露的呢？那我们就慢慢分析一下。</p>

<p>1.当一个Android应用启动的时候，会自动创建一个供应用主线程使用的Looper实例。Looper的主要工作就是一个一个处理消息队列中的消息对象。在Android中，所有Android框架的事件（比如Activity的生命周期方法调用和按钮点击等）都是放入到消息中，然后加入到Looper要处理的消息队列中，由Looper负责一条一条地进行处理。主线程中的Looper生命周期和当前应用一样长。</p>

<p>2.当一个Handler在主线程进行了初始化之后，我们发送一个target为这个Handler的消息到Looper处理的消息队列时，实际上已经发送的消息已经包含了一个Handler实例的引用，只有这样Looper在处理到这条消息时才可以调用Handler#handleMessage(Message)完成消息的正确处理。</p>

<p>3.在Java中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用。静态的内部类不会持有外部类的引用。关于这一内容可以查看<a href="http://droidyue.com/blog/2014/10/02/the-private-modifier-in-java/">细话Java："失效"的private修饰符</a></p>

<p>确实上面的代码示例有点难以察觉内存泄露，那么下面的例子就非常明显了
```java
public class SampleActivity extends Activity {</p>

<p>  private final Handler mLeakyHandler = new Handler() {</p>

<pre><code>@Override
public void handleMessage(Message msg) {
  // ...
}
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);

// Post a message and delay its execution for 10 minutes.
mLeakyHandler.postDelayed(new Runnable() {
  @Override
  public void run() { /* ... */ }
}, 1000 * 60 * 10);

// Go back to the previous Activity.
finish();
</code></pre>

<p>  }
}
```
分析一下上面的代码，当我们执行了Activity的finish方法，被延迟的消息会在被处理之前存在于主线程消息队列中10分钟，而这个消息中又包含了Handler的引用，而Handler是一个匿名内部类的实例，其持有外面的SampleActivity的引用，所以这导致了SampleActivity无法回收，进行导致SampleActivity持有的很多资源都无法回收，这就是我们常说的内存泄露。</p>

<p>注意上面的new Runnable这里也是匿名内部类实现的，同样也会持有SampleActivity的引用，也会阻止SampleActivity被回收。</p>

<p>要解决这种问题，思路就是不适用非静态内部类，继承Handler时，要么是放在单独的类文件中，要么就是使用静态内部类。因为静态的内部类不会持有外部类的引用，所以不会导致外部类实例的内存泄露。当你需要在静态内部类中调用外部的Activity时，我们可以使用<a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">弱引用</a>来处理。另外关于同样也需要将Runnable设置为静态的成员属性。注意：一个静态的匿名内部类实例不会持有外部类的引用。
修改后不会导致内存泄露的代码如下</p>

<p>```java
public class SampleActivity extends Activity {</p>

<p>  /<em>*
   * Instances of static inner classes do not hold an implicit
   * reference to their outer class.
   </em>/
  private static class MyHandler extends Handler {</p>

<pre><code>private final WeakReference&lt;SampleActivity&gt; mActivity;

public MyHandler(SampleActivity activity) {
  mActivity = new WeakReference&lt;SampleActivity&gt;(activity);
}

@Override
public void handleMessage(Message msg) {
  SampleActivity activity = mActivity.get();
  if (activity != null) {
    // ...
  }
}
</code></pre>

<p>  }</p>

<p>  private final MyHandler mHandler = new MyHandler(this);</p>

<p>  /<em>*
   * Instances of anonymous classes do not hold an implicit
   * reference to their outer class when they are &ldquo;static&rdquo;.
   </em>/
  private static final Runnable sRunnable = new Runnable() {</p>

<pre><code>  @Override
  public void run() { /* ... */ }
</code></pre>

<p>  };</p>

<p>  @Override
  protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);

// Post a message and delay its execution for 10 minutes.
mHandler.postDelayed(sRunnable, 1000 * 60 * 10);

// Go back to the previous Activity.
finish();
</code></pre>

<p>  }
}
```</p>

<p>其实在Android中很多的内存泄露都是由于在Activity中使用了非静态内部类导致的，就像本文提到的一样，所以当我们使用时要非静态内部类时要格外注意，如果其实例的持有对象的生命周期大于其外部类对象，那么就有可能导致内存泄露。个人倾向于使用文章的静态类和弱引用的方法解决这种问题。</p>

<h3>译文信息</h3>

<ul>
<li><a href="http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html">How to Leak a Context: Handlers &amp; Inner Classes</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[应用认领那些事]]></title>
    <link href="http://droidyue.com/blog/2014/12/14/android-yingyong-renling/"/>
    <updated>2014-12-14T19:35:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/12/14/android-yingyong-renling</id>
    <content type="html"><![CDATA[<p>最近公司的一款产品提交国内市场，发现有些国内市场提示需要进行应用认领。原因就是别人（或者市场抓取）已经在我们之前将这个应用提交到了该市场。认领成功后，这个应用就重回你的怀抱了，其实认领很简单，这里讲到的自然是对未签名的包进行签名。由于这样的操作细小琐屑，这样更需要记录一下，免得以后麻烦。</p>

<!--more-->


<h2>如何认领</h2>

<ul>
<li>一般的就是市场提供一个未签名的apk包，认领方进行签名后，上传即可认领成功。</li>
<li>另一种就是提供公司证明，这个我们不讲，也没什么可以讲。</li>
</ul>


<p>通常情况下认领都会有对一个未签名的apk包签名认证这种方式，因为签名是软件发布商所独有的，通过对比测试需认领的包的签名和刚签过名的apk包是否一致，如果一致就认领成功，否则失败。</p>

<h2>对未签名包签名</h2>

<p><code>bash
jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore your_keystore  -storepass your_storepass -keypass your_keypass -signedjar path_of_signed_apk  path_of_unsigned_apk your_alias
</code></p>

<h3>需要替换的值</h3>

<ul>
<li>your_key_store keystore文件路径</li>
<li>your_storepass   store密码</li>
<li>your_keypass    key密码</li>
<li>path_of_signed_apk 签名后apk保存的目录</li>
<li>path_of_unsigned_apk 待签名的apk包</li>
<li>your_alias keystore中的别名</li>
</ul>


<p>注意上面的签名算法sigalg 使用SHA1withRSA或者MD5withRSA都可以。</p>

<h2>验证签名</h2>

<p><code>bash
jarsigner -verify -certs -verbose your_app.apk
</code>
比如我们验证百度金融的apk，会得到类似这样的结果
```bash
19:23 $ jarsigner -verify -certs -verbose BaiduFinance.apk | more</p>

<p>s      61679 Fri Nov 14 19:50:16 CST 2014 META-INF/MANIFEST.MF</p>

<pre><code>  X.509, CN=Baidu, OU=Baidu Inc., O=Baidu Inc., L=Beijing, ST=Beijing, C=CN
  [certificate is valid from 12/6/13 10:19 AM to 11/24/63 10:19 AM]
  [CertPath not validated: Path does not chain with any of the trust anchors]

   61800 Fri Nov 14 19:50:16 CST 2014 META-INF/MCO_BAID.SF
     936 Fri Nov 14 19:50:16 CST 2014 META-INF/MCO_BAID.RSA
</code></pre>

<p>sm      2304 Fri Nov 14 19:49:32 CST 2014 assets/mean/data_mean_24_bank_card
```</p>

<h2>疑难问题</h2>

<h3>No -tsa or -tsacert is provided and this jar is not timestamped</h3>

<p>在签名时加入下面的选项
<code>bash
jarsigner -tsa http://timestamp.digicert.com
</code></p>

<h3>Windows无法打开文件</h3>

<p>有些Windows工具无法打开签名后的apk，如果你的签名没有错误，并且验证过，这种情况请忽略。</p>

<h3>签名认领失败</h3>

<p>如果签名认领失败的话，请检查目前线上的包是否进行了二次打包被别人篡改了签名，如果是的话，需要进行商务上的沟通来解决了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[仿腾讯新闻样式的Toast]]></title>
    <link href="http://droidyue.com/blog/2014/11/29/custom-toast-like-tencent-news-app/"/>
    <updated>2014-11-29T17:21:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/29/custom-toast-like-tencent-news-app</id>
    <content type="html"><![CDATA[<p>厌倦了网易新闻无处不在的喷子，尝试了一下腾讯新闻，果然顿时清净了很多，当然这不是重点。个人感觉腾讯新闻客户端的Toast比较不错，相对于系统默认的Toast，更加能起到提醒的作用。于是反编译了一下，简单分享一下,其实很简单。</p>

<!--more-->


<h2>先看效果</h2>

<p><img class="<a" src="href="http://droidyueimg.qiniudn.com/tencent_toast.png">http://droidyueimg.qiniudn.com/tencent_toast.png</a>">
背景为深灰色，支持设置图片和文字。</p>

<h2>布局文件</h2>

<p>```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;RelativeLayout</p>

<pre><code>android:id="@+id/view_tips_layout" 
android:background="@drawable/tips_bg" 
android:layout_width="wrap_content" 
android:layout_height="wrap_content"
xmlns:android="http://schemas.android.com/apk/res/android"&gt;
&lt;View 
    android:layout_width="160.0dip" 
    android:layout_height="160.0dip" 
    android:layout_centerInParent="true" /&gt;

&lt;LinearLayout 
    android:orientation="vertical" 
    android:layout_width="wrap_content" 
    android:layout_height="wrap_content" 
    android:layout_centerInParent="true"&gt;

    &lt;ImageView 
        android:gravity="center" 
        android:layout_gravity="center" 
        android:id="@+id/tips_icon" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_marginBottom="10.0dip" 
        android:src="@drawable/tips_error" 
        android:contentDescription="@null" /&gt;

    &lt;TextView 
        android:textSize="17.0sp" 
        android:textColor="#ffffffff" 
        android:gravity="center" 
        android:layout_gravity="center" 
        android:id="@+id/tips_msg" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:lineSpacingExtra="3.0dip" /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p></RelativeLayout>
```</p>

<h2>程序代码</h2>

<p><code>java
Toast toast = new Toast(getApplicationContext());
View toastView = LayoutInflater.from(getApplicationContext()).inflate(R.layout.view_tips, null);
((ImageView)toastView.findViewById(R.id.tips_icon)).setImageResource(R.drawable.ic_launcher);
((TextView)toastView.findViewById(R.id.tips_msg)).setText("Error Occurs");
toast.setView(toastView);
toast.setGravity(Gravity.NO_GRAVITY, 0, 0);
toast.show();
</code>
Toast默认的位置为底部水平居中。我们可以通过设置setGravity(int, int, int)来进行设置位置。该方法接受三个参数，一个Gravity常量，一个x（水平）方向上的偏移量，一个y（竖直）方向上的偏移量。</p>

<p>如果我们想让位置向右我们需要增加x方向上的偏移量，如果想让位置向下，增大y方向上的偏移量。</p>

<h2>多说</h2>

<p>我们可以根据自己的需求去设置图片，文字，背景色等样式来定制想要的Toast。</p>

<p>注意，涉及到长度宽度字体大小相关的建议放到dimens文件，便于我们进行设备适配。</p>

<h2>示例下载</h2>

<p><a href="http://pan.baidu.com/s/1kTLxagZ">百度网盘</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google为何这样设计OnSharedPreferenceChangeListener]]></title>
    <link href="http://droidyue.com/blog/2014/11/29/why-onsharedpreferencechangelistener-was-not-called/"/>
    <updated>2014-11-29T16:41:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/29/why-onsharedpreferencechangelistener-was-not-called</id>
    <content type="html"><![CDATA[<p>之前使用OnSharedPreferenceChangeListener，遇到了点小问题，就是有些时候OnSharedPreferenceChangeListener没有被触发。最近花了点时间研究了一下，小做整理。本文将会介绍监听器不被触发的原因，解决方法，以及其中隐含的一些技术细节。</p>

<!--more-->


<h2>问题再现</h2>

<p>OnSharedPreferenceChangeListener是Android中SharedPreference文件发生变化的监听器。通常我们想要进行监听，会实现如下的代码。
```java
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>PreferenceManager.getDefaultSharedPreferences(getApplicationContext())
    .registerOnSharedPreferenceChangeListener(new OnSharedPreferenceChangeListener() {
    @Override
    public void onSharedPreferenceChanged(
        SharedPreferences sharedPreferences, String key) {
        Log.i(LOGTAG, "testOnSharedPreferenceChangedWrong key =" + key);
    }
});
</code></pre>

<p>}
```
这种写法看上去没有什么问题，而且很多时候开始几次onSharedPreferenceChanged方法也可以被调用。但是过一段时间（简单demo不容易出现，但是使用DDMS中的gc会立刻导致接下来的问题），你会发现前面的方法突然不再被调用，进而影响到程序的处理。</p>

<h2>原因剖析</h2>

<p>简而言之，就是你注册的监听器被移除掉了。<br/>
首先我们先了解一下registerOnSharedPreferenceChangeListener注册的实现。
```
private final WeakHashMap&lt;OnSharedPreferenceChangeListener, Object> mListeners =</p>

<pre><code>        new WeakHashMap&lt;OnSharedPreferenceChangeListener, Object&gt;();
</code></pre>

<p>//some code goes here
public void More &hellip;registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {</p>

<pre><code>synchronized(this) {
    mListeners.put(listener, mContent);
}
</code></pre>

<p>}
```
从上面的代码可以得知，一个OnSharedPreferenceChangeListener对象实际上是放到了一个WeakHashMap的容器中，执行完示例中的onCreate方法，这个监听器对象很快就会成为垃圾回收的目标，由于放在WeakHashMap中作为key不会阻止垃圾回收，所以当监听器对象被回收之后，这个监听器也会从mListeners中移除。所以就造成了onSharedPreferenceChanged不会被调用。</p>

<p>关于WeakHashMap相关，请阅读<a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">译文：理解Java中的弱引用</a>进而更多了解。</p>

<h2>如何解决</h2>

<h3>改为对象成员变量（推荐）</h3>

<p>将监听器作为Activity的一个成员变量，在Activity的onResume进行注册，在onPause时进行注销。推荐在这两个Activity生命周期中进行处理，尤其是当SharedPreference值发生变化后，对Activity展示的UI进行处理操作的情况。这种方法是最推荐的解决方案。
```java
private OnSharedPreferenceChangeListener mListener = new OnSharedPreferenceChangeListener() {</p>

<pre><code>@Override
public void onSharedPreferenceChanged(
    SharedPreferences sharedPreferences, String key) {
    Log.i(LOGTAG, "instance variable key=" + key);
}
</code></pre>

<p>};</p>

<p>@Override
protected void onResume() {</p>

<pre><code>PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).registerOnSharedPreferenceChangeListener(mListener);
super.onResume();
</code></pre>

<p>}</p>

<p>@Override
protected void onPause() {</p>

<pre><code>PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).unregisterOnSharedPreferenceChangeListener(mListener);
super.onPause();
</code></pre>

<p>}
```</p>

<h3>改为静态变量（不推荐）</h3>

<p>如下，将一个指向匿名的内部类对象的变量sListener使用static修饰，这个内部类对象则不会持有外部类的引用。<br/>
但是这种做法并不推荐，因为一个静态变量和与外部实例不相关，我们很难和外部实例进行一些操作。
```java
private static OnSharedPreferenceChangeListener sListener = new OnSharedPreferenceChangeListener() {</p>

<pre><code>@Override
public void onSharedPreferenceChanged(
    SharedPreferences sharedPreferences, String key) {
    Log.i(LOGTAG, "static variable key=" + key);
}
</code></pre>

<p>};
```</p>

<h2>为什么这样设计</h2>

<p>可能会有人认为这是系统设计的猫腻或者bug，其实不然，这正是Android设计人员的高明之处。</p>

<p>正如我们示例的代码一样，将一个（隐式的）局部变量添加到监听器容器中，如果该容器只是一个普通的HashMap，这样会导致内存泄露，因为该容器还有局部变量指向的对象，该对象又隐式持有外部Activity的对象，导致Activity无法被销毁。关于非静态内部类持有隐式持有外部类引用，请参考<a href="http://droidyue.com/blog/2014/10/02/the-private-modifier-in-java/">细话Java："失效"的private修饰符</a></p>

<p>除此之外，因为局部变量无法在其所在方法外部访问，这样就导致了我们只可以使用方法中使用局部变量就行注册，在合适的时机却无法使用局部变量进行注销。</p>

<h2>三本帮助深入研究Java的书</h2>

<ul>
<li><a href="http://www.amazon.cn/gp/product/0137142528/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=0137142528&amp;linkCode=as2&amp;tag=droidyue-23">Java Performance</a></li>
<li><a href="http://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011F7WU4&amp;linkCode=as2&amp;tag=droidyue-23">Java编程思想(第4版)</a></li>
<li><a href="http://www.amazon.cn/gp/product/B001PTGR52/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001PTGR52&amp;linkCode=as2&amp;tag=droidyue-23">Sun 公司核心技术丛书:Effective Java中文版(第2版)</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
