<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2014-07-26T17:08:57+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[超简单实现Google+列表特效]]></title>
    <link href="http://droidyue.com/blog/2014/07/26/apply-google-plus-list-style-on-android/"/>
    <updated>2014-07-26T10:32:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/26/apply-google-plus-list-style-on-android</id>
    <content type="html"><![CDATA[<p>相信用过Google+的人都感到其应用的特效相当棒，本文将以超简单的形式来实现类似Google+列表的特效。仅仅写几行代码就可以实现奥。</p>

<h2>特效真面目</h2>

<p>由于众所周知的原因，很多人无法使用Google+应用。所以有必要让大家先看一看真面目。</p>

<!--more-->


<p>P.S.找了很多的屏目录制软件都不行，并且没有4.4的机器，所以只能用最笨的方法录制了，请见谅哈。</p>

<iframe height=498 width=510 src="http://player.youku.com/embed/XNzQ2MzAzNjIw" frameborder=0 allowfullscreen></iframe>


<h2>特效动画</h2>

<h3>from_bottom_to_top.xml</h3>

<p>```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;set xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code> android:shareInterpolator="@android:anim/decelerate_interpolator"&gt;
&lt;translate
    android:fromXDelta="0%" android:toXDelta="0%"
    android:fromYDelta="100%" android:toYDelta="0%"
    android:duration="400" /&gt;
</code></pre>

<p></set></p>

<p>```</p>

<h3>from_top_to_bottom.xml</h3>

<p>```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;set xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code> android:shareInterpolator="@android:anim/decelerate_interpolator"&gt;
&lt;translate
    android:fromXDelta="0%" android:toXDelta="0%"
    android:fromYDelta="-100%" android:toYDelta="0%"
    android:duration="400" /&gt;
</code></pre>

<p></set></p>

<p>```</p>

<h2>加入动画</h2>

<p>```java
private int mLastPosition = -1;
@Override
public View getView(int position, View convertView, ViewGroup parent) {</p>

<pre><code>View view = super.getView(position, convertView, parent);
int animResId;
if (position &gt; mLastPosition) {
    animResId = R.anim.from_bottom_to_top;
} else {
    animResId = R.anim.from_top_to_bottom;
}

Animation animation = AnimationUtils.loadAnimation(getContext(), animResId);
view.startAnimation(animation);
mLastPosition = position;
return view;
</code></pre>

<p>}
```</p>

<h2>源码</h2>

<p><a href="http://pan.baidu.com/s/1ntmelML" target="_blank">百度云盘</a></p>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00FQEDTA8/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00FQEDTA8&linkCode=as2&tag=droidyue-23">精彩绝伦的Android UI设计</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00FQEDTA8" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B0065DAGZK/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0065DAGZK&linkCode=as2&tag=droidyue-23">精通Android 3</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B0065DAGZK" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[持续整理:git分支操作]]></title>
    <link href="http://droidyue.com/blog/2014/07/21/git-tutorial-about-branch/"/>
    <updated>2014-07-21T19:07:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/21/git-tutorial-about-branch</id>
    <content type="html"><![CDATA[<p>这篇文章主要的目的是记录一下git中关于分支相关的操作记录. 本文会持续更新,所有的操作都经过本人实践,可以正常运行,并且可以解决问题.</p>

<p>我就不罗嗦介绍什么事Git和Git有多么牛了.</p>

<!--more-->


<hr />

<h3>迁出远程分支</h3>

<p>```bash
git checkout  -b new_local_branch_name repository_name/remote_branch_name</p>

<h2>Example</h2>

<p>git checkout  -b custom origin/custom</p>

<h2>建议是本地的分支名字和其对应的远程分支名称一样.</h2>

<h2>```</h2>

<h3>查看本地所有分支</h3>

<p><code>bash
git branch
</code></p>

<hr />

<h3>查看远程所有分支</h3>

<p>```bash
git branch -r</p>

<h2>```</h2>

<h3>删除本地分支</h3>

<p>```bash
git branch -d your_branch_name</p>

<h2>```</h2>

<h3>强制删除本地分支</h3>

<p>```bash
git branch -D your_branch_name</p>

<h2>```</h2>

<h3>删除远程分支</h3>

<p><code>bash
git push origin --delete your_branch_name
</code>
或者更简单的写法</p>

<p>```bash
git push origin :your_branch_name</p>

<h2>```</h2>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/1430218339/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=1430218339&linkCode=as2&tag=droidyue-23">Pro Git</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=1430218339" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/1430218339/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=1430218339&linkCode=as2&tag=droidyue-23">成为大神必读的Git书籍</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=1430218339" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android实现引用其他程序的文本资源]]></title>
    <link href="http://droidyue.com/blog/2014/07/21/refer-strings-from-other-applications-in-android-chinese-edition/"/>
    <updated>2014-07-21T07:39:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/21/refer-strings-from-other-applications-in-android-chinese-edition</id>
    <content type="html"><![CDATA[<p>在Android中引用其他程序的文本资源并不是很常见,但是有时候还是很是有需要的,通常引用的多半是系统的程序的文本资源.</p>

<p>下面以一个超简单的例子,来展示以下如何实现.</p>

<!--more-->


<p>```java
public void testUseAndroidString() {</p>

<pre><code>Context context = getContext();
Resources res = null;
try {
    //I want to use the clear_activities string in Package com.android.settings
    res = context.getPackageManager().getResourcesForApplication("com.android.settings");
    int resourceId = res.getIdentifier("com.android.settings:string/clear_activities", null, null);
    if(0 != resourceId) {
        CharSequence s = context.getPackageManager().getText("com.android.settings", resourceId, null);
        Log.i(VIEW_LOG_TAG, "resource=" + s);
    }
} catch (NameNotFoundException e) {
    e.printStackTrace();
}
</code></pre>

<p>}
```</p>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00BMTVUGG/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00BMTVUGG&linkCode=as2&tag=droidyue-23">Android软件安全与逆向分析</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00BMTVUGG" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B00E192518/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00E192518&linkCode=as2&tag=droidyue-23">你一定爱读的极简欧洲史</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00E192518" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android修复通知栏跳动的问题]]></title>
    <link href="http://droidyue.com/blog/2014/07/20/fix-notification-switching-position-issue-chinese-edition/"/>
    <updated>2014-07-20T11:59:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/20/fix-notification-switching-position-issue-chinese-edition</id>
    <content type="html"><![CDATA[<p>曾经遇到过这样的问题，在我的代码中使用了通知栏，一切都正常，但是就是正在进行的通知栏中属于我的程序的那一条总是上下跳来跳去，一闪一闪的。感觉用户体验很不好，于是Google一下，找到了解决方法。</p>

<!-- more -->


<p>在我的代码，我是这样写的。
```java</p>

<pre><code>notification.when = System.currentTimeMillis();
</code></pre>

<p><code>
这就是问题的关键，对于通知来说，when这个属性值应该在activity一启动的时候就应该固定。如果没有固定，就会使用默认的值，默认的值就是当前的时间，即`System.currentTimeMillis()`的值。因此使用一个自定义的固定值就可以解决问题。
</code>java
final long TIMESTAMP_FIXED = 1234567890l;
notification.when = TIMESTAMP_FIXED;
```
以下如Google介绍如何使用notification的when的说明。</p>

<blockquote><p>A timestamp related to this notification, in milliseconds since the epoch. Default value: Now. Choose a timestamp that will be most relevant to the user. For most finite events, this corresponds to the time the event happened (or will happen, in the case of events that have yet to occur but about which the user is being informed). Indefinite events should be timestamped according to when the activity began. Some examples:</p>

<ul>
<li>Notification of a new chat message should be stamped when the message was received.</li>
<li>Notification of an ongoing file download (with a progress bar, for example) should be stamped when the download started.</li>
<li>Notification of a completed file download should be stamped when the download finished.</li>
<li>Notification of an upcoming meeting should be stamped with the time the meeting will begin (that is, in the future).</li>
<li>Notification of an ongoing stopwatch (increasing timer) should be stamped with the watch&rsquo;s start time.</li>
<li>Notification of an ongoing countdown timer should be stamped with the timer&rsquo;s end time.</li>
</ul>
</blockquote>

<h3>Reference</h3>

<ul>
<li><a href="http://developer.android.com/reference/android/app/Notification.html#when">http://developer.android.com/reference/android/app/Notification.html#when</a></li>
</ul>


<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00J91AF9C/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00J91AF9C&linkCode=as2&tag=droidyue-23">打造高质量Android应用:Android开发必知的50个诀窍</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00J91AF9C" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B00D2ID4PK/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00D2ID4PK&linkCode=as2&tag=droidyue-23">深入理解Java虚拟机:JVM高级特性与最佳实践</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00D2ID4PK" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你真的懂么:Android中删除Preference]]></title>
    <link href="http://droidyue.com/blog/2014/07/18/remove-a-preference-from-the-screen/"/>
    <updated>2014-07-18T20:50:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/07/18/remove-a-preference-from-the-screen</id>
    <content type="html"><![CDATA[<p>Android的设置界面实现比较简单,有时甚至只需要使用一个简单的xml文件即可.声明简单,但是如何从PreferenceScreen或者PreferenceCategory中删除一个Preference会简单么.为什么有些人写的就无法删除成功呢?本文将从Android源码实现来分析一下.</p>

<!--more-->


<h2>声明文件</h2>

<p>```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;PreferenceScreen xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>android:key="root"&gt;

&lt;PreferenceCategory 
    android:key="theme" 
    android:title="Theme"
    android:summary="Theme Settings"
    &gt;
    &lt;CheckBoxPreference
        android:key="holo_theme"
        android:title="Holo Theme"
        android:summary="Use Holo Theme"
        /&gt;

&lt;/PreferenceCategory&gt;

&lt;CheckBoxPreference
    android:key="rmcache"
    android:title="Auto Clear Cache"
    android:summary="Enable Auto Clear Cache "
    /&gt;
</code></pre>

<p></PreferenceScreen>
```</p>

<h2>层级关系</h2>

<p><img class="<a" src="href="http://droidyueimg.qiniudn.com/preference_family_tree.png">http://droidyueimg.qiniudn.com/preference_family_tree.png</a>" title="preferece family tree" ></p>

<h2>删除Preference</h2>

<ul>
<li><p>删除key为rmcache的Preference,这个Preference是PreferenceScreen root的子节点.
<code>java
PreferenceScreen screen = getPreferenceScreen();
CheckBoxPreference autoClearCheckboxPref = (CheckBoxPreference) screen.findPreference("rmcache");
screen.removePreference(autoClearCheckboxPref);
</code></p></li>
<li><p>删除key为holo_theme的Preference,其为PreferenceScreen root的孙子节点,非直接关系.
<code>java
PreferenceCategory themePrefCategory = (PreferenceCategory) screen.findPreference("theme");
CheckBoxPreference holoCheckboxPref = (CheckBoxPreference)themePrefCategory.findPreference("holo_theme");
themePrefCategory.removePreference(holoCheckboxPref);
</code></p>

<h2>为什么删除失败</h2>

很多人出现了删除失败的问题,主要原因是使用了非父亲节点来删除,比如这样
<code>java
PreferenceScreen screen = getPreferenceScreen();
CheckBoxPreference holoCheckboxPref = (CheckBoxPreference)screen.findPreference("holo_theme");
screen.removePreference(holoCheckboxPref);
</code>
PreferenceGroup删除实现,其实PreferenceScreen和PreferenceCategory都是PreferenceGroup的子类.
```java
/**

<ul>
<li>Removes a {@link Preference} from this group.</li>
<li></li>
<li>@param preference The preference to remove.</li>
<li>@return Whether the preference was found and removed.
*/
public boolean removePreference(Preference preference) {
 final boolean returnValue = removePreferenceInt(preference);
 notifyHierarchyChanged();
 return returnValue;
}</li>
</ul>


<p>private boolean removePreferenceInt(Preference preference) {
    synchronized(this) {
        preference.onPrepareForRemoval();
        return mPreferenceList.remove(preference);
    }
}
```
而mPreferenceList中存放的都是当前PreferenceGroup的直接子Preference.</p></li>
</ul>


<h2>findPreference实现</h2>

<p>findPreference查找不仅仅限于直接子Preference,会遍历其所有的子Preference.</p>

<p>所以代码中同样有root PreferenceGroup和直接父PreferenceGroup引用时,通常后者效率会高.
```java</p>

<pre><code>/**
 * Finds a {@link Preference} based on its key. If two {@link Preference}
 * share the same key (not recommended), the first to appear will be
 * returned (to retrieve the other preference with the same key, call this
 * method on the first preference). If this preference has the key, it will
 * not be returned.
 * &lt;p&gt;
 * This will recursively search for the preference into children that are
 * also {@link PreferenceGroup PreferenceGroups}.
 * 
 * @param key The key of the preference to retrieve.
 * @return The {@link Preference} with the key, or null.
 */
public Preference findPreference(CharSequence key) {
    if (TextUtils.equals(getKey(), key)) {
        return this;
    }
    final int preferenceCount = getPreferenceCount();
    for (int i = 0; i &lt; preferenceCount; i++) {
        final Preference preference = getPreference(i);
        final String curKey = preference.getKey();

        if (curKey != null &amp;&amp; curKey.equals(key)) {
            return preference;
        }

        if (preference instanceof PreferenceGroup) {
            final Preference returnedPreference = ((PreferenceGroup)preference)
                    .findPreference(key);
            if (returnedPreference != null) {
                return returnedPreference;
            }
        }
    }

    return null;
}
</code></pre>

<p>```</p>

<h2>findPreference和removePreference实现比较</h2>

<p>为什么findPreference遍历所有的子节点,而removePreference不会,只会删除直接子Preference</p>

<h3>原因有以下几点:</h3>

<ul>
<li>findPreference支持遍历查找,减少了声明诸多的中间PreferenceGroup代码.而findPreference属于常用接口方法.</li>
<li>removePreference调用较少.</li>
<li>当存在key相同的Preference时,如果removePreference不限定直接子Preference,那么无法准确删除哪一个.</li>
</ul>


<hr />

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00CJ368JS/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00CJ368JS&linkCode=as2&tag=droidyue-23">Android的设计与实现</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00CJ368JS" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B009OLU8EE/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B009OLU8EE&linkCode=as2&tag=droidyue-23">Android系统源代码情景分析</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B009OLU8EE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
</feed>
