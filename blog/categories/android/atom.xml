<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2015-12-13T17:44:40+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android中SQLite操作性能优化]]></title>
    <link href="http://droidyue.com/blog/2015/12/13/android-sqlite-tuning/"/>
    <updated>2015-12-13T17:38:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/12/13/android-sqlite-tuning</id>
    <content type="html"><![CDATA[<p>数据库是应用开发中常用的技术，在Android应用中也不例外。Android默认使用了SQLite数据库，在应用程序开发中，我们使用最多的无外乎增删改查。纵使操作简单，也有可能出现查找数据缓慢，插入数据耗时等情况，如果出现了这种问题，我们就需要考虑对数据库操作进行优化了。本文将介绍一些实用的数据库优化操作，希望可以帮助大家更好地在开发过程中使用数据库。</p>

<!--more-->


<h2>建立索引</h2>

<p>很多时候，我们都听说，想要查找快速就建立索引。这句话没错，数据表的索引类似于字典中的拼音索引或者部首索引。</p>

<h3>索引的解释</h3>

<p>重温一下我们小时候查字典的过程：</p>

<ul>
<li>对于已经知道拼音的字，比如<code>中</code>这个字，我们只需要在拼音索引里面找到<code>zhong</code>，就可以确定这个字在词典中的页码。</li>
<li>对于不知道拼音的字，比如<code>欗</code>这个字，我们只需要在部首索引里面查找这个字，就能找到确定这个字在词典中的页码。</li>
</ul>


<p>没错，索引做的事情就是这么简单，使得我们不需要查找整个数据表就可以实现快速访问。</p>

<h3>建立索引</h3>

<p>创建索引的基本语法如下
<code>
CREATE INDEX index_name ON table_name;
</code></p>

<p>创建单列索引
<code>
CREATE INDEX index_name ON table_name (column_name);
</code></p>

<h3>索引真的好么</h3>

<p>毋庸置疑，索引加速了我们检索数据表的速度。然而正如西方谚语 &ldquo;There are two sides of a coin"，索引亦有缺点：</p>

<ul>
<li>对于增加，更新和删除来说，使用了索引会变慢，比如你想要删除字典中的一个字，那么你同时也需要删除这个字在拼音索引和部首索引中的信息。</li>
<li>建立索引会增加数据库的大小，比如字典中的拼音索引和部首索引实际上是会增加字典的页数，让字典变厚的。</li>
<li>为数据量比较小的表建立索引，往往会事倍功半。</li>
</ul>


<p>所以使用索引需要考虑实际情况进行利弊权衡，对于查询操作量级较大，业务对要求查询要求较高的，还是推荐使用索引的。</p>

<h2>编译SQL语句</h2>

<p>SQLite想要执行操作，需要将程序中的sql语句编译成对应的SQLiteStatement，比如<code>select * from record</code>这一句，被执行100次就需要编译100次。对于批量处理插入或者更新的操作，我们可以使用显式编译来做到重用SQLiteStatement。</p>

<p>想要做到重用SQLiteStatement也比较简单，基本如下：</p>

<ul>
<li>编译sql语句获得SQLiteStatement对象，参数使用<code>?</code>代替</li>
<li>在循环中对SQLiteStatement对象进行具体数据绑定，bind方法中的index从1开始，不是0</li>
</ul>


<p>请参考如下简单的使用代码
```java
private void insertWithPreCompiledStatement(SQLiteDatabase db) {</p>

<pre><code>String sql = "INSERT INTO " + TableDefine.TABLE_RECORD + "( " + TableDefine.COLUMN_INSERT_TIME + ") VALUES(?)";
SQLiteStatement  statement = db.compileStatement(sql);
int count = 0;
while (count &lt; 100) {
    count++;
    statement.clearBindings();
    statement.bindLong(1, System.currentTimeMillis());
    statement.executeInsert();
}
</code></pre>

<p>}
```</p>

<h2>显式使用事务</h2>

<p>在Android中，无论是使用SQLiteDatabase的insert,delete等方法还是execSQL都开启了事务，来确保每一次操作都具有原子性，使得结果要么是操作之后的正确结果，要么是操作之前的结果。</p>

<p>然而事务的实现是依赖于名为rollback journal文件，借助这个临时文件来完成原子操作和回滚功能。既然属于文件，就符合Unix的文件范型(Open-Read/Write-Close)，因而对于批量的修改操作会出现反复打开文件读写再关闭的操作。然而好在，我们可以显式使用事务，将批量的数据库更新带来的journal文件打开关闭降低到1次。</p>

<p>具体的实现代码如下：</p>

<p>```java
private void insertWithTransaction(SQLiteDatabase db) {</p>

<pre><code>int count = 0;
ContentValues values = new ContentValues();
try {
    db.beginTransaction();
    while (count++ &lt; 100) {
        values.put(TableDefine.COLUMN_INSERT_TIME, System.currentTimeMillis());
        db.insert(TableDefine.TABLE_RECORD, null, values);
    }
    db.setTransactionSuccessful();
} catch (Exception e) {
    e.printStackTrace();
} finally {
    db.endTransaction();
}
</code></pre>

<p>}
```</p>

<p>上面的代码中，如果没有异常抛出，我们则认为事务成功，调用<code>db.setTransactionSuccessful();</code>确保操作真实生效。如果在此过程中出现异常，则批量数据一条也不会插入现有的表中。</p>

<h2>查询数据优化</h2>

<p>对于查询的优化，除了建立索引以外，有以下几点微优化的建议</p>

<h3>按需获取数据列信息</h3>

<p>通常情况下，我们处于自己省时省力的目的，对于查找使用类似这样的代码
```java
private void badQuery(SQLiteDatabase db) {</p>

<pre><code>db.query(TableDefine.TABLE_RECORD, null, null, null, null, null, null) ;
</code></pre>

<p>}
```
其中上面方法的第二个参数类型为String[]，意思是返回结果参考的colum信息，传递null表明需要获取全部的column数据。这里建议大家传递真实需要的字符串数据对象表明需要的列信息，这样做效率会有所提升。</p>

<h3>提前获取列索引</h3>

<p>当我们需要遍历cursor时，我们通常的做法是这样
```java
private void badQueryWithLoop(SQLiteDatabase db) {</p>

<pre><code>Cursor cursor = db.query(TableDefine.TABLE_RECORD, new String[]{TableDefine.COLUMN_INSERT_TIME}, null, null, null, null, null) ;
while (cursor.moveToNext()) {
    long insertTime = cursor.getLong(cursor.getColumnIndex(TableDefine.COLUMN_INSERT_TIME));
}
</code></pre>

<p>}
<code>
但是如果我们将获取ColumnIndex的操作提到循环之外，效果会更好一些，修改后的代码如下：
</code>java
private void goodQueryWithLoop(SQLiteDatabase db) {</p>

<pre><code>Cursor cursor = db.query(TableDefine.TABLE_RECORD, new String[]{TableDefine.COLUMN_INSERT_TIME}, null, null, null, null, null) ;
int insertTimeColumnIndex = cursor.getColumnIndex(TableDefine.COLUMN_INSERT_TIME);
while (cursor.moveToNext()) {
    long insertTime = cursor.getLong(insertTimeColumnIndex);
}
cursor.close();
</code></pre>

<p>}
```</p>

<h2>ContentValues的容量调整</h2>

<p>SQLiteDatabase提供了方便的ContentValues简化了我们处理列名与值的映射，ContentValues内部采用了HashMap来存储Key-Value数据，ContentValues的初始容量是8，如果当添加的数据超过8之前，则会进行双倍扩容操作，因此建议对ContentValues填入的内容进行估量，设置合理的初始化容量，减少不必要的内部扩容操作。</p>

<h2>及时关闭Cursor</h2>

<p>使用数据库，比较常见的就是忘记关闭Cursor。关于如何发现未关闭的Cursor，我们可以使用StrictMode，详细请戳这里<a href="http://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode/">Android性能调优利器StrictMode</a></p>

<h2>耗时异步化</h2>

<p>数据库的操作，属于本地IO，通常比较耗时，如果处理不好，很容易导致<a href="http://droidyue.com/blog/2015/07/18/anr-in-android/">ANR</a>,因此建议将这些耗时操作放入异步线程中处理，这里推荐一个单线程 + 任务队列形式处理的<a href="http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/">HandlerThread</a>实现异步化。</p>

<h2>源码下载</h2>

<p>示例源码，存放在Github，地址为<a href="https://github.com/androidyue/AndroidSQLiteTuningDemo">AndroidSQLiteTuningDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android处理崩溃的一些实践]]></title>
    <link href="http://droidyue.com/blog/2015/12/06/practise-about-crash-in-android/"/>
    <updated>2015-12-06T22:47:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/12/06/practise-about-crash-in-android</id>
    <content type="html"><![CDATA[<p>对于任何程序来说，崩溃都是一件很难避免的事情，当然Android程序也不例外。在Android程序中，引起崩溃的多属于运行时异常或者错误，对于这些异常我们很难做到类似Checked Exception那样显式捕获，因而最终导致了程序崩溃。本文讲介绍一些如何处理崩溃的实践，比如收集崩溃的stacktrace，甚至如何避免出现程序已停止的对话框。</p>

<!--more-->


<h2>如何收集崩溃信息</h2>

<p>收集崩溃信息，可以更好的修复问题，增强程序的稳定性。Android中的崩溃收集沿用了Java的收集机制，实现起来比较简单。</p>

<h3>1.实现UncaughtExceptionHandler</h3>

<p>我们需要实现UncaughtExceptionHandler接口中的<code>uncaughtException</code>方法。该方法体中最常见的操作就是读取崩溃的stacktrace信息，然后上报到服务器数据便于开发者分析。实现代码如下：
```java
public class SimpleUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {</p>

<pre><code>private static final String LOGTAG = "SimpleUncaughtExceptionHandler";

@Override
public void uncaughtException(Thread thread, Throwable ex) {
    //读取stacktrace信息
    final Writer result = new StringWriter();
    final PrintWriter printWriter = new PrintWriter(result);
    ex.printStackTrace(printWriter);
    String errorReport = result.toString();
    Log.i(LOGTAG, "uncaughtException errorReport=" + errorReport);
}
</code></pre>

<p>}
```
除此之外，还建议携带以下信息发送到服务器，帮助更快定位和重现问题。</p>

<ul>
<li>设备唯一ID（基于IMEI或者Android ID等），方便根据用户提供的id，查找崩溃的stacktrace</li>
<li>设备语言与区域 方便重现</li>
<li>应用的版本号</li>
<li>设备的系统版本</li>
<li>设备类型，如平板，手机，TV等</li>
<li>崩溃发生的时间等</li>
</ul>


<h3>注册默认的异常处理</h3>

<p>注册默认的异常处理就是最后的一步，很简单，通常建议放在Application的onCreate方法中进行。
```java
public class DroidApplication extends Application {</p>

<pre><code>private static final String LOGTAG = "DroidApplication";

@Override
public void onCreate() {
    super.onCreate();
    Log.i(LOGTAG, "onCreate");
    Thread.setDefaultUncaughtExceptionHandler(new SimpleUncaughtExceptionHandler());
}
</code></pre>

<p>}
```</p>

<h3>验证</h3>

<p>当我们刻意触发一个NullPointerException时，过滤日志<code>adb logcat | grep SimpleUncaughtExceptionHandler</code>类似如下信息，则说明成功了。
<code>java
I/SimpleUncaughtExceptionHandler(22469): uncaughtException errorReport=java.lang.NullPointerException
I/SimpleUncaughtExceptionHandler(22469):  at com.droidyue.avoidforceclosedemo.MainActivity.causeNPE(MainActivity.java:22)
I/SimpleUncaughtExceptionHandler(22469):  at com.droidyue.avoidforceclosedemo.MainActivity.onClick(MainActivity.java:29)
I/SimpleUncaughtExceptionHandler(22469):  at android.view.View.performClick(View.java:4470)
I/SimpleUncaughtExceptionHandler(22469):  at android.view.View$PerformClick.run(View.java:18593)
I/SimpleUncaughtExceptionHandler(22469):  at android.os.Handler.handleCallback(Handler.java:733)
I/SimpleUncaughtExceptionHandler(22469):  at android.os.Handler.dispatchMessage(Handler.java:95)
I/SimpleUncaughtExceptionHandler(22469):  at android.os.Looper.loop(Looper.java:157)
I/SimpleUncaughtExceptionHandler(22469):  at android.app.ActivityThread.main(ActivityThread.java:5867)
I/SimpleUncaughtExceptionHandler(22469):  at java.lang.reflect.Method.invokeNative(Native Method)
I/SimpleUncaughtExceptionHandler(22469):  at java.lang.reflect.Method.invoke(Method.java:515)
I/SimpleUncaughtExceptionHandler(22469):  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:858)
I/SimpleUncaughtExceptionHandler(22469):  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:674)
I/SimpleUncaughtExceptionHandler(22469):  at dalvik.system.NativeStart.main(Native Method)
</code></p>

<h2>不出现应用崩溃对话框</h2>

<p>在Android崩溃的时候，我们都会看到类似这样的对话框</p>

<p><img src="http://7jpolu.com1.z0.glb.clouddn.com/app_crash.png" alt="app crash" /></p>

<p>然而，实际上有些情况下是不需要展示这个对话框的，一个常用的例子，我的程序中一个不太重要的推送服务采用了单独的进程，当这个进程崩溃时，实际上是可以允许不让用户感知的。</p>

<p>如果我们采取主进程仍弹出对话框，其他进程不弹出的策略，那么我们的问题，可以总结成如下三个</p>

<ul>
<li>如何判断进程为主进程还是其他进程，或者某个进程</li>
<li>如何在某些进程不弹出应用崩溃对话框</li>
<li>如何在主进程弹出崩溃对话框</li>
</ul>


<p>既然问题来了，我们就开动挖掘机深挖吧。</p>

<h3>进程判定</h3>

<p>进行进程判定也比较容易，首先我们需要获得进程名
```java
public static String getProcessName(Context appContext) {</p>

<pre><code>String currentProcessName = "";
int pid = android.os.Process.myPid();
ActivityManager manager = (ActivityManager) appContext.getSystemService(Context.ACTIVITY_SERVICE);
for (ActivityManager.RunningAppProcessInfo processInfo : manager.getRunningAppProcesses()) {
    if (processInfo.pid == pid) {
        currentProcessName = processInfo.processName;
        break;
    }
}
return currentProcessName;
</code></pre>

<p>}
<code>
判断主进程，则对比进程名是否和包名相同即可
</code>java
mAppContext.getPackageName().equals(processName)
<code>
判断为某个进程，在mainifest这样这样声明
</code>java
<service android:name=".DroidService" android:process=":service"></service>
<code>
其对应的完整进程名为`com.droidyue.avoidforceclosedemo:service`，我们判断可以使用如下代码
</code>java
&ldquo;com.droidyue.avoidforceclosedemo:service&rdquo;.equals(processName);
```</p>

<h3>不弹框的处理</h3>

<p>不弹框的需要做的就是不调用Android默认的异常处理，当异常出现时，收集完信息，执行进程kill即可。
<code>java
android.os.Process.killProcess(android.os.Process.myPid());
</code></p>

<h3>主进程保持弹窗的处理</h3>

<p>想要保持弹窗也比较容易，就是调用Android默认的异常处理。</p>

<p>首先需要获得Android默认的异常处理，在设置自定的异常处理之前，将Android默认处理保存起来。如下是在自定义异常处理的构造方法中获取Android默认处理
```java
public DroidUncaughtExceptionHandler(Context context) {</p>

<pre><code>mAppContext = context.getApplicationContext();
mDefaultExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
</code></pre>

<p>}
<code>
然后在异常处理方法uncaughtException中调用如下方法
</code>java
mDefaultExceptionHandler.uncaughtException(thread, ex);
```</p>

<p>注意，如果你的应用崩溃后，不调用Android默认的异常处理，也不进行杀死进程，则进程处于不可交互，即UI点击无响应状态。</p>

<h2>源码</h2>

<p>本示例源码，存放在Github，地址为<a href="https://github.com/androidyue/AvoidForceCloseDemo">AvoidForceCloseDemo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[详解 Android 中的 HandlerThread]]></title>
    <link href="http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/"/>
    <updated>2015-11-08T22:50:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread</id>
    <content type="html"><![CDATA[<p>HandlerThread是Android API提供的一个便捷的类，使用它我们可以快速的创建一个带有Looper的线程，有了Looper这个线程，我们又可以生成Handler，那么HandlerThread是什么，可以做什么呢，有哪些奇技淫巧可以被我们利用呢？</p>

<!--more-->


<h2>实现原理</h2>

<p>在介绍原理之前，我们先使用普通的Thread来创建一个Handler，创建的过程大致如下：
```java
Handler mHandler;
private void createManualThreadWithHandler() {</p>

<pre><code>new Thread() {
    @Override
    public void run() {
        super.run();
        Looper.prepare();
        mHandler = new Handler(Looper.myLooper());
        Looper.loop();
    }
}.start();
</code></pre>

<p>}
```
实现很简单，在目标线程内如下配置</p>

<ul>
<li>调用Looper.prepare 创建与当前线程绑定的Looper实例</li>
<li>使用上面创建的Looper生成Handler实例</li>
<li>调用Looper.loop()实现消息循环</li>
</ul>


<p>明白上面的实现步骤，HandlerThread的实现也就简单了，其实现为：
```java
@Override
public void run() {</p>

<pre><code>mTid = Process.myTid();
Looper.prepare();
synchronized (this) {
    mLooper = Looper.myLooper();
    notifyAll();
}
Process.setThreadPriority(mPriority);
onLooperPrepared();
Looper.loop();
mTid = -1;
</code></pre>

<p>}
```
确实很简单，无需赘述。</p>

<h2>Handler原理</h2>

<p>要理解Handler的原理，理解如下几个概念即可茅塞顿开。</p>

<ul>
<li>Message 意为消息，发送到Handler进行处理的对象，携带描述信息和任意数据。</li>
<li>MessageQueue 意为消息队列，Message的集合。</li>
<li>Looper 有着一个很难听的中文名字，消息泵，用来从MessageQueue中抽取Message，发送给Handler进行处理。</li>
<li>Handler 处理Looper抽取出来的Message。</li>
</ul>


<h2>如何使用</h2>

<p>HandlerThread使用起来很容易，首先需要进行初始化。
```java
private Handler mHandler;
private LightTaskManager() {</p>

<pre><code>HandlerThread workerThread = new HandlerThread("LightTaskThread");
workerThread.start();
mHandler = new Handler(workerThread.getLooper());
</code></pre>

<p>}
<code>``
注意：上面的</code>workerThread.start();`必须要执行。</p>

<p>至于如何使用HandlerThread来执行任务，主要是调用Handler的API</p>

<ul>
<li>使用post方法提交任务，postAtFrontOfQueue将任务加入到队列前端，postAtTime指定时间提交任务，postDelayed延后提交任务。</li>
<li>使用sendMessage方法可以发送消息，sendMessageAtFrontOfQueue将该消息放入消息队列前端，sendMessageAtTime 指定时间发送消息，sendMessageDelayed延后提交消息。</li>
</ul>


<p>通过包裹Handler API，我们可以实现如下代码(仅post相关方法):
```java
public void post(Runnable run) {</p>

<pre><code>mHandler.post(run);
</code></pre>

<p>}</p>

<p>public void postAtFrontOfQueue(Runnable runnable) {</p>

<pre><code>mHandler.postAtFrontOfQueue(runnable);
</code></pre>

<p>}</p>

<p>public void postDelayed(Runnable runnable, long delay) {</p>

<pre><code>mHandler.postDelayed(runnable, delay);
</code></pre>

<p>}</p>

<p>public void postAtTime(Runnable runnable, long time) {</p>

<pre><code>mHandler.postAtTime(runnable, time);
</code></pre>

<p>}
```</p>

<h2>控制优先级</h2>

<p>了解到如何使用之外，关于HandlerThread的使用需要上升一个界别，那就是优化。这里的优化主要是合理调整HandlerThread的优先级。</p>

<p>HandlerThread的默认优先级是<code>Process.THREAD_PRIORITY_DEFAULT</code>,具体值为0。线程的优先级的取值范围为-20到19。优先级高的获得的CPU资源更多，反之则越少。-20代表优先级最高，19最低。0位于中间位置，但是作为工作线程的HandlerThread没有必要设置这么高的优先级，因而需要我们降低其优先级。</p>

<h3>可控制的优先级</h3>

<ul>
<li>THREAD_PRIORITY_DEFAULT，默认的线程优先级，值为0。</li>
<li>THREAD_PRIORITY_LOWEST，最低的线程级别，值为19。</li>
<li>THREAD_PRIORITY_BACKGROUND 后台线程建议设置这个优先级，值为10。</li>
<li>THREAD_PRIORITY_MORE_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微优先，值为-1。</li>
<li>THREAD_PRIORITY_LESS_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微落后一些，值为1。</li>
</ul>


<p>以上的这些优先级都是可以在程序中设置的，除此之外还有不可控的优先级均有系统进行自动调整。</p>

<h3>如何修改权限</h3>

<p>最通用的就是在run方法中，加入合理的设置优先级代码，比如
```
Runnable run = new Runnable() {</p>

<pre><code>@Override
public void run() {
    android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
</code></pre>

<p>};
LightTaskManager.getInstance().post(run);
```
上述方法不仅适用于HandlerThread，也可以适用于其他的线程。</p>

<p>除此之外，HandlerThread的构造方法也提供了设置优先级的功能。用法如下：
<code>java
HandlerThread workerThread = new HandlerThread("LightTaskThread", Process.THREAD_PRIORITY_BACKGROUND);
</code></p>

<p>关于设置优先级，系统的AsyncTask已经开始进行了默认设置，将线程的优先级设置成THREAD_PRIORITY_BACKGROUND了。
```java
public AsyncTask() {</p>

<pre><code>mWorker = new WorkerRunnable&lt;Params, Result&gt;() {
    public Result call() throws Exception {
        mTaskInvoked.set(true);

        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
        //noinspection unchecked
        Result result = doInBackground(mParams);
        Binder.flushPendingCommands();
        return postResult(result);
    }
};
</code></pre>

<p>}
```</p>

<p>关于Android中线程的调度详情，请参考<a href="">剖析Android中进程与线程调度之nice</a></p>

<h2>应用场景</h2>

<p>我们可以使用HandlerThread处理本地IO读写操作（数据库，文件），因为本地IO操作大多数的耗时属于毫秒级别，对于单线程 + 异步队列的形式 不会产生较大的阻塞。因此在这个HandlerThread中不适合加入网络IO操作。</p>

<p>对于本地IO读取操作，我们可以使用postAtFrontOfQueue方法，快速将读取操作加入队列前端执行，必要时返回给主线程更新UI。示例场景，从数据库中读取数据展现在ListView中。注意读取也是需要花费一定时间，推荐在数据展示之前有必要的用户可感知进度提示。</p>

<p>对于本地IO写操作，根据具体情况，选择post或者postDelayed方法执行。比如SharedPreference commit，或者文件写入操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Android Log的一些思考]]></title>
    <link href="http://droidyue.com/blog/2015/11/01/thinking-about-android-log/"/>
    <updated>2015-11-01T17:09:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/11/01/thinking-about-android-log</id>
    <content type="html"><![CDATA[<p>在日常的Android开发中，日志打印是一项必不可少的操作，我们通过分析打印的日志可以分析程序的运行数据和情况。然而使用日志打印的正确姿势又是怎样呢，如何屏蔽日志信息输出呢，本文将逐一进行回答。</p>

<!--more-->


<h2>哪些形式</h2>

<h3>System.out.println</h3>

<p>这是标准的Java输出方法，相信很多公司都不提倡使用，这里进行列举，目的是为了提醒大家不用。</p>

<h3>Android Log</h3>

<p>Android自身提供了一个日志工具类，那就是android.util.Log。使用很简单，如下
<code>java
Log.i(LOGTAG, "onCreate");
</code></p>

<h2>TAG选取</h2>

<h3>选用人名</h3>

<p>关于TAG的选取，很多人都曾采用人名的形式，比如
<code>
Log.i("andy", "onCreate");
</code>
这样做的目标一是为了过滤方便，当一个人在写一个模块多个文件时，使用这个形式，过滤起来很容易帮助理解程序的执行情况。另外的目的就是为了表明日志周围代码的作者姓甚名谁。</p>

<p>然而，我却不推荐这种人名作为TAG的形式。原因如下</p>

<ul>
<li>以人名作为关键字过滤，不易确定产生日志的类文件</li>
<li>随着某个人模块实现的增加，过滤人名易产生来自其他模块的干扰信息。</li>
</ul>


<h3>动态选取</h3>

<p>还有一种选取LOGTAG的方式，就是
<code>
private static final String LOGTAG = DroidSettings.class.getSimpleName();
</code>
这样使用，得到的LOGTAG的值就是DroidSettings，然而并非如此，当DroidSettings这个类进行了混淆之后，类名变成了类似a,b,c这样的名称，LOGTAG则不再是DroidSettings这个值了。这样可能造成的问题就是，内部混淆有日志的包，我们去过滤DroidSettings 却永远得不到任何信息。</p>

<h3>推荐的记录形式</h3>

<p>推荐的形式就是以字符串字面量形式去设置LOGTAG。如下，在DroidSettings类中
<code>java
private static final String LOGTAG = "DroidSettings";
</code></p>

<h3>优雅打印日志的姿势</h3>

<p>什么才是打印日志的优雅姿势是，我认为一条好的日志需要包含以下三点</p>

<ul>
<li>这条日志所在的类，我们通过LOGTAG可以表示</li>
<li>这条日志所在的方法，需要加入方法名的字符串</li>
<li>必要的其他信息，比如参数或者局部变量。</li>
</ul>


<p>结合三点，下面是一个符合规则的简单示例
```java
private String  getBookName(int bookId) {</p>

<pre><code>String bookName = mBooks.get(bookId);
DroidLog.i(LOGTAG, "getBookName bookId=" + bookId + ";bookName=" + bookName);
return bookName;
</code></pre>

<p>}
```
上面的代码，包含了所在类（LOGTAG），方法名(getBookName)， 参数(bookId)，局部变量(bookName)。必要的信息都展示了出来，对于了解程序运行很有帮助。</p>

<h2>屏蔽日志输出</h2>

<p>在Android中进行屏蔽日志，有两种实现形式，一种是在编译期屏蔽，另一种则是从运行时进行屏蔽，后者相对比较常见，从后向前介绍。</p>

<h3>运行时屏蔽</h3>

<p>在运行时屏蔽日志，通常的做法是创建一个自定义的类，比如叫做DroidLog
```java
public class DroidLog {</p>

<pre><code>private static final boolean ENABLE_LOG = true;


public static void i(String tag, String message) {
    if (ENABLE_LOG) {
        android.util.Log.i(tag, message);
    }
}
</code></pre>

<p>}
```
在编码时，我们调用DroidLog.i方法来记录日志，然后在打包时，修改ENABLE_LOG的值为false，这样就能屏蔽了日志输出。</p>

<p>然后运行时屏蔽的方案实际上有一点小问题，比如
```java
private void dumpDebugInfo() {</p>

<pre><code>DroidLog.i(LOGTAG, "sdkVersion=" + Build.VERSION.SDK_INT + "; Locale=" + Locale.getDefault());
</code></pre>

<p>}
<code>``
虽然上面的日志不会打印，但是</code>&ldquo;sdkVersion=&rdquo; + Build.VERSION.SDK_INT + &ldquo;; Locale=&rdquo; + Locale.getDefault()`这段字符串拼接语句却实实在在执行了。总的来说，还是会产生一些影响。</p>

<p>关于字符串拼接的细节，可以阅读<a href="http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/">Java细节：字符串的拼接</a></p>

<h2>编译期屏蔽</h2>

<p>既然运行时屏蔽存在问题，那么是否可以提前到编译期进行屏蔽呢，答案是肯定的。这里我们就使用了Proguard的一个小功能。</p>

<p>assumenosideeffects从英文单词上去理解，意思为 假设没有副作用。该功能属于优化的一种方式，该功能常常用来处理日志打印，比如我们想要屏蔽掉来自DroidLog的日志打印。
在混淆的配置文件中，加入下列代码</p>

<p>```
-assumenosideeffects class com.droidyue.logdemo.DroidLog {</p>

<pre><code>    public static *** i(...);
</code></pre>

<p>}
```</p>

<p>然而仅仅处理DroidLog是不够的，因为我们无法保证团队其他成员是否使用了原生的android.utils.Log来进行日志打印（尽管有编码约束）</p>

<p>```
-assumenosideeffects class android.util.Log {</p>

<pre><code>    public static *** d(...);
    public static *** e(...);
    public static *** i(...);
    public static *** v(...);
    public static *** println(...);
    public static *** w(...);
    public static *** wtf(...);
</code></pre>

<p>}
```</p>

<p>一般写到这里，基本可以结束，但是我们还需要探究一下，编译期屏蔽是否和运行时屏蔽一样有着同样的问题呢？ 我们接下来证明<br/>
首先，我们选用这段代码作为例子
```java
public class MainActivity extends Activity {</p>

<pre><code>private static final String LOGTAG = "MainActivity" ;
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    dumpDebugInfo();
}

private void dumpDebugInfo() {
    Locale defaultLocale = Locale.getDefault();
    DroidLog.i(LOGTAG, "sdkVersion=" + Build.VERSION.SDK_INT + "; Locale=" + defaultLocale);
}
</code></pre>

<p>}
<code>
然后修改混淆文件proguard-project.txt，启用混淆处理。
</code>
-assumenosideeffects class android.util.Log {</p>

<pre><code>public static *** d(...);
public static *** i(...);
public static *** v(...);
</code></pre>

<p>}</p>

<p>-assumenosideeffects class com.droidyue.logdemo.DroidLog {</p>

<pre><code>    public static *** i(...);
</code></pre>

<p>}
```</p>

<p>然后使用Eclipse的导出功能，生成指定签名的APK包，运行必然没有日志输出。</p>

<p>接下来对生成的APK包进行反编译，得到的smali文件。查看MainActivity.smali。</p>

<p>注意：Proguard进行优化，发生了内联操作，讲dumpDebugInfo的方法体实现提取到onCreate方法中。</p>

<p>onCreate方法体中没有任何关于<code>DroidLog.i</code>方法的调用，但是<code>"sdkVersion=" + Build.VERSION.SDK_INT + "; Locale=" + defaultLocale</code>对应的字符串拼接操作依然存在。
```</p>

<h1>virtual methods</h1>

<p>.method protected onCreate(Landroid/os/Bundle;)V</p>

<pre><code>.locals 3

invoke-super {p0, p1}, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V

const v0, 0x7f030017

invoke-virtual {p0, v0}, Lcom/droidyue/logdemo/MainActivity;-&gt;setContentView(I)V

invoke-static {}, Ljava/util/Locale;-&gt;getDefault()Ljava/util/Locale;

move-result-object v0

new-instance v1, Ljava/lang/StringBuilder;

const-string v2, "sdkVersion="

invoke-direct {v1, v2}, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;(Ljava/lang/String;)V

sget v2, Landroid/os/Build$VERSION;-&gt;SDK_INT:I

invoke-virtual {v1, v2}, Ljava/lang/StringBuilder;-&gt;append(I)Ljava/lang/StringBuilder;

move-result-object v1

const-string v2, "; Locale="

invoke-virtual {v1, v2}, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder;

move-result-object v1

invoke-virtual {v1, v0}, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/Object;)Ljava/lang/StringBuilder;

move-result-object v0

invoke-virtual {v0}, Ljava/lang/StringBuilder;-&gt;toString()Ljava/lang/String;

return-void
</code></pre>

<p>.end method
```
因此，无论是运行时日志屏蔽还是编译期，message参数上发生的字符串拼接都依然存在。但是编译期屏蔽减少了方法调用（即方法进出栈操作），理论上编译期屏蔽日志更优。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能调优利器StrictMode]]></title>
    <link href="http://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode/"/>
    <updated>2015-09-26T20:50:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode</id>
    <content type="html"><![CDATA[<p>作为Android开发，日常的开发工作中或多或少要接触到性能问题，比如我的Android程序运行缓慢卡顿，并且常常出现ANR对话框等等问题。既然有性能问题，就需要进行性能优化。正所谓工欲善其事，必先利其器。一个好的工具，可以帮助我们发现并定位问题，进而有的放矢进行解决。本文主要介绍StrictMode 在Android 应用开发中的应用和一些问题。</p>

<!--more-->


<h2>什么是StrictMode</h2>

<p>StrictMode意思为严格模式，是用来检测程序中违例情况的开发者工具。最常用的场景就是检测主线程中本地磁盘和网络读写等耗时的操作。</p>

<h3>严在哪里</h3>

<p>既然叫做严格模式，那么又严格在哪些地方呢？<br/>
在Android中，主线程，也就是UI线程，除了负责处理UI相关的操作外，还可以执行文件读取或者数据库读写操作（从Android 4.0 开始，网络操作禁止在主线程中执行，否则会抛出<a href="http://droidyue.com/blog/2014/11/08/look-into-android-dot-os-dot-networkonmainthreadexception/">NetworkOnMainThreadException</a>）。使用严格模式，系统检测出主线程违例的情况会做出相应的反应，如日志打印，弹出对话框亦或者崩溃等。换言之，严格模式会将应用的违例细节暴露给开发者方便优化与改善。</p>

<h3>具体能检测什么</h3>

<p>严格模式主要检测两大问题，一个是线程策略，即TreadPolicy，另一个是VM策略，即VmPolicy。</p>

<h3>ThreadPolicy</h3>

<p>线程策略检测的内容有</p>

<ul>
<li>自定义的耗时调用 使用<strong>detectCustomSlowCalls()</strong>开启</li>
<li>磁盘读取操作 使用<strong>detectDiskReads()</strong>开启</li>
<li>磁盘写入操作 使用<strong>detectDiskWrites()</strong>开启</li>
<li>网络操作  使用<strong>detectNetwork()</strong>开启</li>
</ul>


<h3>VmPolicy</h3>

<p>虚拟机策略检测的内容有</p>

<ul>
<li>Activity泄露 使用<strong>detectActivityLeaks()</strong>开启</li>
<li>未关闭的Closable对象泄露  使用<strong>detectLeakedClosableObjects()</strong>开启</li>
<li>泄露的Sqlite对象  使用<strong>detectLeakedSqlLiteObjects()</strong>开启</li>
<li>检测实例数量 使用<strong>setClassInstanceLimit()</strong>开启</li>
</ul>


<h2>工作原理</h2>

<p>其实StrictMode实现原理也比较简单，以IO操作为例，主要是通过在open，read，write，close时进行监控。<code>libcore.io.BlockGuardOs</code>文件就是监控的地方。以open为例，如下进行监控。</p>

<p>```java
@Override
public FileDescriptor open(String path, int flags, int mode) throws ErrnoException {</p>

<pre><code>BlockGuard.getThreadPolicy().onReadFromDisk();
if ((mode &amp; O_ACCMODE) != O_RDONLY) {
    BlockGuard.getThreadPolicy().onWriteToDisk();
}
return os.open(path, flags, mode);
</code></pre>

<p>}
<code>
其中**onReadFromDisk()**方法的实现，代码位于StrictMode.java中。
</code>
public void onReadFromDisk() {</p>

<pre><code>if ((mPolicyMask &amp; DETECT_DISK_READ) == 0) {
    return;
}
if (tooManyViolationsThisLoop()) {
    return;
}
BlockGuard.BlockGuardPolicyException e = new StrictModeDiskReadViolation(mPolicyMask);
e.fillInStackTrace();
startHandlingViolationException(e);
</code></pre>

<p>}
```</p>

<h2>如何使用</h2>

<p>关于StrictMode如何使用，最重要的就是如何启用严格模式。</p>

<h3>放在哪里</h3>

<p>严格模式的开启可以放在Application或者Activity以及其他组件的onCreate方法。为了更好地分析应用中的问题，建议放在Application的onCreate方法中。</p>

<h3>简单启用</h3>

<p>以下的代码启用全部的ThreadPolicy和VmPolicy违例检测
```java
if (IS_DEBUG &amp;&amp; Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {</p>

<pre><code>StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectAll().penaltyLog().build());
StrictMode.setVmPolicy(new VmPolicy.Builder().detectAll().penaltyLog().build());
</code></pre>

<p>}
```
严格模式需要在debug模式开启，不要在release版本中启用。</p>

<p>同时，严格模式自API 9 开始引入，某些API方法也从 API 11 引入。使用时应该注意 API 级别。</p>

<p>如有需要，也可以开启部分的严格模式。</p>

<h3>查看结果</h3>

<p>严格模式有很多种报告违例的形式，但是想要分析具体违例情况，还是需要查看日志，终端下过滤StrictMode就能得到违例的具体stacktrace信息。
<code>bash
adb logcat | grep StrictMode
</code></p>

<h2>解决违例</h2>

<ul>
<li>如果是主线程中出现文件读写违例，建议使用工作线程（必要时结合Handler）完成。</li>
<li>如果是对SharedPreferences写入操作，在API 9 以上 建议优先调用apply而非commit。</li>
<li>如果是存在未关闭的Closable对象，根据对应的stacktrace进行关闭。</li>
<li>如果是SQLite对象泄露，根据对应的stacktrace进行释放。</li>
</ul>


<p>举个例子</p>

<p>以主线程中的文件写入为例，引起违例警告的代码
```java
public void writeToExternalStorage() {</p>

<pre><code>File externalStorage = Environment.getExternalStorageDirectory();
File destFile = new File(externalStorage, "dest.txt");
try {
    OutputStream output = new FileOutputStream(destFile, true);
    output.write("droidyue.com".getBytes());
    output.flush();
    output.close();
} catch (FileNotFoundException e) {
    e.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
}
</code></pre>

<p>}
<code>
引起的警告为
</code>bash
D/StrictMode( 9730): StrictMode policy violation; ~duration=20 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=31 violation=2
D/StrictMode( 9730):    at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1176)
D/StrictMode( 9730):    at libcore.io.BlockGuardOs.open(BlockGuardOs.java:106)
D/StrictMode( 9730):    at libcore.io.IoBridge.open(IoBridge.java:390)
D/StrictMode( 9730):    at java.io.FileOutputStream.<init>(FileOutputStream.java:88)
D/StrictMode( 9730):    at com.example.strictmodedemo.MainActivity.writeToExternalStorage(MainActivity.java:56)
D/StrictMode( 9730):    at com.example.strictmodedemo.MainActivity.onCreate(MainActivity.java:30)
D/StrictMode( 9730):    at android.app.Activity.performCreate(Activity.java:4543)
<code>
因为上述属于主线程中的IO违例，解决方法就是讲写入操作放入工作线程。
</code>
public void writeToExternalStorage() {</p>

<pre><code>new Thread() {
    @Override
    public void run() {
        super.run();
        File externalStorage = Environment.getExternalStorageDirectory();
        File destFile = new File(externalStorage, "dest.txt");
        try {
            OutputStream output = new FileOutputStream(destFile, true);
            output.write("droidyue.com".getBytes());
            output.flush();
            output.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}.start();
</code></pre>

<p>}
<code>
然而这并非完善，因为OutputStream.write方法可能抛出IOException，导致存在OutputStream对象未关闭的情况，仍然需要改进避免出现Closable对象未关闭的违例。改进如下
</code>java
public void writeToExternalStorage() {</p>

<pre><code>new Thread() {
    @Override
    public void run() {
        super.run();
        File externalStorage = Environment.getExternalStorageDirectory();
        File destFile = new File(externalStorage, "dest.txt");
        OutputStream output = null;
        try {
            output = new FileOutputStream(destFile, true);
            output.write("droidyue.com".getBytes());
            output.flush();
            output.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (null != output) {
                try {
                    output.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}.start();
</code></pre>

<p>}
```</p>

<h2>检测内存泄露</h2>

<p>通常情况下，检测内存泄露，我们需要使用MAT对heap dump 文件进行分析，这种操作不困难，但也不容易。使用严格模式，只需要过滤日志就能发现内存泄露。</p>

<p>这里以Activity为例说明，首先我们需要开启对检测Activity泄露的违例检测。使用上面的detectAll或者detectActivityLeaks()均可。其次写一段能够产生Activity泄露的代码。
```
public class LeakyActivity extends Activity{</p>

<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    MyApplication.sLeakyActivities.add(this);
}
</code></pre>

<p>}
<code>
MyApplication中关于sLeakyActivities的部分实现
</code>java
public class MyApplication extends Application {</p>

<pre><code>public static final boolean IS_DEBUG = true;
public static ArrayList&lt;Activity&gt; sLeakyActivities = new ArrayList&lt;Activity&gt;();
</code></pre>

<p>}
```</p>

<p>当我们反复进入LeakyActivity再退出，过滤StrictMode就会得到这样的日志
<code>bash
E/StrictMode( 2622): class com.example.strictmodedemo.LeakyActivity; instances=2; limit=1
E/StrictMode( 2622): android.os.StrictMode$InstanceCountViolation: class com.example.strictmodedemo.LeakyActivity; instances=2; limit=1
E/StrictMode( 2622):    at android.os.StrictMode.setClassInstanceLimit(StrictMode.java:1)
</code>
分析日志，LeakyActivity本应该是只存在一份实例，但现在出现了2个，说明LeakyActivity发生了内存泄露。</p>

<p>严格模式除了可以检测Activity的内存泄露之外，还能自定义检测类的实例泄露。从API 11 开始，系统提供的这个方法可以实现我们的需求。
<code>
public StrictMode.VmPolicy.Builder setClassInstanceLimit (Class klass, int instanceLimit)
</code>
举个栗子，比如一个浏览器中只允许存在一个SearchBox实例，我们就可以这样设置已检测SearchBox实例的泄露
<code>
StrictMode.setVmPolicy(new VmPolicy.Builder().setClassInstanceLimit(SearchBox.class, 1).penaltyLog().build());
</code></p>

<h2>noteSlowCall</h2>

<p>StrictMode从 API 11开始允许开发者自定义一些耗时调用违例，这种自定义适用于自定义的任务执行类中，比如我们有一个进行任务处理的类，为TaskExecutor。
```
public class TaskExecutor {</p>

<pre><code>public void execute(Runnable task) {
    task.run();
}
</code></pre>

<p>}
<code>
先需要跟踪每个任务的耗时情况，如果大于500毫秒需要提示给开发者，noteSlowCall就可以实现这个功能，如下修改代码
</code>java
public class TaskExecutor {</p>

<pre><code>private static long SLOW_CALL_THRESHOLD = 500;
public void executeTask(Runnable task) {
    long startTime = SystemClock.uptimeMillis();
    task.run();
    long cost = SystemClock.uptimeMillis() - startTime;
    if (cost &gt; SLOW_CALL_THRESHOLD) {
        StrictMode.noteSlowCall("slowCall cost=" + cost);
    }
}
</code></pre>

<p>}
<code>
执行一个耗时2000毫秒的任务
</code>bash
TaskExecutor executor = new TaskExecutor();
executor.executeTask(new Runnable() {</p>

<pre><code>@Override
public void run() {
    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>});
<code>
得到的违例日志，注意其中`~duration=20 ms`并非耗时任务的执行时间，而我们的自定义信息`msg=slowCall cost=2000`才包含了真正的耗时。
</code>bash
D/StrictMode(23890): StrictMode policy violation; ~duration=20 ms: android.os.StrictMode$StrictModeCustomViolation: policy=31 violation=8 msg=slowCall cost=2000
D/StrictMode(23890):    at android.os.StrictMode$AndroidBlockGuardPolicy.onCustomSlowCall(StrictMode.java:1163)
D/StrictMode(23890):    at android.os.StrictMode.noteSlowCall(StrictMode.java:1974)
D/StrictMode(23890):    at com.example.strictmodedemo.TaskExecutor.executeTask(TaskExecutor.java:17)
D/StrictMode(23890):    at com.example.strictmodedemo.MainActivity.onCreate(MainActivity.java:36)
D/StrictMode(23890):    at android.app.Activity.performCreate(Activity.java:4543)
D/StrictMode(23890):    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1071)
D/StrictMode(23890):    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2158)
D/StrictMode(23890):    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2237)
D/StrictMode(23890):    at android.app.ActivityThread.access$600(ActivityThread.java:139)
D/StrictMode(23890):    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1262)
D/StrictMode(23890):    at android.os.Handler.dispatchMessage(Handler.java:99)
D/StrictMode(23890):    at android.os.Looper.loop(Looper.java:156)
D/StrictMode(23890):    at android.app.ActivityThread.main(ActivityThread.java:5005)
D/StrictMode(23890):    at java.lang.reflect.Method.invokeNative(Native Method)
D/StrictMode(23890):    at java.lang.reflect.Method.invoke(Method.java:511)
D/StrictMode(23890):    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:784)
D/StrictMode(23890):    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:551)
D/StrictMode(23890):    at dalvik.system.NativeStart.main(Native Method)
```</p>

<h2>其他技巧</h2>

<p>除了通过日志查看之外，我们也可以在开发者选项中开启严格模式，开启之后，如果主线程中有执行时间长的操作，屏幕则会闪烁，这是一个更加直接的方法。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/strictmode_developer_tools.png">http://7jpolu.com1.z0.glb.clouddn.com/strictmode_developer_tools.png</a>"></p>

<h2>问题来了</h2>

<h3>日志的时间靠谱么</h3>

<p>在下面的过滤日志中，我们看到下面的一个IO操作要消耗31毫秒，这是真的么<br/>
<code>bash
D/StrictMode( 2921): StrictMode policy violation; ~duration=31 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=31 violation=2
D/StrictMode( 2921):    at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1176)
D/StrictMode( 2921):    at libcore.io.BlockGuardOs.read(BlockGuardOs.java:148)
D/StrictMode( 2921):    at libcore.io.IoBridge.read(IoBridge.java:422)
D/StrictMode( 2921):    at java.io.FileInputStream.read(FileInputStream.java:179)
D/StrictMode( 2921):    at java.io.InputStreamReader.read(InputStreamReader.java:244)
D/StrictMode( 2921):    at java.io.BufferedReader.fillBuf(BufferedReader.java:130)
D/StrictMode( 2921):    at java.io.BufferedReader.readLine(BufferedReader.java:354)
D/StrictMode( 2921):    at com.example.strictmodedemo.MainActivity.testReadContentOfFile(MainActivity.java:65)
D/StrictMode( 2921):    at com.example.strictmodedemo.MainActivity.onCreate(MainActivity.java:28)
D/StrictMode( 2921):    at android.app.Activity.performCreate(Activity.java:4543)
</code></p>

<p>从上面的stacktrace可以看出testReadContentOfFile方法中包含了文件读取IO操作，至于是否为31毫秒，我们可以利用秒表的原理计算一下，即在方法调用的地方如下记录
<code>java
long startTime = System.currentTimeMillis();
testReadContentOfFile();
long cost = System.currentTimeMillis() - startTime;
Log.d(LOGTAG, "cost = " + cost);
</code>
得到的日志中上述操作耗时9毫秒，非31毫秒。
<code>bash
D/MainActivity(20996): cost = 9
</code>
注：通常情况下StrictMode给出的耗时相对实际情况偏高，并不是真正的耗时数据。</p>

<h2>注意</h2>

<ul>
<li>在线上环境即Release版本不建议开启严格模式。</li>
<li>严格模式无法监控JNI中的磁盘IO和网络请求。</li>
<li>应用中并非需要解决全部的违例情况，比如有些IO操作必须在主线程中进行。</li>
</ul>


<p><script type="text/javascript" src="http://droidyue.b0.upaiyun.com/js/blog/book_copyright.js"></script>
<script type="text/javascript">
	showBookCopyright();
</script>
</p>
]]></content>
  </entry>
  
</feed>
