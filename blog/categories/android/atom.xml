<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2016-03-19T18:59:32+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[理解Java中的ThreadLocal]]></title>
    <link href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/"/>
    <updated>2016-03-13T20:21:00+08:00</updated>
    <id>http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java</id>
    <content type="html"><![CDATA[<p>提到ThreadLocal，有些Android或者Java程序员可能有所陌生，可能会提出种种问题，它是做什么的，是不是和线程有关，怎么使用呢？等等问题，本文将总结一下我对ThreadLocal的理解和认识，希望让大家理解ThreadLocal更加透彻一些。</p>

<!--more-->


<h2>ThreadLocal是什么</h2>

<p>ThreadLocal是一个关于创建线程局部变量的类。</p>

<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。</p>

<h2>Global &amp;&amp; Local</h2>

<p>上面的两个修饰看似矛盾，实则不然。</p>

<ul>
<li>Global 意思是在当前线程中，任何一个点都可以访问到ThreadLocal的值。</li>
<li>Local 意思是该线程的ThreadLocal只能被该线程访问，一般情况下其他线程访问不到。</li>
</ul>


<h2>用法简介</h2>

<h3>创建，支持泛型</h3>

<p><code>java
ThreadLocal&lt;String&gt; mStringThreadLocal = new ThreadLocal&lt;&gt;();
</code></p>

<h3>set方法</h3>

<p><code>java
mStringThreadLocal.set("droidyue.com");
</code></p>

<h3>get方法</h3>

<p><code>java
mStringThreadLocal.get();
</code></p>

<p>完整的使用示例
```java
private void testThreadLocal() {</p>

<pre><code>Thread t = new Thread() {
    ThreadLocal&lt;String&gt; mStringThreadLocal = new ThreadLocal&lt;&gt;();

    @Override
    public void run() {
        super.run();
        mStringThreadLocal.set("droidyue.com");
        mStringThreadLocal.get();
    }
};

t.start();
</code></pre>

<p>}
```</p>

<h3>ThreadLocal初始值</h3>

<p>为ThreadLocal设置默认的get初始值，需要重写<code>initialValue</code>方法，下面是一段代码，我们将默认值修改成了线程的名字
```java
ThreadLocal<String> mThreadLocal = new ThreadLocal<String>() {</p>

<pre><code>@Override
protected String initialValue() {
    return Thread.currentThread().getName();
}
</code></pre>

<p>};
```</p>

<h2>Android中的应用</h2>

<p>在Android中，Looper类就是利用了ThreadLocal的特性，保证每个线程只存在一个Looper对象。
```java
static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();
private static void prepare(boolean quitAllowed) {</p>

<pre><code>if (sThreadLocal.get() != null) {
    throw new RuntimeException("Only one Looper may be created per thread");
}
sThreadLocal.set(new Looper(quitAllowed));
</code></pre>

<p>}
```</p>

<h2>如何实现</h2>

<p>为了更好的掌握ThreadLocal，我认为了解其内部实现是很有必要的，这里我们以set方法从起始看一看ThreadLocal的实现原理。</p>

<p>下面是ThreadLocal的set方法，大致意思为</p>

<ul>
<li>首先获取当前线程</li>
<li>利用当前线程作为句柄获取一个ThreadLocalMap的对象</li>
<li>如果上述ThreadLocalMap对象不为空，则设置值，否则创建这个ThreadLocalMap对象并设置值</li>
</ul>


<p>源码如下
```java
public void set(T value) {</p>

<pre><code>Thread t = Thread.currentThread();
ThreadLocalMap map = getMap(t);
if (map != null)
    map.set(this, value);
else
    createMap(t, value);
</code></pre>

<p>}
```</p>

<p>下面是一个利用Thread对象作为句柄获取ThreadLocalMap对象的代码</p>

<p>```java
ThreadLocalMap getMap(Thread t) {</p>

<pre><code>return t.threadLocals;
</code></pre>

<p>}
```</p>

<p>上面的代码获取的实际上是Thread对象的threadLocals变量，可参考下面代码
```java
class Thread implements Runnable {</p>

<pre><code>/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */

ThreadLocal.ThreadLocalMap threadLocals = null;
</code></pre>

<p>}
```</p>

<p>而如果一开始设置，即ThreadLocalMap对象未创建，则新建ThreadLocalMap对象，并设置初始值。
```java
void createMap(Thread t, T firstValue) {</p>

<pre><code>t.threadLocals = new ThreadLocalMap(this, firstValue);
</code></pre>

<p>}
```</p>

<p>总结：实际上ThreadLocal的值是放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问，其他线程无法访问。</p>

<h2>对象存放在哪里</h2>

<p>在Java中，栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</p>

<h3>问：那么是不是说ThreadLocal的实例以及其值存放在栈上呢？</h3>

<p>其实不是，因为ThreadLocal实例实际上也是被其创建的类持有（更顶端应该是被线程持有）。而ThreadLocal的值其实也是被线程实例持有。</p>

<p><strong>它们都是位于堆上，只是通过一些技巧将可见性修改成了线程可见。</strong></p>

<p>关于堆和栈的比较，请参考<a href="http://droidyue.com/blog/2014/12/07/differences-between-stack-and-heap-in-java/">Java中的堆和栈的区别</a></p>

<h2>真的只能被一个线程访问么</h2>

<p>既然上面提到了ThreadLocal只对当前线程可见，是不是说ThreadLocal的值只能被一个线程访问呢？</p>

<p>使用InheritableThreadLocal可以实现多个线程访问ThreadLocal的值。</p>

<p>如下，我们在主线程中创建一个InheritableThreadLocal的实例，然后在子线程中得到这个InheritableThreadLocal实例设置的值。</p>

<p>```java
private void testInheritableThreadLocal() {</p>

<pre><code>final ThreadLocal threadLocal = new InheritableThreadLocal();
threadLocal.set("droidyue.com");
Thread t = new Thread() {
    @Override
    public void run() {
        super.run();
        Log.i(LOGTAG, "testInheritableThreadLocal =" + threadLocal.get());
    }
};

t.start();
</code></pre>

<p>}
<code>
上面的代码输出的日志信息为
</code>
I/MainActivity( 5046): testInheritableThreadLocal =droidyue.com
<code>
使用InheritableThreadLocal可以将某个线程的ThreadLocal值在其子线程创建时传递过去。因为在线程创建过程中，有相关的处理逻辑。
</code>java
//Thread.java
 private void init(ThreadGroup g, Runnable target, String name,</p>

<pre><code>                  long stackSize, AccessControlContext acc) {
    //code goes here
    if (parent.inheritableThreadLocals != null)
        this.inheritableThreadLocals =
            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
    /* Stash the specified stack size in case the VM cares */
    this.stackSize = stackSize;

    /* Set thread ID */
    tid = nextThreadID();
</code></pre>

<p>}
```
上面代码就是在线程创建的时候，复制父线程的inheritableThreadLocals的数据。</p>

<h2>会导致内存泄露么</h2>

<p>有网上讨论说ThreadLocal会导致内存泄露，原因如下</p>

<ul>
<li>首先ThreadLocal实例被线程的ThreadLocalMap实例持有，也可以看成被线程持有。</li>
<li>如果应用使用了线程池，那么之前的线程实例处理完之后出于复用的目的依然存活</li>
<li>所以，ThreadLocal设定的值被持有，导致内存泄露。</li>
</ul>


<p>上面的逻辑是清晰的，可是ThreadLocal并不会产生内存泄露，因为ThreadLocalMap做选择key的时候，并不是直接选择ThreadLocal实例，而是ThreadLocalMap实例的弱引用。
```java
static class ThreadLocalMap {</p>

<p>/<em>*
* The entries in this hash map extend WeakReference, using
* its main ref field as the key (which is always a
* ThreadLocal object).  Note that null keys (i.e. entry.get()
* == null) mean that the key is no longer referenced, so the
* entry can be expunged from table.  Such entries are referred to
* as &ldquo;stale entries&rdquo; in the code that follows.
</em>/</p>

<pre><code>static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
    /** The value associated with this ThreadLocal. */
    Object value;

    Entry(ThreadLocal&lt;?&gt; k, Object v) {
        super(k);
        value = v;
    }
}
</code></pre>

<p>}
```
所以实际上从ThreadLocal设计角度来说是不会导致内存泄露的。关于弱引用，了解更多，请访问<a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">译文：理解Java中的弱引用
</a></p>

<h2>使用场景</h2>

<ul>
<li>实现单个线程单例以及单个线程上下文信息存储，比如交易id等</li>
<li>实现线程安全，非线程安全的对象使用ThreadLocal之后就会变得线程安全，因为每个线程都会有一个对应的实例</li>
<li>承载一些线程相关的数据，避免在方法中来回传递参数</li>
</ul>


<h2>参考文章</h2>

<ul>
<li><a href="http://tutorials.jenkov.com/java-concurrency/threadlocal.html">Java ThreadLocal</a></li>
<li><a href="http://cs.oswego.edu/pipermail/concurrency-interest/2007-October/004456.html">Threadlocals and memory leaks in J2EE</a></li>
<li><a href="http://veerasundar.com/blog/2010/11/java-thread-local-how-to-use-and-code-sample/">Java Thread Local – How to use and code sample</a></li>
<li><a href="http://javarevisited.blogspot.hk/2012/05/how-to-use-threadlocal-in-java-benefits.html">ThreadLocal in Java &ndash; Example Program and Tutorial</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android签名相关知识整理]]></title>
    <link href="http://droidyue.com/blog/2016/03/06/summary-of-android-signing/"/>
    <updated>2016-03-06T16:17:00+08:00</updated>
    <id>http://droidyue.com/blog/2016/03/06/summary-of-android-signing</id>
    <content type="html"><![CDATA[<p>不止一次有用到Android签名相关的知识，每次都几乎从零开始在Google上搜索找，不想在继续这样了，找了个时间好好整理了一下自己用到的一些碎片知识，于是乎放到这里，一是备忘，二是帮助别人。</p>

<!--more-->


<h2>从APK文件中获取签名信息</h2>

<h3>使用方法</h3>

<p><code>java
keytool -list -printcert -jarfile your_apk_file
</code></p>

<h3>输出信息</h3>

<ul>
<li>签名Owner,Issuer等信息</li>
<li>签名的fingerprints,如md5及sha1等值</li>
<li>签名有效期等信息</li>
</ul>


<h3>示例效果</h3>

<p>```java
16:29 $ keytool -list -printcert -jarfile akoi_1.2.apk
Signer #1:</p>

<p>Signature:</p>

<p>Owner: CN=Andrew Wallace, OU=droidyue.com, O=droidyue.com, L=Beijing, ST=Beijing, C=86
Issuer: CN=Andrew Wallace, OU=droidyue.com, O=droidyue.com, L=Beijing, ST=Beijing, C=86
Serial number: 11a8a4a3
Valid from: Tue Feb 10 18:07:43 CST 2015 until: Sun Jun 13 18:07:43 CST 3013
Certificate fingerprints:</p>

<pre><code> MD5:  46:C5:BE:EF:B5:C9:00:E1:FA:42:50:50:57:54:CA:15
 SHA1: C1:14:5D:0A:C2:BF:F6:06:43:20:AE:2C:07:12:97:58:C2:1B:39:D1
 SHA256: 0E:88:7D:C2:4C:D6:84:A7:58:D4:24:1E:9D:38:F9:05:98:1E:B2:A2:D7:CB:0F:81:74:60:5B:38:89:FF:21:1C
 Signature algorithm name: SHA256withRSA
 Version: 3
</code></pre>

<p>```</p>

<h2>从签名文件中获取签名信息</h2>

<h3>使用方法</h3>

<p><code>java
keytool -list -v -keystore your_kestore_file
</code>
注意，上述命令执行后，会提示输入密码，其实输入错误也没有关系，不影响结果。</p>

<h3>输出信息</h3>

<ul>
<li>签名Owner,Issuer等信息</li>
<li>签名的fingerprints,如md5及sha1等值</li>
<li>签名有效期等信息</li>
</ul>


<h3>示例效果</h3>

<p>```java
Keystore type: JKS
Keystore provider: SUN</p>

<p>Your keystore contains 1 entry</p>

<p>Alias name: droidyue.com
Creation date: Feb 10, 2015
Entry type: PrivateKeyEntry
Certificate chain length: 1
Certificate[1]:
Owner: CN=Andrew Wallace, OU=droidyue.com, O=droidyue.com, L=Beijing, ST=Beijing, C=86
Issuer: CN=Andrew Wallace, OU=droidyue.com, O=droidyue.com, L=Beijing, ST=Beijing, C=86
Serial number: 11a8a4a3
Valid from: Tue Feb 10 18:07:43 CST 2015 until: Sun Jun 13 18:07:43 CST 3013
Certificate fingerprints:</p>

<pre><code> MD5:  46:C5:BE:EF:B5:C9:00:E1:FA:42:50:50:57:54:CA:15
 SHA1: C1:14:5D:0A:C2:BF:F6:06:43:20:AE:2C:07:12:97:58:C2:1B:39:D1
 SHA256: 0E:88:7D:C2:4C:D6:84:A7:58:D4:24:1E:9D:38:F9:05:98:1E:B2:A2:D7:CB:0F:81:74:60:5B:38:89:FF:21:1C
 Signature algorithm name: SHA256withRSA
 Version: 3
</code></pre>

<p>```</p>

<h2>重新签名APK</h2>

<p>在没有源码情况下，我们就能对apk进行更换签名。</p>

<h3>脚本</h3>

<ul>
<li><a href="https://apk-resigner.googlecode.com/svn/trunk/signapk.sh">signapk.sh</a></li>
<li><a href="http://7jpqsg.com1.z0.glb.clouddn.com/signapk.sh">备用地址</a></li>
</ul>


<h3>使用方法</h3>

<p><code>java
bash signapk.sh your_apk_file your_keystore_file keystore_pass keystore_alias
</code></p>

<h3>示例效果</h3>

<p><code>java
16:57 $ bash signapk.sh weixin6313android740.apk ~/Documents/baidu_disk/百度云同步盘/droidapp/mykiki 123456 droidyue.com
param1 weixin6313android740.apk
param2 /Users/androidyue/Documents/droidapp/mykiki
param3 123456
param4 droidyue.com
deleting: META-INF/MANIFEST.MF
deleting: META-INF/DROIDYUE.SF
deleting: META-INF/DROIDYUE.RSA
   adding: META-INF/MANIFEST.MF
   adding: META-INF/DROIDYUE.SF
   adding: META-INF/DROIDYUE.RSA
......
Verification succesful
</code></p>

<p>生成的文件会放在当前目录，其文件名相对输入文件，增加了<code>signed_</code>前缀，比如对<code>weixin6313android740.apk</code>进行上述操作得到的输出文件是<code>signed_weixin6313android740.apk</code></p>

<h2>Gradle build生成签名APK</h2>

<p>想要在执行gradle build时生成指定签名的apk，需要在build.gradle中如下修改
```java
android {</p>

<pre><code>signingConfigs {
    release {
        storeFile file("myrelease.keystore")
        storePassword "********"
        keyAlias "******"
        keyPassword "******"
    }
}
buildTypes {
    release {
        signingConfig signingConfigs.release
    }
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于获取当前Activity的一些思考]]></title>
    <link href="http://droidyue.com/blog/2016/02/21/thinking-of-getting-the-current-activity-in-android/"/>
    <updated>2016-02-21T20:53:00+08:00</updated>
    <id>http://droidyue.com/blog/2016/02/21/thinking-of-getting-the-current-activity-in-android</id>
    <content type="html"><![CDATA[<p>在Android开发过程中，我们有时候需要获取当前的Activity实例，比如弹出Dialog操作，必须要用到这个。关于如何实现由很多种思路，这其中有的简单，有的复杂，这里简单总结一下个人的一些经验吧。</p>

<!--more-->


<h2>反射</h2>

<p>反射是我们经常会想到的方法，思路大概为</p>

<p>  1 获取ActivityThread中所有的ActivityRecord <br/>
  2 从ActivityRecord中获取状态不是<code>pause</code>的Activity并返回</p>

<p>一个使用反射来实现的代码大致如下
```java</p>

<pre><code>public static Activity getActivity() {
    Class activityThreadClass = null;
    try {
        activityThreadClass = Class.forName("android.app.ActivityThread");
        Object activityThread = activityThreadClass.getMethod("currentActivityThread").invoke(null);
        Field activitiesField = activityThreadClass.getDeclaredField("mActivities");
        activitiesField.setAccessible(true);
        Map activities = (Map) activitiesField.get(activityThread);
        for (Object activityRecord : activities.values()) {
            Class activityRecordClass = activityRecord.getClass();
            Field pausedField = activityRecordClass.getDeclaredField("paused");
            pausedField.setAccessible(true);
            if (!pausedField.getBoolean(activityRecord)) {
                Field activityField = activityRecordClass.getDeclaredField("activity");
                activityField.setAccessible(true);
                Activity activity = (Activity) activityField.get(activityRecord);
                return activity;
            }
        }
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } catch (NoSuchMethodException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (InvocationTargetException e) {
        e.printStackTrace();
    } catch (NoSuchFieldException e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>

<p>```</p>

<p>然而这种方法并不是很推荐，主要是有以下的不足：</p>

<ul>
<li>反射通常会比较慢</li>
<li>不稳定性，这个才是不推荐的原因，Android框架代码存在修改的可能性，谁要无法100%保证<code>mActivities</code>，<code>paused</code>固定不变。所以可靠性不是完全可靠。</li>
</ul>


<h2>Activity基类</h2>

<p>既然反射不是很可靠，那么有一种比较可靠的方式，就是使用Activity基类。</p>

<p>在Activity的<code>onResume</code>方法中，将当前的Activity实例保存到一个变量中。
```java
public class BaseActivity extends Activity{</p>

<pre><code>@Override
protected void onResume() {
    super.onResume();
    MyActivityManager.getInstance().setCurrentActivity(this);
}
</code></pre>

<p>}
```</p>

<p>然而，这一种方法也不仅完美，因为这种方法是基于约定的，所以必须每个Activity都继承BaseActivity，如果一旦出现没有继承BaseActivity的就可能有问题。</p>

<h2>回调方法</h2>

<p>介绍了上面两种不是尽善尽美的方法，这里实际上还是有一种更便捷的方法，那就是通过Framework提供的回调来实现。</p>

<p>Android自 API 14开始引入了一个方法，即Application的<code>registerActivityLifecycleCallbacks</code>方法，用来监听所有Activity的生命周期回调，比如<code>onActivityCreated</code>,<code>onActivityResumed</code>等。</p>

<p>So，一个简单的实现如下
```java
public class MyApplication extends Application {</p>

<pre><code>@Override
public void onCreate() {
    super.onCreate();
    registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {
        @Override
        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {

        }

        @Override
        public void onActivityStarted(Activity activity) {

        }

        @Override
        public void onActivityResumed(Activity activity) {
            MyActivityManager.getInstance().setCurrentActivity(activity);
        }

        @Override
        public void onActivityPaused(Activity activity) {

        }

        @Override
        public void onActivityStopped(Activity activity) {

        }

        @Override
        public void onActivitySaveInstanceState(Activity activity, Bundle outState) {

        }

        @Override
        public void onActivityDestroyed(Activity activity) {

        }
    });
}
</code></pre>

<p>}
```</p>

<p>然而，金无足赤人无完人，这种方法唯一的遗憾就是只支持API 14即其以上。不过还在现在大多数设备都满足了这个要求。</p>

<h3>为什么是弱引用</h3>

<p>可能有人会带着疑问看到这里，MyActivityManager是个什么鬼，好，我们现在看一下这个类的实现
```java
public class MyActivityManager {</p>

<pre><code>private static MyActivityManager sInstance = new MyActivityManager();
private WeakReference&lt;Activity&gt; sCurrentActivityWeakRef;


private MyActivityManager() {

}

public static MyActivityManager getInstance() {
    return sInstance;
}

public Activity getCurrentActivity() {
    Activity currentActivity = null;
    if (sCurrentActivityWeakRef != null) {
        currentActivity = sCurrentActivityWeakRef.get();
    }
    return currentActivity;
}

public void setCurrentActivity(Activity activity) {
    sCurrentActivityWeakRef = new WeakReference&lt;Activity&gt;(activity);
}
</code></pre>

<p>}
```</p>

<p>这个类，实现了当前Activity的设置和获取。</p>

<p>那么为什么要使用弱引用持有Activity实例呢？</p>

<p>其实最主要的目的就是避免内存泄露，因为使用默认的强引用会导致Activity实例无法释放，导致内存泄露的出现。详细了解弱引用，请参考本文<a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">译文：理解Java中的弱引用</a></p>

<h2>Demo源码</h2>

<ul>
<li><a href="https://github.com/androidyue/GetCurrentActivityDemo">GetCurrentActivityDemo</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[聊一聊Android 6.0的运行时权限]]></title>
    <link href="http://droidyue.com/blog/2016/01/17/understanding-marshmallow-runtime-permission/"/>
    <updated>2016-01-17T20:40:00+08:00</updated>
    <id>http://droidyue.com/blog/2016/01/17/understanding-marshmallow-runtime-permission</id>
    <content type="html"><![CDATA[<p>Android 6.0，代号棉花糖，自发布伊始，其主要的特征运行时权限就很受关注。因为这一特征不仅改善了用户对于应用的使用体验，还使得应用开发者在实践开发中需要做出改变。</p>

<p>没有深入了解运行时权限的开发者通常会有很多疑问，比如什么是运行时权限，哪些是运行时的权限，我的应用是不是会在6.0系统上各种崩溃呢，如何才能支持运行时权限机制呢。本文讲尝试回答这一些问题，希望读者阅读完成之后，都能找到较为完美的答案。</p>

<!--more-->


<h2>权限一刀切</h2>

<p>在6.0以前的系统，都是权限一刀切的处理方式，<strong>只要用户安装，Manifest申请的权限都会被赋予，并且安装后权限也撤销不了</strong>。<br/>
这种情况下，当我们从Google Play安装一个应用，在安装之前会得到这样的权限提示信息。</p>

<p><img src="http://7jpolu.com1.z0.glb.clouddn.com/pre-marshmallow-permission.jpg" alt="Permission" /></p>

<p>当上述对话框弹出后，用户只有两种选择：</p>

<ul>
<li>我信任你，即使有敏感权限</li>
<li>你一个**应用，要这个权限干嘛，我还是不安装了。</li>
</ul>


<p>所以，这种一刀切的处理方式还是有弊端的，我们没有办法只允许某些权限或者拒绝某些权限。</p>

<h2>棉花糖运行时权限</h2>

<p>从棉花糖开始，Android系统引入了新的权限机制，即本文要讲的运行时权限。</p>

<p>何为运行时权限呢？举个栗子，以某个需要拍照的应用为例，当运行时权限生效时，其Camera权限不是在安装后赋予，而是在应用运行的时候进行请求权限（比如当用户按下”相机拍照“按钮后）看到的效果则是这样的</p>

<p><img src="http://7jpolu.com1.z0.glb.clouddn.com/marshmallow-permission.png" alt="Requesting Camera Permission" /></p>

<p>接下来，对于Camera权限的处理完全权交给用户。是不是有点像苹果系统的处理呢，不要说这是抄袭，暂且称为师夷长技以制夷。</p>

<h2>权限的分组</h2>

<p>Android中有很多权限，但并非所有的权限都是敏感权限，于是6.0系统就对权限进行了分类，一般为下述几类</p>

<ul>
<li>正常(Normal Protection)权限</li>
<li>危险(Dangerous)权限</li>
<li>特殊(Particular)权限</li>
<li>其他权限（一般很少用到）</li>
</ul>


<h2>正常权限</h2>

<p>正常权限具有如下的几个特点</p>

<ul>
<li>对用户隐私没有较大影响或者不会打来安全问题。</li>
<li>安装后就赋予这些权限，<strong>不需要显示提醒用户，用户也不能取消这些权限</strong>。</li>
</ul>


<h3>正常权限列表</h3>

<p><code>java
ACCESS_LOCATION_EXTRA_COMMANDS
ACCESS_NETWORK_STATE
ACCESS_NOTIFICATION_POLICY
ACCESS_WIFI_STATE
BLUETOOTH
BLUETOOTH_ADMIN
BROADCAST_STICKY
CHANGE_NETWORK_STATE
CHANGE_WIFI_MULTICAST_STATE
CHANGE_WIFI_STATE
DISABLE_KEYGUARD
EXPAND_STATUS_BAR
GET_PACKAGE_SIZE
INTERNET
KILL_BACKGROUND_PROCESSES
MODIFY_AUDIO_SETTINGS
NFC
READ_SYNC_SETTINGS
READ_SYNC_STATS
RECEIVE_BOOT_COMPLETED
REORDER_TASKS
REQUEST_INSTALL_PACKAGES
SET_TIME_ZONE
SET_WALLPAPER
SET_WALLPAPER_HINTS
TRANSMIT_IR
USE_FINGERPRINT
VIBRATE
WAKE_LOCK
WRITE_SYNC_SETTINGS
SET_ALARM
INSTALL_SHORTCUT
UNINSTALL_SHORTCUT
</code>
上述的权限基本设计的是关于网络，蓝牙，时区，快捷方式等方面，只要在Manifest指定了这些权限，就会被授予，并且不能撤销。</p>

<h2>特殊权限</h2>

<p>这里讲特殊权限提前讲一下，因为这个相对来说简单一些。</p>

<p>特殊权限，顾名思义，就是一些特别敏感的权限，在Android系统中，主要由两个</p>

<ul>
<li>SYSTEM_ALERT_WINDOW，设置悬浮窗，进行一些黑科技</li>
<li>WRITE_SETTINGS  修改系统设置</li>
</ul>


<p>关于上面两个特殊权限的授权，做法是使用<code>startActivityForResult</code>启动授权界面来完成。</p>

<h3>请求SYSTEM_ALERT_WINDOW</h3>

<p>```java
private static final int REQUEST_CODE = 1;
private  void requestAlertWindowPermission() {</p>

<pre><code>Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);
intent.setData(Uri.parse("package:" + getPackageName()));
startActivityForResult(intent, REQUEST_CODE);
</code></pre>

<p>}</p>

<p>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {</p>

<pre><code>super.onActivityResult(requestCode, resultCode, data);
if (requestCode == REQUEST_CODE) {
    if (Settings.canDrawOverlays(this)) {
        Log.i(LOGTAG, "onActivityResult granted");
    }
}
</code></pre>

<p>}
```</p>

<p>上述代码需要注意的是</p>

<ul>
<li>使用Action <code>Settings.ACTION_MANAGE_OVERLAY_PERMISSION</code>启动隐式Intent</li>
<li>使用<code>"package:" + getPackageName()</code>携带App的包名信息</li>
<li>使用<code>Settings.canDrawOverlays</code>方法判断授权结果</li>
</ul>


<h3>请求WRITE_SETTINGS</h3>

<p>```java
private static final int REQUEST_CODE_WRITE_SETTINGS = 2;
private void requestWriteSettings() {</p>

<pre><code>Intent intent = new Intent(Settings.ACTION_MANAGE_WRITE_SETTINGS);
intent.setData(Uri.parse("package:" + getPackageName()));
startActivityForResult(intent, REQUEST_CODE_WRITE_SETTINGS );
</code></pre>

<p>}
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {</p>

<pre><code>super.onActivityResult(requestCode, resultCode, data);
if (requestCode == REQUEST_CODE_WRITE_SETTINGS) {
    if (Settings.System.canWrite(this)) {
        Log.i(LOGTAG, "onActivityResult write settings granted" );
    }
}
</code></pre>

<p>}
```</p>

<p>上述代码需要注意的是</p>

<ul>
<li>使用Action <code>Settings.ACTION_MANAGE_WRITE_SETTINGS</code> 启动隐式Intent</li>
<li>使用<code>"package:" + getPackageName()</code>携带App的包名信息</li>
<li>使用<code>Settings.System.canWrite</code>方法检测授权结果</li>
</ul>


<p>注意：关于这两个特殊权限，一般不建议应用申请。</p>

<h2>危险权限</h2>

<p>危险权限实际上才是运行时权限主要处理的对象，这些权限可能引起隐私问题或者影响其他程序运行。Android中的危险权限可以归为以下几个分组：</p>

<ul>
<li>CALENDAR</li>
<li>CAMERA</li>
<li>CONTACTS</li>
<li>LOCATION</li>
<li>MICROPHONE</li>
<li>PHONE</li>
<li>SENSORS</li>
<li>SMS</li>
<li>STORAGE</li>
</ul>


<p>各个权限分组与其具体的权限，可以参考下图：</p>

<p><img src="http://ww4.sinaimg.cn/large/6a195423jw1ezwpc11cs0j20hr0majwm.jpg" alt="Permission Groups and detailed permissions" /></p>

<h2>必须要支持运行时权限么</h2>

<p>目前应用实际上是可以不需要支持运行时权限的，但是最终肯定还是需要支持的，只是时间问题而已。</p>

<p>想要不支持运行时权限机制很简单，只需要将<code>targetSdkVersion</code>设置低于23就可以了，意思是告诉系统，我还没有完全在API 23（6.0）上完全搞定，不要给我启动新的特性。</p>

<h2>不支持运行时权限会崩溃么</h2>

<p>可能会，但不是那种一上来就噼里啪啦崩溃不断的那种。</p>

<p>如果你的应用将<code>targetSdkVersion</code>设置低于23，那么在6.0的系统上不会为这个应用开启运行时权限机制，即按照以前的一刀切方式处理。</p>

<h3>然而有点糟糕的是</h3>

<p>6.0系统提供了一个应用权限管理界面，界面长得是这样的</p>

<p><img class="<a" src="href="http://ww2.sinaimg.cn/large/6a195423jw1ezwqnmjhcdj20u01hc40k.jpg">http://ww2.sinaimg.cn/large/6a195423jw1ezwqnmjhcdj20u01hc40k.jpg</a>" width="300"></p>

<p>既然是可以管理，用户就能取消权限，当一个不支持运行时权限的应用某项权限被取消时</p>

<p><img class="<a" src="href="http://ww4.sinaimg.cn/large/6a195423jw1ezwqaftmpgj20u01hc77e.jpg">http://ww4.sinaimg.cn/large/6a195423jw1ezwqaftmpgj20u01hc77e.jpg</a>" width="300"></p>

<p>系统会弹出一个对话框提醒撤销的危害，如果用户执意撤销，会带来如下的反应</p>

<ul>
<li>如果你的程序正在运行，则会被杀掉。</li>
<li>当你的应用再次运行时，可能出现崩溃</li>
</ul>


<p>为什么会可能崩溃的，比如下面这段代码
<code>
TelephonyManager telephonyManager = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);
String deviceId = telephonyManager.getDeviceId();
if (deviceId.equals(mLastDeviceId)) {//This may cause NPE
  //do something
}
</code>
如果用户撤消了获取DeviceId的权限，那么再次运行时,deviceId就是null，如果程序后续处理不当，就会出现崩溃。</p>

<h2>该来的还得来</h2>

<p>6.0的运行时权限，我们最终都是要支持的，通常我们需要使用如下的API</p>

<ul>
<li><strong>int checkSelfPermission(String permission)</strong> 用来检测应用是否已经具有权限</li>
<li><strong>void requestPermissions(String[] permissions, int requestCode)</strong>  进行请求单个或多个权限</li>
<li><strong>void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults)</strong> 用户对请求作出响应后的回调</li>
</ul>


<p>以一个请求Camera权限为例
```java</p>

<pre><code>@Override
public void onClick(View v) {
    if (!(checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED)) {
        requestCameraPermission();
    }
}

private static final int REQUEST_PERMISSION_CAMERA_CODE = 1;
private void requestCameraPermission() {
    requestPermissions(new String[]{Manifest.permission.CAMERA}, REQUEST_PERMISSION_CAMERA_CODE);
}

@Override
public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    if (requestCode == REQUEST_PERMISSION_CAMERA_CODE) {
        int grantResult = grantResults[0];
        boolean granted = grantResult == PackageManager.PERMISSION_GRANTED;
        Log.i(LOGTAG, "onRequestPermissionsResult granted=" + granted);
    }
}
</code></pre>

<p>```</p>

<p>通常情况下，我们会得到这样的一个对话框</p>

<p><img class="<a" src="href="http://ww1.sinaimg.cn/large/6a195423jw1ezwtttfjp1j20u01hc0vr.jpg">http://ww1.sinaimg.cn/large/6a195423jw1ezwtttfjp1j20u01hc0vr.jpg</a>" width="300"></p>

<p><strong>当用户选择允许，我们就可以在onRequestPermissionsResult方法中进行响应的处理，比如打开摄像头</strong><br/>
<strong>当用户拒绝，你的应用可能就开始危险了</strong></p>

<p>当我们再次尝试申请权限时，弹出的对话框和之前有点不一样了，主要表现为多了一个checkbox。如下图</p>

<p><img class="<a" src="href="http://ww1.sinaimg.cn/large/6a195423jw1ezwtz1ljjgj20u01hcad8.jpg">http://ww1.sinaimg.cn/large/6a195423jw1ezwtz1ljjgj20u01hcad8.jpg</a>" width="300"></p>

<p>当用户勾选了”不再询问“拒绝后，你的程序基本这个权限就Game Over了。</p>

<p>不过，你还有一丝希望，那就是再出现上述的对话框之前做一些说明信息，比如你使用这个权限的目的（一定要坦白）。</p>

<p>shouldShowRequestPermissionRationale这个API可以帮我们判断接下来的对话框是否包含”不再询问“选择框。</p>

<h3>一个标准的流程</h3>

<p>```java
if (!(checkSelfPermission(Manifest.permission.READ_CONTACTS) == PackageManager.PERMISSION_GRANTED)) {
  if (shouldShowRequestPermissionRationale(Manifest.permission.READ_CONTACTS)) {</p>

<pre><code>  Toast.makeText(this, "Please grant the permission this time", Toast.LENGTH_LONG).show();
}
requestReadContactsPermission();
</code></pre>

<p>} else {
  Log.i(LOGTAG, &ldquo;onClick granted&rdquo;);
}
```</p>

<h3>如何批量申请</h3>

<p>批量申请权限很简单，只需要字符串数组放置多个权限即可。如请求代码
```java
private static final int REQUEST_CODE = 1;
private void requestMultiplePermissions() {</p>

<pre><code>String[] permissions = {Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_PHONE_STATE};
requestPermissions(permissions, REQUEST_CODE);
</code></pre>

<p>}
```
对应的界面效果是
<img src="http://ww2.sinaimg.cn/large/6a195423jw1ezxulzbeu2j20iq0ggt9y.jpg" alt="Multiple Requesting Permissions" /></p>

<p>注意：间隔较短的多个权限申请建议设置成单次多个权限申请形式，避免弹出多个对话框，造成不太好的视觉效果。</p>

<h3>申请这么多权限岂不是很累</h3>

<p>其实你不需要每个权限都去显式申请，举一个例子，如果你的应用授权了读取联系人的权限，那么你的应用也是被赋予了写入联系人的权限。因为读取联系人和写入联系人这两个权限都属于联系人权限分组，所以一旦组内某个权限被允许，该组的其他权限也是被允许的。</p>

<h2>注意事项</h2>

<h3>API问题</h3>

<p>由于checkSelfPermission和requestPermissions从API 23才加入，低于23版本，需要在运行时判断 或者使用Support Library v4中提供的方法</p>

<ul>
<li>ContextCompat.checkSelfPermission</li>
<li>ActivityCompat.requestPermissions</li>
<li>ActivityCompat.shouldShowRequestPermissionRationale</li>
</ul>


<h3>多系统问题</h3>

<p>当我们支持了6.0必须也要支持4.4，5.0这些系统，所以需要在很多情况下，需要有两套处理。比如Camera权限
```java
if (isMarshmallow()) {</p>

<pre><code>requestPermission();//然后在回调中处理
</code></pre>

<p>} else {</p>

<pre><code>useCamera();//低于6.0直接使用Camera
</code></pre>

<p>}
```</p>

<h2>两个权限</h2>

<p>运行时权限对于应用影响比较大的权限有两个，他们分别是</p>

<ul>
<li>READ_PHONE_STATE</li>
<li>WRITE_EXTERNAL_STORAGE/READ_EXTERNAL_STORAGE</li>
</ul>


<p>其中READ_PHONE_STATE用来获取deviceID，即IMEI号码。这是很多统计依赖计算设备唯一ID的参考。如果新的权限导致读取不到，避免导致统计的异常。建议在完全支持运行时权限之前，将对应的值写入到App本地数据中，对于新安装的，可以采取其他策略减少对统计的影响。</p>

<p>WRITE_EXTERNAL_STORAGE/READ_EXTERNAL_STORAGE这两个权限和外置存储（即sdcard）有关，对于下载相关的应用这一点还是比较重要的，我们应该尽可能的说明和引导用户授予该权限。</p>

<h2>些许建议</h2>

<ul>
<li>不要使用多余的权限，新增权限时要慎重</li>
<li>使用Intent来替代某些权限，如拨打电话（和你的产品经理PK去吧）</li>
<li>对于使用权限获取的某些值，比如deviceId，尽量本地存储，下次访问直接使用本地的数据值</li>
<li>注意，由于用户可以撤销某些权限，所以不要使用应用本地的标志位来记录是否获取到某权限。</li>
</ul>


<h2>注意</h2>

<p>即使支持了运行时权限，也要在Manifest声明，因为市场应用会根据这个信息和硬件设备进行匹配，决定你的应用是否在该设备上显示。</p>

<h2>是否支持运行时权限</h2>

<p>个人觉得Marshmallow的运行时权限对于用户来说绝对是一个好东西，但是目前想要支持需要做的事情还是比较多的。</p>

<p>对于一个有很多依赖的宿主应用，想要做到支持还是有一些工作量的，因为你的权限申请受制于依赖。</p>

<p>建议在短期内暂时可以不考虑支持该运行时权限机制,等时机成熟或者简单易用的第三方库完善之后再支持也未尝不可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修复Android中Navigation Bar遮挡PopupWindow的问题]]></title>
    <link href="http://droidyue.com/blog/2016/01/10/android-navigation-bar-popupwindow-issue/"/>
    <updated>2016-01-10T14:41:00+08:00</updated>
    <id>http://droidyue.com/blog/2016/01/10/android-navigation-bar-popupwindow-issue</id>
    <content type="html"><![CDATA[<p>最近遇到了一个问题，关于Navigation Bar遮挡PopupWindow的问题，问题不难，粗略做一点总结。</p>

<!--more-->


<h2>现象描述</h2>

<ul>
<li>问题应该出现在5.0 Lollipop版本及以上</li>
<li>遮挡的现象如下图,Navigation Bar位于了PopupWindow的上层，明显是一种问题。</li>
</ul>


<p><img src="http://7jpolu.com1.z0.glb.clouddn.com/navigation_issue.png" alt="Android Navigation Bar Issue" /></p>

<h2>我的实现代码</h2>

<p>```java
private void showPopupWindow() {</p>

<pre><code>if (mPopupWindow == null) {
    View contentView = LayoutInflater.from(this).inflate(R.layout.popup_window_content, null);
    mPopupWindow = new PopupWindow(contentView, LinearLayout.LayoutParams.MATCH_PARENT,500, true);
    mPopupWindow.setBackgroundDrawable(new BitmapDrawable());
}
mPopupWindow.showAtLocation(findViewById(R.id.contentContainer), Gravity.BOTTOM, 0,0);
</code></pre>

<p>}
```
<strong>其实和具体的实现代码没有关系</strong>，重点是修改主题style。</p>

<h2>修改style</h2>

<p>修改v21/styles.xml(如没有，可以创建),将<code>android:windowDrawsSystemBarBackgrounds</code>修改为<code>false</code>。</p>

<p>```xml</p>



<p>```</p>

<h2>修改好的效果</h2>

<p><img src="http://7jpolu.com1.z0.glb.clouddn.com/navigation_bar_good.png" alt="Good PopupWindow" /></p>

<h2>更佳的方法</h2>

<p>感谢来自Github的网友提出了一个更优秀的方案。很简单，设置如下代码即可
<code>java
popupWindow.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
</code>
注意：这个方法不会影响到状态栏的颜色改变，而第一种方法会。</p>

<h2>demo源码</h2>

<p><a href="https://github.com/androidyue/Navigation-Bar-Issue-Demo">Navigation Bar Issue Demo</a></p>
]]></content>
  </entry>
  
</feed>
