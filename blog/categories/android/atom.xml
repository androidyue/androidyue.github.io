<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2014-12-30T21:55:56+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android中Handler引起的内存泄露]]></title>
    <link href="http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur/"/>
    <updated>2014-12-28T11:24:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur</id>
    <content type="html"><![CDATA[<p>在Android常用编程中，Handler在进行异步操作并处理返回结果时经常被使用。通常我们的代码会这样实现。
```java
public class SampleActivity extends Activity {</p>

<p>  private final Handler mLeakyHandler = new Handler() {</p>

<pre><code>@Override
public void handleMessage(Message msg) {
  // ... 
}
</code></pre>

<p>  }
}
```</p>

<!--more-->


<p>但是，其实上面的代码可能导致内存泄露，当你使用Android lint工具的话，会得到这样的警告</p>

<blockquote><p>In Android, Handler classes should be static or leaks might occur, Messages enqueued on the application thread&rsquo;s MessageQueue also retain their target Handler. If the Handler is an inner class, its outer class will be retained as well. To avoid leaking the outer class, declare the Handler as a static nested class with a WeakReference to its outer class</p></blockquote>

<p>看到这里，可能还是有一些搞不清楚，代码中哪里可能导致内存泄露，又是如何导致内存泄露的呢？那我们就慢慢分析一下。</p>

<p>1.当一个Android应用启动的时候，会自动创建一个供应用主线程使用的Looper实例。Looper的主要工作就是一个一个处理消息队列中的消息对象。在Android中，所有Android框架的事件（比如Activity的生命周期方法调用和按钮点击等）都是放入到消息中，然后加入到Looper要处理的消息队列中，由Looper负责一条一条地进行处理。主线程中的Looper生命周期和当前应用一样长。</p>

<p>2.当一个Handler在主线程进行了初始化之后，我们发送一个target为这个Handler的消息到Looper处理的消息队列时，实际上已经发送的消息已经包含了一个Handler实例的引用，只有这样Looper在处理到这条消息时才可以调用Handler#handleMessage(Message)完成消息的正确处理。</p>

<p>3.在Java中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用。静态的内部类不会持有外部类的引用。关于这一内容可以查看<a href="http://droidyue.com/blog/2014/10/02/the-private-modifier-in-java/">细话Java："失效"的private修饰符</a></p>

<p>确实上面的代码示例有点难以察觉内存泄露，那么下面的例子就非常明显了
```java
public class SampleActivity extends Activity {</p>

<p>  private final Handler mLeakyHandler = new Handler() {</p>

<pre><code>@Override
public void handleMessage(Message msg) {
  // ...
}
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);

// Post a message and delay its execution for 10 minutes.
mLeakyHandler.postDelayed(new Runnable() {
  @Override
  public void run() { /* ... */ }
}, 1000 * 60 * 10);

// Go back to the previous Activity.
finish();
</code></pre>

<p>  }
}
```
分析一下上面的代码，当我们执行了Activity的finish方法，被延迟的消息会在被处理之前存在于主线程消息队列中10分钟，而这个消息中又包含了Handler的引用，而Handler是一个匿名内部类的实例，其持有外面的SampleActivity的引用，所以这导致了SampleActivity无法回收，进行导致SampleActivity持有的很多资源都无法回收，这就是我们常说的内存泄露。</p>

<p>注意上面的new Runnable这里也是匿名内部类实现的，同样也会持有SampleActivity的引用，也会阻止SampleActivity被回收。</p>

<p>要解决这种问题，思路就是不适用非静态内部类，继承Handler时，要么是放在单独的类文件中，要么就是使用静态内部类。因为静态的内部类不会持有外部类的引用，所以不会导致外部类实例的内存泄露。当你需要在静态内部类中调用外部的Activity时，我们可以使用<a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">弱引用</a>来处理。另外关于同样也需要将Runnable设置为静态的成员属性。注意：一个静态的匿名内部类实例不会持有外部类的引用。
修改后不会导致内存泄露的代码如下</p>

<p>```java
public class SampleActivity extends Activity {</p>

<p>  /<em>*
   * Instances of static inner classes do not hold an implicit
   * reference to their outer class.
   </em>/
  private static class MyHandler extends Handler {</p>

<pre><code>private final WeakReference&lt;SampleActivity&gt; mActivity;

public MyHandler(SampleActivity activity) {
  mActivity = new WeakReference&lt;SampleActivity&gt;(activity);
}

@Override
public void handleMessage(Message msg) {
  SampleActivity activity = mActivity.get();
  if (activity != null) {
    // ...
  }
}
</code></pre>

<p>  }</p>

<p>  private final MyHandler mHandler = new MyHandler(this);</p>

<p>  /<em>*
   * Instances of anonymous classes do not hold an implicit
   * reference to their outer class when they are &ldquo;static&rdquo;.
   </em>/
  private static final Runnable sRunnable = new Runnable() {</p>

<pre><code>  @Override
  public void run() { /* ... */ }
</code></pre>

<p>  };</p>

<p>  @Override
  protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);

// Post a message and delay its execution for 10 minutes.
mHandler.postDelayed(sRunnable, 1000 * 60 * 10);

// Go back to the previous Activity.
finish();
</code></pre>

<p>  }
}
```</p>

<p>其实在Android中很多的内存泄露都是由于在Activity中使用了非静态内部类导致的，就像本文提到的一样，所以当我们使用时要非静态内部类时要格外注意，如果其实例的持有对象的生命周期大于其外部类对象，那么就有可能导致内存泄露。个人倾向于使用文章的静态类和弱引用的方法解决这种问题。</p>

<h3>译文信息</h3>

<ul>
<li><a href="http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html">How to Leak a Context: Handlers &amp; Inner Classes</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[应用认领那些事]]></title>
    <link href="http://droidyue.com/blog/2014/12/14/android-yingyong-renling/"/>
    <updated>2014-12-14T19:35:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/12/14/android-yingyong-renling</id>
    <content type="html"><![CDATA[<p>最近公司的一款产品提交国内市场，发现有些国内市场提示需要进行应用认领。原因就是别人（或者市场抓取）已经在我们之前将这个应用提交到了该市场。认领成功后，这个应用就重回你的怀抱了，其实认领很简单，这里讲到的自然是对未签名的包进行签名。由于这样的操作细小琐屑，这样更需要记录一下，免得以后麻烦。</p>

<!--more-->


<h2>如何认领</h2>

<ul>
<li>一般的就是市场提供一个未签名的apk包，认领方进行签名后，上传即可认领成功。</li>
<li>另一种就是提供公司证明，这个我们不讲，也没什么可以讲。</li>
</ul>


<p>通常情况下认领都会有对一个未签名的apk包签名认证这种方式，因为签名是软件发布商所独有的，通过对比测试需认领的包的签名和刚签过名的apk包是否一致，如果一致就认领成功，否则失败。</p>

<h2>对未签名包签名</h2>

<p><code>bash
jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore your_keystore  -storepass your_storepass -keypass your_keypass -signedjar path_of_signed_apk  path_of_unsigned_apk your_alias
</code></p>

<h3>需要替换的值</h3>

<ul>
<li>your_key_store keystore文件路径</li>
<li>your_storepass   store密码</li>
<li>your_keypass    key密码</li>
<li>path_of_signed_apk 签名后apk保存的目录</li>
<li>path_of_unsigned_apk 待签名的apk包</li>
<li>your_alias keystore中的别名</li>
</ul>


<p>注意上面的签名算法sigalg 使用SHA1withRSA或者MD5withRSA都可以。</p>

<h2>验证签名</h2>

<p><code>bash
jarsigner -verify -certs -verbose your_app.apk
</code>
比如我们验证百度金融的apk，会得到类似这样的结果
```bash
19:23 $ jarsigner -verify -certs -verbose BaiduFinance.apk | more</p>

<p>s      61679 Fri Nov 14 19:50:16 CST 2014 META-INF/MANIFEST.MF</p>

<pre><code>  X.509, CN=Baidu, OU=Baidu Inc., O=Baidu Inc., L=Beijing, ST=Beijing, C=CN
  [certificate is valid from 12/6/13 10:19 AM to 11/24/63 10:19 AM]
  [CertPath not validated: Path does not chain with any of the trust anchors]

   61800 Fri Nov 14 19:50:16 CST 2014 META-INF/MCO_BAID.SF
     936 Fri Nov 14 19:50:16 CST 2014 META-INF/MCO_BAID.RSA
</code></pre>

<p>sm      2304 Fri Nov 14 19:49:32 CST 2014 assets/mean/data_mean_24_bank_card
```</p>

<h2>疑难问题</h2>

<h3>No -tsa or -tsacert is provided and this jar is not timestamped</h3>

<p>在签名时加入下面的选项
<code>bash
jarsigner -tsa http://timestamp.digicert.com
</code></p>

<h3>Windows无法打开文件</h3>

<p>有些Windows工具无法打开签名后的apk，如果你的签名没有错误，并且验证过，这种情况请忽略。</p>

<h3>签名认领失败</h3>

<p>如果签名认领失败的话，请检查目前线上的包是否进行了二次打包被别人篡改了签名，如果是的话，需要进行商务上的沟通来解决了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[仿腾讯新闻样式的Toast]]></title>
    <link href="http://droidyue.com/blog/2014/11/29/custom-toast-like-tencent-news-app/"/>
    <updated>2014-11-29T17:21:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/29/custom-toast-like-tencent-news-app</id>
    <content type="html"><![CDATA[<p>厌倦了网易新闻无处不在的喷子，尝试了一下腾讯新闻，果然顿时清净了很多，当然这不是重点。个人感觉腾讯新闻客户端的Toast比较不错，相对于系统默认的Toast，更加能起到提醒的作用。于是反编译了一下，简单分享一下,其实很简单。</p>

<!--more-->


<h2>先看效果</h2>

<p><img class="<a" src="href="http://droidyueimg.qiniudn.com/tencent_toast.png">http://droidyueimg.qiniudn.com/tencent_toast.png</a>">
背景为深灰色，支持设置图片和文字。</p>

<h2>布局文件</h2>

<p>```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;RelativeLayout</p>

<pre><code>android:id="@+id/view_tips_layout" 
android:background="@drawable/tips_bg" 
android:layout_width="wrap_content" 
android:layout_height="wrap_content"
xmlns:android="http://schemas.android.com/apk/res/android"&gt;
&lt;View 
    android:layout_width="160.0dip" 
    android:layout_height="160.0dip" 
    android:layout_centerInParent="true" /&gt;

&lt;LinearLayout 
    android:orientation="vertical" 
    android:layout_width="wrap_content" 
    android:layout_height="wrap_content" 
    android:layout_centerInParent="true"&gt;

    &lt;ImageView 
        android:gravity="center" 
        android:layout_gravity="center" 
        android:id="@+id/tips_icon" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_marginBottom="10.0dip" 
        android:src="@drawable/tips_error" 
        android:contentDescription="@null" /&gt;

    &lt;TextView 
        android:textSize="17.0sp" 
        android:textColor="#ffffffff" 
        android:gravity="center" 
        android:layout_gravity="center" 
        android:id="@+id/tips_msg" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:lineSpacingExtra="3.0dip" /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p></RelativeLayout>
```</p>

<h2>程序代码</h2>

<p><code>java
Toast toast = new Toast(getApplicationContext());
View toastView = LayoutInflater.from(getApplicationContext()).inflate(R.layout.view_tips, null);
((ImageView)toastView.findViewById(R.id.tips_icon)).setImageResource(R.drawable.ic_launcher);
((TextView)toastView.findViewById(R.id.tips_msg)).setText("Error Occurs");
toast.setView(toastView);
toast.setGravity(Gravity.NO_GRAVITY, 0, 0);
toast.show();
</code>
Toast默认的位置为底部水平居中。我们可以通过设置setGravity(int, int, int)来进行设置位置。该方法接受三个参数，一个Gravity常量，一个x（水平）方向上的偏移量，一个y（竖直）方向上的偏移量。</p>

<p>如果我们想让位置向右我们需要增加x方向上的偏移量，如果想让位置向下，增大y方向上的偏移量。</p>

<h2>多说</h2>

<p>我们可以根据自己的需求去设置图片，文字，背景色等样式来定制想要的Toast。</p>

<p>注意，涉及到长度宽度字体大小相关的建议放到dimens文件，便于我们进行设备适配。</p>

<h2>示例下载</h2>

<p><a href="http://pan.baidu.com/s/1kTLxagZ">百度网盘</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google为何这样设计OnSharedPreferenceChangeListener]]></title>
    <link href="http://droidyue.com/blog/2014/11/29/why-onsharedpreferencechangelistener-was-not-called/"/>
    <updated>2014-11-29T16:41:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/29/why-onsharedpreferencechangelistener-was-not-called</id>
    <content type="html"><![CDATA[<p>之前使用OnSharedPreferenceChangeListener，遇到了点小问题，就是有些时候OnSharedPreferenceChangeListener没有被触发。最近花了点时间研究了一下，小做整理。本文将会介绍监听器不被触发的原因，解决方法，以及其中隐含的一些技术细节。</p>

<!--more-->


<h2>问题再现</h2>

<p>OnSharedPreferenceChangeListener是Android中SharedPreference文件发生变化的监听器。通常我们想要进行监听，会实现如下的代码。
```java
protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>PreferenceManager.getDefaultSharedPreferences(getApplicationContext())
    .registerOnSharedPreferenceChangeListener(new OnSharedPreferenceChangeListener() {
    @Override
    public void onSharedPreferenceChanged(
        SharedPreferences sharedPreferences, String key) {
        Log.i(LOGTAG, "testOnSharedPreferenceChangedWrong key =" + key);
    }
});
</code></pre>

<p>}
```
这种写法看上去没有什么问题，而且很多时候开始几次onSharedPreferenceChanged方法也可以被调用。但是过一段时间（简单demo不容易出现，但是使用DDMS中的gc会立刻导致接下来的问题），你会发现前面的方法突然不再被调用，进而影响到程序的处理。</p>

<h2>原因剖析</h2>

<p>简而言之，就是你注册的监听器被移除掉了。<br/>
首先我们先了解一下registerOnSharedPreferenceChangeListener注册的实现。
```
private final WeakHashMap&lt;OnSharedPreferenceChangeListener, Object> mListeners =</p>

<pre><code>        new WeakHashMap&lt;OnSharedPreferenceChangeListener, Object&gt;();
</code></pre>

<p>//some code goes here
public void More &hellip;registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {</p>

<pre><code>synchronized(this) {
    mListeners.put(listener, mContent);
}
</code></pre>

<p>}
```
从上面的代码可以得知，一个OnSharedPreferenceChangeListener对象实际上是放到了一个WeakHashMap的容器中，执行完示例中的onCreate方法，这个监听器对象很快就会成为垃圾回收的目标，由于放在WeakHashMap中作为key不会阻止垃圾回收，所以当监听器对象被回收之后，这个监听器也会从mListeners中移除。所以就造成了onSharedPreferenceChanged不会被调用。</p>

<p>关于WeakHashMap相关，请阅读<a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">译文：理解Java中的弱引用</a>进而更多了解。</p>

<h2>如何解决</h2>

<h3>改为对象成员变量（推荐）</h3>

<p>将监听器作为Activity的一个成员变量，在Activity的onResume进行注册，在onPause时进行注销。推荐在这两个Activity生命周期中进行处理，尤其是当SharedPreference值发生变化后，对Activity展示的UI进行处理操作的情况。这种方法是最推荐的解决方案。
```java
private OnSharedPreferenceChangeListener mListener = new OnSharedPreferenceChangeListener() {</p>

<pre><code>@Override
public void onSharedPreferenceChanged(
    SharedPreferences sharedPreferences, String key) {
    Log.i(LOGTAG, "instance variable key=" + key);
}
</code></pre>

<p>};</p>

<p>@Override
protected void onResume() {</p>

<pre><code>PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).registerOnSharedPreferenceChangeListener(mListener);
super.onResume();
</code></pre>

<p>}</p>

<p>@Override
protected void onPause() {</p>

<pre><code>PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).unregisterOnSharedPreferenceChangeListener(mListener);
super.onPause();
</code></pre>

<p>}
```</p>

<h3>改为静态变量（不推荐）</h3>

<p>如下，将一个指向匿名的内部类对象的变量sListener使用static修饰，这个内部类对象则不会持有外部类的引用。<br/>
但是这种做法并不推荐，因为一个静态变量和与外部实例不相关，我们很难和外部实例进行一些操作。
```java
private static OnSharedPreferenceChangeListener sListener = new OnSharedPreferenceChangeListener() {</p>

<pre><code>@Override
public void onSharedPreferenceChanged(
    SharedPreferences sharedPreferences, String key) {
    Log.i(LOGTAG, "static variable key=" + key);
}
</code></pre>

<p>};
```</p>

<h2>为什么这样设计</h2>

<p>可能会有人认为这是系统设计的猫腻或者bug，其实不然，这正是Android设计人员的高明之处。</p>

<p>正如我们示例的代码一样，将一个（隐式的）局部变量添加到监听器容器中，如果该容器只是一个普通的HashMap，这样会导致内存泄露，因为该容器还有局部变量指向的对象，该对象又隐式持有外部Activity的对象，导致Activity无法被销毁。关于非静态内部类持有隐式持有外部类引用，请参考<a href="http://droidyue.com/blog/2014/10/02/the-private-modifier-in-java/">细话Java："失效"的private修饰符</a></p>

<p>除此之外，因为局部变量无法在其所在方法外部访问，这样就导致了我们只可以使用方法中使用局部变量就行注册，在合适的时机却无法使用局部变量进行注销。</p>

<h2>三本帮助深入研究Java的书</h2>

<ul>
<li><a href="http://www.amazon.cn/gp/product/0137142528/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=0137142528&amp;linkCode=as2&amp;tag=droidyue-23">Java Performance</a></li>
<li><a href="http://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011F7WU4&amp;linkCode=as2&amp;tag=droidyue-23">Java编程思想(第4版)</a></li>
<li><a href="http://www.amazon.cn/gp/product/B001PTGR52/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001PTGR52&amp;linkCode=as2&amp;tag=droidyue-23">Sun 公司核心技术丛书:Effective Java中文版(第2版)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中WebView拦截替换网络请求数据]]></title>
    <link href="http://droidyue.com/blog/2014/11/23/block-web-resource-in-webview/"/>
    <updated>2014-11-23T21:54:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/23/block-web-resource-in-webview</id>
    <content type="html"><![CDATA[<p>Android中处理网页时我们必然用到WebView,这里我们有这样一个需求，我们想让WebView在处理网络请求的时候将某些请求拦截替换成某些特殊的资源。具体一点儿说，在WebView加载 <code>http://m.sogou.com</code> 时，会加载一个logo图片，我们的需求就是将这个logo图片换成另一张图片。</p>

<!--more-->


<h3>shouldInterceptRequest</h3>

<p>好在Android中的WebView比较强大，从API 11(Android 3.0)开始， shouldInterceptRequest被引入就是为了解决这一类的问题。</p>

<p>shouldInterceptRequest这个回调可以通知主程序WebView处理的资源（css,js,image等）请求，并允许主程序进行处理后返回数据。如果主程序返回的数据为null，WebView会自行请求网络加载资源，否则使用主程序提供的数据。注意这个回调发生在非UI线程中,所以进行UI系统相关的操作是不可以的。</p>

<p>shouldInterceptRequest有两种重载。</p>

<ul>
<li><strong>public WebResourceResponse shouldInterceptRequest (WebView view, String url)</strong> 从API 11开始引入，API 21弃用</li>
<li><strong>public WebResourceResponse shouldInterceptRequest (WebView view, WebResourceRequest request)</strong> 从API 21开始引入</li>
</ul>


<p>本次例子暂时使用第一种，即shouldInterceptRequest (WebView view, String url)。</p>

<h3>示例代码</h3>

<p>```java
WebView webView = new WebView(this);
webView.setWebViewClient(new WebViewClient() {</p>

<pre><code>@Override
public WebResourceResponse shouldInterceptRequest(WebView view, String url) {
    Log.i(LOGTAG, "shouldInterceptRequest url=" + url + ";threadInfo" + Thread.currentThread());
    WebResourceResponse response = null;
    if (url.contains("logo")) {
        try {
            InputStream localCopy = getAssets().open("droidyue.png");
            response = new WebResourceResponse("image/png", "UTF-8", localCopy);
        } catch (IOException e) {
            e.printStackTrace();
        }       
    }
    return response;
}   
</code></pre>

<p>});
setContentView(webView);
webView.loadUrl(&ldquo;<a href="http://m.sogou.com">http://m.sogou.com</a>&rdquo;);
```
其中WebResourceResponse需要设定三个属性，MIME类型，数据编码，数据(InputStream流形式)。</p>

<h3>示例下载</h3>

<ul>
<li><a href="http://pan.baidu.com/s/1ntOaHoH">百度云盘</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
