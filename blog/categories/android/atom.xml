<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2015-09-07T20:53:16+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[剖析Android中进程与线程调度之nice]]></title>
    <link href="http://droidyue.com/blog/2015/09/05/android-process-and-thread-schedule-nice/"/>
    <updated>2015-09-05T11:35:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/09/05/android-process-and-thread-schedule-nice</id>
    <content type="html"><![CDATA[<p>在计算机操作系统中，进程是进行资源分配和调度的基本单位，同时每个进程之内也可以存在多个线程。那么在Android系统（Linux Kernel）中，进程是如何去抢占资源，线程又是如何根据优先级切换呢，本文将尝试剖析这个问题，研究nice在Linux以及Android系统中的应用。</p>

<!--more-->


<h2>一些概念</h2>

<ul>
<li>进程 是计算机系统中，程序运行的实体，也是线程的容器。</li>
<li>线程 是进程中实际执行单位，一个线程是程序执行流的最小单元。在一个进程中可以有多个线程存在。</li>
</ul>


<h2>nice与进程调度</h2>

<p>Linux中，使用nice value（以下成为nice值）来设定一个进程的优先级，系统任务调度器根据nice值合理安排调度。</p>

<ul>
<li>nice的取值范围为-20到19。</li>
<li>通常情况下，nice的默认值为0。视具体操作系统而定。</li>
<li>nice的值越大，进程的优先级就越低，获得CPU调用的机会越少，nice值越小，进程的优先级则越高，获得CPU调用的机会越多。</li>
<li>一个nice值为-20的进程优先级最高，nice值为19的进程优先级最低。</li>
<li>父进程fork出来的子进程nice值与父进程相同。父进程renice，子进程nice值不会随之改变。</li>
</ul>


<h3>词源考究</h3>

<p>nice这个命令的来源几乎没有资料提到，于是便尝试自己来推断一下。在诸如词霸，沪江等词典给出的意思均为<code>好的；美好的；可爱的；好心的，友好的</code>。而有道词典则稍微给出了一个其他词典没有的<code>和蔼的</code>。个人认为有道给出的这个比较合理。要想做到和蔼，就需要做到谦让，因此或多或少牺牲自己一点，成全他人。所以nice值越高，越和蔼，但是自己的优先级也会越低。</p>

<h3>renice</h3>

<p>对于一个新的进程我们可以按照下面的代码为一个进程设定nice值。
<code>bash
nice -n 10 adb logcat
</code>
对于已经创建的进程，我们可以使用renice来修改nice值
<code>
sudo renice -n 0 -p 24161
</code>
该命令需要使用root权限，-p对应的值为进程id。</p>

<p>注意renice命令在Linux发行版中-n 的值应该为进程的目标优先级。而Mac下-n，则是代表对当前权限的增加值。
比如在Mac下，讲一个进程的nice值由19改成10，可以这样操作<code>sudo renice -n -9  -p 24161</code>,这一点需要注意，避免掉进坑里。</p>

<h3>Android中的nice</h3>

<p>由于Android基于Linux Kernel，在Android中也存在nice值。但是一般情况下我们无法控制，原因如下：</p>

<ul>
<li>Android系统并不像其他Linux发行版那样便捷地使用nice命令操作。</li>
<li>renice需要root权限，一般应用无法实现。</li>
</ul>


<h2>线程调度</h2>

<p>虽然对于进程的优先级，我们无法控制，但是我们可以控制进程中的线程的优先级。在Android中有两种线程的优先级，一种为Android API版本，另一种是 Java 原生版本。</p>

<h3>Android API</h3>

<p>Android中的线程优先级别目前规定了如下，了解了进程优先级与nice值的关系，那么线程优先级与值之间的关系也就更加容易理解。</p>

<ul>
<li>THREAD_PRIORITY_DEFAULT，默认的线程优先级，值为0。</li>
<li>THREAD_PRIORITY_LOWEST，最低的线程级别，值为19。</li>
<li>THREAD_PRIORITY_BACKGROUND 后台线程建议设置这个优先级，值为10。</li>
<li>THREAD_PRIORITY_FOREGROUND 用户正在交互的UI线程，代码中无法设置该优先级，系统会按照情况调整到该优先级，值为-2。</li>
<li>THREAD_PRIORITY_DISPLAY 也是与UI交互相关的优先级界别，但是要比THREAD_PRIORITY_FOREGROUND优先，代码中无法设置，由系统按照情况调整，值为-4。</li>
<li>THREAD_PRIORITY_URGENT_DISPLAY 显示线程的最高级别，用来处理绘制画面和检索输入事件，代码中无法设置成该优先级。值为-8。</li>
<li>THREAD_PRIORITY_AUDIO 声音线程的标准级别，代码中无法设置为该优先级，值为 -16。</li>
<li>THREAD_PRIORITY_URGENT_AUDIO 声音线程的最高级别，优先程度较THREAD_PRIORITY_AUDIO要高。代码中无法设置为该优先级。值为-19。</li>
<li>THREAD_PRIORITY_MORE_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微优先，值为-1。</li>
<li>THREAD_PRIORITY_LESS_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微落后一些，值为1。</li>
</ul>


<p>使用Android API为线程设置优先级也很简单，只需要在线程执行时调用android.os.Process.setThreadPriority方法即可。这种在线程运行时进行修改优先级，效果类似renice。
```
new Thread () {</p>

<pre><code>@Override
public void run() {
    super.run();
    android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
</code></pre>

<p>}.start();
```</p>

<h3>Java原生API</h3>

<p>Java为Thread提供了三个级别的设置，</p>

<ul>
<li>MAX_PRIORITY，相当于android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY，值为10。</li>
<li>MIN_PRIORITY，相当于android.os.Process.THREAD_PRIORITY_LOWEST，值为0。</li>
<li>NORM_PRIORITY，相当于android.os.Process.THREAD_PRIORITY_DEFAULT，值为5。</li>
</ul>


<p>使用setPriority我们可以为某个线程设置优先级，使用getPriority可以获得某个线程的优先级。</p>

<p>在Android系统中，不建议使用Java原生的API，因为Android提供的API划分的级别更多，更适合在Android系统中进行设定细致的优先级。</p>

<h2>注意</h2>

<p>Android API的线程优先级和Java原生API的优先级是相对独立的，比如使用android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)后，使用Java原生API,Thread.getPriority()得到的值不会改变。如下面代码：
```
new Thread() {</p>

<pre><code>@Override
public void run() {
    super.run();
    Log.i(LOGTAG, "Java Thread Priority Before=" + Thread.currentThread().getPriority());
    Process.setThreadPriority(Process.THREAD_PRIORITY_LOWEST);
    Log.i(LOGTAG, "Java Thread Priority=" + Thread.currentThread().getPriority());
}
</code></pre>

<p>}.start();
<code>
上述代码的运行日志为
</code>
I/MainActivity( 3679): Java Thread Priority Before=5
I/MainActivity( 3679): Java Thread Priority=5
```</p>

<p>由于上面的这一点缺陷，导致我们在分析ANR trace时需要注意，在下面的ANR日志信息中，<code>prio=5</code>中proi的值对应的Java原生API的线程优先级。而<code>nice=-6</code>中的nice表示的Android API版本的线程优先级。</p>

<p><code>
"main" prio=5 tid=1 NATIVE
  | group="main" sCount=1 dsCount=0 obj=0x41690f18 self=0x4167e650
  | sysTid=1765 nice=-6 sched=0/0 cgrp=apps handle=1074196888
  | state=S schedstat=( 0 0 0 ) utm=5764 stm=3654 core=2
  #00  pc 00022624  /system/lib/libc.so (__futex_syscall3+8)
  #01  pc 0000f054  /system/lib/libc.so (__pthread_cond_timedwait_relative+48)
  #02  pc 0000f0b4  /system/lib/libc.so (__pthread_cond_timedwait+64)
</code></p>

<h2>避免ANR</h2>

<p>我在之前的文章<a href="http://droidyue.com/blog/2015/07/18/anr-in-android/">说说Android中的ANR</a>中提到使用WorkerThread处理耗时IO操作，同时将WorkerThread的优先级降低，对于耗时IO操作，比如读取数据库，文件等，我们可以设置该workerThread优先级为THREAD_PRIORITY_BACKGROUND，以此降低与主线程竞争的能力。</p>

<p>{%include post/book_copyright.html %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入讲解Android中Activity launchMode]]></title>
    <link href="http://droidyue.com/blog/2015/08/16/dive-into-android-activity-launchmode/"/>
    <updated>2015-08-16T21:22:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/08/16/dive-into-android-activity-launchmode</id>
    <content type="html"><![CDATA[<p>Android系统中的Activity可以说一件很赞的设计，它在内存管理上良好的设计，使得多任务管理在Android系统中运行游刃有余。但是Activity绝非启动展示在屏幕而已，其启动方式也大有学问，本文讲具体介绍Activity的启动模式的诸多细节，纠正一些开发中可能错误的观点，帮助大家深入理解Activity。</p>

<!--more-->


<h2>行文之前</h2>

<p>在正式行文之前，先介绍一些文章提到的概念</p>

<ul>
<li>文章后续会提到Task，这里的Task指的是与用户交互的Activity实例的集合。</li>
<li>Task中的Activity实例以栈的形式存放，这个栈就是Activity的回退栈。</li>
</ul>


<p><strong>本文图片较多，在看图时，请注意观察Activity顶部的title，来区分具体Activity。</strong></p>

<h2>为何有启动模式</h2>

<p>应用中的每一个Activity都是进行不同的事物处理。以邮件客户端为例，InboxActivity目的就是为了展示收件箱，这个Activity不建议创建成多个实例。而ComposeMailActivity则是用来撰写邮件，可以实例化多个此Activity对象。合理地设计Activity对象是否使用已有的实例还是多次创建，会使得交互设计更加良好，也能避免很多问题。至于想要达到前面的目标，就需要使用今天的Activity启动模式。</p>

<h2>如何使用</h2>

<p>使用很简单，只需要在manifest中对应的Activity元素加入<strong>android:launchMode</strong>属性即可。如下述代码
```xml
&lt;activity</p>

<pre><code>android:name=".SingleTaskActivity"
android:label="singleTask launchMode"
android:launchMode="singleTask"&gt;
</code></pre>

<p></activity>
```</p>

<p>接下来就是介绍launchMode的四个值的时刻了。</p>

<h2>standard</h2>

<p>这是launchMode的默认值，Activity不包含android:launchMode或者显示设置为standard的Activity就会使用这种模式。</p>

<p>一旦设置成这个值，<strong>每当有一次Intent请求，就会创建一个新的Activity实例</strong>。举个例子，如果有10个撰写邮件的Intent，那么就会创建10个ComposeMailActivity的实例来处理这些Intent。结果很明显，这种模式会创建某个Activity的多个实例。</p>

<h3>Android 5.0之前的表现</h3>

<p>这种Activity新生成的实例会放入发送Intent的Task的栈的顶部。下图为启动同一程序内的Activity。
{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/pre_lollipop_standard_activity_in_same_app.jpg">http://7jpolu.com1.z0.glb.clouddn.com/pre_lollipop_standard_activity_in_same_app.jpg</a> pre_lollipop_standard_activity_in_same_app %}</p>

<p>下面的图片展示跨程序之间调用，新生成的Activity实例会放入发送Intent的Task的栈的顶部，尽管它们属于不同的程序。
{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/pre_lollipop_standard_activity_across_app.jpg">http://7jpolu.com1.z0.glb.clouddn.com/pre_lollipop_standard_activity_across_app.jpg</a>  pre_lollipop_standard_activity_across_app %}</p>

<p>但是当我们打开任务管理器，则会有一点奇怪，应为显示的任务是Gallery，展示的界面确实另一个程序的Activity（因为其位于Task的栈顶）。</p>

<p>{%img  <a href="http://7jpolu.com1.z0.glb.clouddn.com/pre_lollipop_task_manager_across_app.jpg">http://7jpolu.com1.z0.glb.clouddn.com/pre_lollipop_task_manager_across_app.jpg</a> %}</p>

<p>这时候如果我们从Gallery应用切换到拨号应用，再返回到Gallery，看到的还是这个非Gallery的Activity，如果我们想要对Gallery进行操作，必须按Back键返回到Gallery界面才可以。确实有点不太合理。</p>

<h3>Android 5.0及之后表现</h3>

<p>对于同一应用内部Activity启动和5.0之前表现一样，变化的就是不同应用之间Activity启动变得合理了。</p>

<p>跨应用之间启动Activity，会创建一个新的Task，新生成的Activity就会放入刚创建的Task中。如下图</p>

<p>{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/lollipop_across_app_new_task.jpg">http://7jpolu.com1.z0.glb.clouddn.com/lollipop_across_app_new_task.jpg</a> %}</p>

<p>同时任务管理器查看任务也显得更加合理了。</p>

<p>{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/lollipop_task_manager_standard.jpg">http://7jpolu.com1.z0.glb.clouddn.com/lollipop_task_manager_standard.jpg</a> %}</p>

<p>假设之前存在我们的测试程序，然后从Gallery又分享文件到我们的测试程序，则对应的任务管理器展示效果如下。</p>

<p>{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/lollipop_standard_across_app_alread_exists.jpg">http://7jpolu.com1.z0.glb.clouddn.com/lollipop_standard_across_app_alread_exists.jpg</a> %}</p>

<p>使用场景：standard这种启动模式适合于撰写邮件Activity或者社交网络消息发布Activity。如果你想为每一个intent创建一个Activity处理，那么就是用standard这种模式。</p>

<h2>singleTop</h2>

<p>singleTop其实和standard几乎一样，使用singleTop的Activity也可以创建很多个实例。唯一不同的就是，<strong>如果调用的目标Activity已经位于调用者的Task的栈顶，则不创建新实例，而是使用当前的这个Activity实例，并调用这个实例的onNewIntent方法</strong>。
{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/singletop.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singletop.jpg</a> %}
在singleTop这种模式下，我们需要处理应用这个模式的Activity的onCreate和onNewIntent两个方法，确保逻辑正常。</p>

<h3>使用场景</h3>

<p>关于singleTop一个典型的使用场景就是搜索功能。假设有一个搜索框，每次搜索查询都会将我们引导至SearchActivity查看结果，为了更好的交互体验，我们在结果页顶部也放置这样的搜索框。</p>

<p>假设一下，SearchActivity启动模式为standard，那么每一个搜索都会创建一个新的SearchActivity实例，10次查询就是10个Activity。当我们想要退回到非SearchActivity，我们需要按返回键10次，这显然太不合理了。</p>

<p>但是如果我们使用singleTop的话，如果SearchActivity在栈顶，当有了新的查询时，不再重新创建SearchAc实例，而是使用当前的SearchActivity来更新结果。当我们需要返回到非SearchActivity只需要按一次返回键即可。使用了singleTop显然比之前要合理。</p>

<h3>总结</h3>

<ul>
<li>只有在调用者和目标Activity在同一Task中，并且目标Activity位于栈顶，才使用现有目标Activity实例，否则创建新的目标Activity实例。</li>
<li>如果是外部程序启动singleTop的Activity，在Android 5.0之前新创建的Activity会位于调用者的Task中，5.0及以后会放入新的Task中。</li>
</ul>


<h2>singleTask</h2>

<p>singleTask这个模式和前面提到的standard和singleTop截然不同。<strong>使用singleTask启动模式的Activity在系统中只会存在一个实例</strong>。如果这个实例已经存在，intent就会通过onNewIntent传递到这个Activity。否则新的Activity实例被创建。</p>

<h3>同一程序内</h3>

<p>如果系统中不存在singleTask Activity的实例，那么就需要创建这个Activity的实例，并且将这个实例放入和调用者相同的Task中并位于栈顶。</p>

<p>{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/singletask_inapp_create_new_instance.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singletask_inapp_create_new_instance.jpg</a> %}</p>

<p>如果singleTask Activity实例已然存在，那么在Activity回退栈中，所有位于该Activity上面的Activity实例都将被销毁掉（销毁过程会调用Activity生命周期回调），这样使得singleTask Activity实例位于栈顶。与此同时，Intent会通过onNewIntent传递到这个SingleTask Activity实例。</p>

<p>{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/singletask_sameapp_instance_exists.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singletask_sameapp_instance_exists.jpg</a> %}</p>

<p>然而在Google关于singleTask的<a href="http://developer.android.com/guide/components/tasks-and-back-stack.html">文档</a>有这样一段描述</p>

<blockquote><p>The system creates a new task and instantiates the activity at the root of the new task.</p></blockquote>

<p>意思为 系统会创建一个新的Task，并创建Activity实例放入这个新的Task的底部。</p>

<p>然而实际并非如此，在我的例子中，singleTask Activity并创建并放入了调用者所在的Task，而不是放入新的Task，使用<code>adb shell dumpsys activity</code>便可以进行验证。
```java
Task id #239
  TaskRecord{428efe30 #239 A=com.thecheesefactory.lab.launchmode U=0 sz=2}
  Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=com.thecheesefactory.lab.launchmode/.StandardActivity }</p>

<pre><code>Hist #1: ActivityRecord{429a88d0 u0 com.thecheesefactory.lab.launchmode/.SingleTaskActivity t239}
  Intent { cmp=com.thecheesefactory.lab.launchmode/.SingleTaskActivity }
  ProcessRecord{42243130 18965:com.thecheesefactory.lab.launchmode/u0a123}
Hist #0: ActivityRecord{425fec98 u0 com.thecheesefactory.lab.launchmode/.StandardActivity t239}
  Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=com.thecheesefactory.lab.launchmode/.StandardActivity }
  ProcessRecord{42243130 18965:com.thecheesefactory.lab.launchmode/u0a123}
</code></pre>

<p><code>
然而想要实现文档的描述也并非不可能，我们需要在设置launchMode为singleTask的同时，再加上taskAffinity属性即可。
</code>xml
&lt;activity</p>

<pre><code>android:name=".SingleTaskActivity"
android:label="singleTask launchMode"
android:launchMode="singleTask"
android:taskAffinity=""&gt;
</code></pre>

<p></activity>
```
完成上面的修改，我们看一下效果，Task的变化如下图</p>

<p>{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/singleTaskTaskAffinity.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singleTaskTaskAffinity.jpg</a> %}
同时，系统中的任务管理器效果也会相应变化</p>

<p>{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/singletask_task_affinity_task_manger.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singletask_task_affinity_task_manger.jpg</a> %}</p>

<h3>跨应用之间</h3>

<p>在跨应用Intent传递时，如果系统中不存在singleTask Activity的实例，那么讲创建一个新的Task，然后创建SingleTask Activity的实例，将其放入新的Task中。Task变化如下。</p>

<p>{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/singletask_across_app_no_instance.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singletask_across_app_no_instance.jpg</a> %}
系统的任务管理器也会如下变化</p>

<p>{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/singletask_acrossapp_no_instance_taskmanager.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singletask_acrossapp_no_instance_taskmanager.jpg</a> %}</p>

<p>如果singleTask Activity所在的应用进程存在，但是singleTask Activity实例不存在，那么从别的应用启动这个Activity，新的Activity实例会被创建，并放入到所属进程所在的Task中，并位于栈顶位置。</p>

<p>{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/singletask_acrossapp_application_exists_activity_nonexists.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singletask_acrossapp_application_exists_activity_nonexists.jpg</a> %}</p>

<p>更复杂的一种情况，如果singleTask Activity实例存在，从其他程序被启动，那么这个Activity所在的Task会被移到顶部，并且在这个Task中，位于singleTask Activity实例之上的所有Activity将会被正常销毁掉。如果我们按返回键，那么我们首先会回退到这个Task中的其他Activity，直到当前Task的Activity回退栈为空时，才会返回到调用者的Task。</p>

<p>{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/singletask_acrossapp_instance_exists_and_back.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singletask_acrossapp_instance_exists_and_back.jpg</a> %}</p>

<p>在上图中，当Task2中的相册启动分享调用Task1中的singleTask Activity，而该Activity实例存在，并位于Task1中回退栈中的第三个位置（从上到下顺序），那么位于该Activity上面的两个Activity实例将会被销毁掉，使得该Activity实例位于栈顶。此时Task1中的回退栈只剩两个Activity，如果点击返回，那么会退到的不是相册应用，而是singleTask Activity栈位置下面的Activity，再次点击返回方可返回相册应用。</p>

<h3>使用场景</h3>

<p>该模式的使用场景多类似于邮件客户端的收件箱或者社交应用的时间线Activity。上述两种场景需要对应的Activity只保持一个实例即可，但是也要谨慎使用这种模式，因为它可以在用户未感知的情况下销毁掉其他Activity。</p>

<h2>singleInstance</h2>

<p>这个模式和singleTask差不多，因为他们在系统中都只有一份实例。唯一不同的就是存放singleInstance Activity实例的Task只能存放一个该模式的Activity实例。如果从singleInstance Activity实例启动另一个Activity，那么这个Activity实例会放入其他的Task中。同理，如果singleInstance Activity被别的Activity启动，它也会放入不同于调用者的Task中。</p>

<p>{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/singleInstance_new_instance.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singleInstance_new_instance.jpg</a> %}
虽然是两个task，但是在系统的任务管理器中，却始终显示一个，即位于顶部的Task中。</p>

<p>{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/singleInstances_taskmanager.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singleInstances_taskmanager.jpg</a> %}</p>

<p>另外当我们从任务管理器进入这个应用，是无法通过返回键会退到Task1的。</p>

<p>好在有办法解决这个问题，就是之前提到的<code>taskAffinity=""</code>，为launchMode为singleInstance的Activity加入这个属性即可。
```xml
&lt;activity</p>

<pre><code>android:name=".SingleInstanceActivity"
android:label="singleInstance launchMode"
android:launchMode="singleInstance"
android:taskAffinity=""&gt;
</code></pre>

<p></activity>
```
再次运行修改的代码，查看任务管理器，这样的结果就合理了。</p>

<p>{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/singleinstance_task_affinity.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singleinstance_task_affinity.jpg</a> %}</p>

<h3>使用情况</h3>

<p>这种模式的使用情况比较罕见，在Launcher中可能使用。或者你确定你需要使Activity只有一个实例。建议谨慎使用。</p>

<h2>Intent Flags</h2>

<p>除了在manifest文件中设置launchMode之外，还可以在Intnet中设置flag达到同样的效果。如下述代码就可以让StandardActivity已singleTop模式启动。
<code>java
Intent intent = new Intent(StandardActivity.this, StandardActivity.class);
intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
startActivity(intent);
</code></p>

<p>关于Intent Flags这里暂不做重点介绍，具体可以参考<a href="http://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_BROUGHT_TO_FRONT">官方文档</a></p>

<h2>原文信息</h2>

<ul>
<li><a href="http://inthecheesefactory.com/blog/understand-android-activity-launchmode/en">Understand Android Activity&rsquo;s launchMode: standard, singleTop, singleTask and singleInstance</a></li>
</ul>


<h2>One More Thing</h2>

<p>为了更深刻理解，建议多读几次。如果文章有问题，请在下方评论指出。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[探究android:largeHeap]]></title>
    <link href="http://droidyue.com/blog/2015/08/01/dive-into-android-large-heap/"/>
    <updated>2015-08-01T17:10:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/08/01/dive-into-android-large-heap</id>
    <content type="html"><![CDATA[<p>在日常的Android开发中，我们必然遇到过OutOfMemoryError这样的崩溃，产生的原因无外乎两点，一是内存过小不够用，二是程序设计有误，导致不能释放内存，其中后者情况较多。在解决这个问题时，我们亦或多或少听到android:largeHeap，然而这个概念又是什么呢，它该如何使用，存在哪些问题呢。本文讲比较全面介绍Android中的largeHeap帮助各位全面深入了解这个概念。</p>

<!--more-->


<h2>磨刀不误砍柴工</h2>

<p>为了便于理解，先简单介绍一些和文章相关的基础概念。</p>

<ul>
<li>通常，一个Android程序在运行时会启动一个Dalvik虚拟机（暂不讨论ART模式）</li>
<li>虚拟机的运行时内存一般由堆和栈两大部分构成。</li>
<li>栈是存储方法调用的一片内存数据区。</li>
<li>堆内存占据了虚拟机的大部分内存空间，程序执行时产生的对象就分配在堆内存上。</li>
<li>如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。</li>
</ul>


<p>如若具体了解堆和栈，请参考文章<a href="http://droidyue.com/blog/2014/12/07/differences-between-stack-and-heap-in-java/">Java中的堆和栈的区别</a>和<a href="http://droidyue.com/blog/2014/12/21/java-runtime-data-areas/">JVM运行时的数据区</a></p>

<h2>largeHeap介绍</h2>

<p>一个应用如果使用了largeHeap，会请求系统为Dalvik虚拟机分配更大的内存空间。使用起来也很方便，只需在manifest文件application节点加入<strong>android:largeHeap=&ldquo;true&rdquo;</strong>即可。
```xml
&lt;application android:icon=&ldquo;@drawable/icon&rdquo;</p>

<pre><code>android:allowBackup="false"
android:label="@string/app_name" 
android:debuggable="true" 
android:theme="@android:style/Theme.Black"
android:largeHeap="true"
</code></pre>

<blockquote><p>```</p></blockquote>

<h2>largeHeap有多大</h2>

<p>在Android中，有如下两个方法可以帮助我们查看当前内存大小</p>

<ul>
<li>ActivityManager.getMemoryClass()获得内用正常情况下内存的大小</li>
<li>ActivityManager.getLargeMemoryClass()可以获得开启largeHeap最大的内存大小</li>
</ul>


<p>然而largeHeap这个最大值是如何决定的呢？想要了解这个问题，我们就需要看一下Android系统中的一个文件。</p>

<p>这个文件路径是<code>/system/build.prop</code>，由于文件比较大，这里我们只截取关于dalvik内存的配置信息，如下。
<code>java
dalvik.vm.heapstartsize=8m
dalvik.vm.heapgrowthlimit=192m
dalvik.vm.heapsize=512m
dalvik.vm.heaptargetutilization=0.75
dalvik.vm.heapminfree=2m
dalvik.vm.heapmaxfree=8m
</code></p>

<p>上面有诸多配置，但从字面意思也不难理解，为了正确理解，有必要逐一解释一下。</p>

<p><strong>dalvik.vm.heapstartsize=8m</strong></p>

<p>相当于虚拟机的 -Xms配置，该项用来设置堆内存的初始大小。</p>

<p><strong>dalvik.vm.heapgrowthlimit=192m</strong></p>

<p>相当于虚拟机的 -XX:HeapGrowthLimit配置，该项用来设置一个标准的应用的最大堆内存大小。一个标准的应用就是没有使用android:largeHeap的应用。</p>

<p><strong>dalvik.vm.heapsize=512m</strong></p>

<p>相当于虚拟机的 -Xmx配置，该项设置了使用android:largeHeap的应用的最大堆内存大小。</p>

<p><strong>dalvik.vm.heaptargetutilization=0.75</strong></p>

<p>相当于虚拟机的 -XX:HeapTargetUtilization,该项用来设置当前理想的堆内存利用率。其取值位于0与1之间。当GC进行完垃圾回收之后，Dalvik的堆内存会进行相应的调整，通常结果是当前存活的对象的大小与堆内存大小做除法，得到的值为这个选项的设置，即这里的0.75。注意，这只是一个参考值，<a href="http://grepcode.com/file/repo1.maven.org/maven2/org.robovm/robovm-rt/1.0.0/dalvik/system/VMRuntime.java#VMRuntime.setTargetHeapUtilization%28float%29">Dalvik虚拟机也可以忽略此设置</a>。</p>

<p><strong>dalvik.vm.heapminfree=2m</strong>与<strong>dalvik.vm.heapmaxfree=8m</strong></p>

<p>dalvik.vm.heapminfree对应的是-XX:HeapMinFree配置，用来设置单次堆内存调整的最小值。<strong>dalvik.vm.heapmaxfree</strong>对应的是-XX:HeapMaxFree配置，用来设置单次堆内存调整的最大值。通常情况下，还需要结合上面的 -XX:HeapTargetUtilization的值，才能确定内存调整时，需要调整的大小。</p>

<h2>largeHeap需要权限么</h2>

<p>为何有此疑问呢？ 原因是这样的。 首先一个设备的内存是固定的，当我们使用了largeHeap之后就可以使我们的程序内存增加，但这部分增加的内存有可能是源自被系统杀掉的后台程序。所以，使用largeHeap理论上是有可能杀掉其他的程序的。</p>

<p>然而，结果就是不需要权限，Google在一开始就是这样，只需要简单在Application元素上加入android:largeHeap=&ldquo;true"就能正常使用。</p>

<h2>largeHeap对GC的影响</h2>

<p>拥有了更多的内存，是不是就意味着要花更多的时间遍历对象垃圾回收呢？其实不然。</p>

<p>首先largeHeap自Android 4.0开始支持，而并发的垃圾回收方式从Android 2.3开始引入。</p>

<p>在引入并发垃圾回收之前，系统采用了Stop-the-World回收方式，进行一次垃圾回收通常消耗几百毫秒，这是很影响交互和响应的。</p>

<p>引入并发垃圾回收之后,在GC开始和结束的阶段会有短暂的暂停时间，通常在10毫秒以内。</p>

<p>因此在支持largeHeap的系统上都采用了并发垃圾回收，GC的Pause Time不会很长，对交互响应影响甚微。</p>

<h2>慎用largeHeap</h2>

<p>对于largeHeap的使用，我们该持有的谨慎的态度，largeHeap可以使用，但是要谨慎。</p>

<p>对于本身对内存要求过大的图片或者视频应用，我们可以使用largeHeap。</p>

<p>除上面的情况，如果仅仅是为了解决OutOfMemoryError这样的问题，而尝试使用largeHeap分配更大内存的这种指标不治本的方法不可取。对待这样的OOM问题，建议阅读以下几篇文章，了解Android中内存泄露和垃圾回收，从代码上去查找问题，从根本上解决问题。</p>

<h2>推荐文章</h2>

<ul>
<li><a href="http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur/">Android中Handler引起的内存泄露</a></li>
<li><a href="http://droidyue.com/blog/2015/04/12/avoid-memory-leaks-on-context-in-android/">避免Android中Context引起的内存泄露</a></li>
<li><a href="http://droidyue.com/blog/2014/11/02/note-for-google-io-memory-management-for-android-chinese-edition/">Google IO：Android内存管理主题演讲记录</a></li>
</ul>


<p>{%include post/book_copyright.html %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Android lint发现并解决高版本API问题]]></title>
    <link href="http://droidyue.com/blog/2015/07/25/use-android-lint-to-find-higher-api-usage/"/>
    <updated>2015-07-25T16:51:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/07/25/use-android-lint-to-find-higher-api-usage</id>
    <content type="html"><![CDATA[<p>在编写代码时，为了实现一些功能，我们需要使用高版本的API，比如SharedPreference的Editor中的apply方法为API 9开始引入，在API 9 以上的机器使用没有问题，但是在API 8上，如果运行时执行了这段代码，就会崩溃，问题相当严重。尤其是该问题出现在正式版中，后果不堪设想。本文将介绍如何使用lint发现并解决这些问题。</p>

<!--more-->


<h2>lint是什么</h2>

<p>lint是Android提供的一个静态代码分析的工具，使用这个工具可以帮助我们找出Android项目中潜在的bug，安全，性能，可用性，辅助性和国际化等问题，同时还可以查找出错误拼写，提示开发者更正。</p>

<h3>lint的工作流程</h3>

<p>{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/lint_workflow.png">http://7jpolu.com1.z0.glb.clouddn.com/lint_workflow.png</a> %}</p>

<p>上图为lint的工作流程图，下面为一些元素的简短说明。</p>

<p><strong>程序源文件</strong></p>

<p>程序源文件就是Android工程的组成部分，包括Java和xml文件，图标以及混淆配置文件</p>

<p><strong>lint.xml文件</strong></p>

<p>lint配置文件，用来排除某些检查或者自定义检测问题的严重程度。</p>

<p><strong>lint工具</strong></p>

<p>一个静态代码扫描工具，对Android工程进行扫描分析，可以从终端执行命令，也可以从Android Studio等IDE中使用。lint工具可以帮助我们找到Android应用性能和代码质量问题。在正式发布应用之前，强烈建议使用lint检查并修复发现的问题。</p>

<p><strong>lint检查结果</strong></p>

<p>lint的检查结果可以从终端，Android Studio等IDE工具，或者生成结果文件查看。每一个问题都会标明在文件中的位置行数，以及关于该问题的说明等信息。</p>

<h2>查找问题</h2>

<p>知道了lint如何工作，就只需执行lint查找问题，有了明确的问题，才能有的放矢地解决。</p>

<h3>Android Sutdio</h3>

<p>选择菜单Analyze&mdash;>Configure Current File Analysis&mdash;>Configure Inspections 清空所有的检查项，然后如下图勾选<strong>Calling new methods on older versions</strong> 和 <strong>Using inlined constants on older versions</strong></p>

<p>{%img  <a href="http://7jpolu.com1.z0.glb.clouddn.com/android_studio_lint_custom.png">http://7jpolu.com1.z0.glb.clouddn.com/android_studio_lint_custom.png</a> %}</p>

<p>然后执行Analyze&mdash;> Inspect Code，然后查看底部的Inspection即可</p>

<h3>command line</h3>

<p><code>bash lineos:false
cd project_root_dir
lint --check NewApi,InlinedApi --html /tmp/api_check.html ./
</code>
无需多时，结果就会以html形式写入/tmp/api_check.html文件</p>

<h3>Gradle Command Line</h3>

<p>配置build.gradle
```java lineos:false
android{</p>

<pre><code>//some other config
lintOptions {
    abortOnError false
    xmlReport false
    check 'NewApi', 'InlinedApi'
}
</code></pre>

<p>}
<code>
然后执行下面的命令
</code>bash lineos:false
cd project_root_dir
./gradlew lint
```
结果会输出到工程目录build/outputs/lint-results.html。</p>

<h2>如何解决</h2>

<p>结合上面的输出结果，我们接下来要做的就是如何解决，如下为一些解决思路。</p>

<h3>必然执行高版本API</h3>

<ul>
<li>如果是NewApi警告，考虑其他方法代替。比如String.isEmpty自API 9才引入，但是使用TextUtils.isEmpty替换。</li>
<li>如果是InlinedApi警告，可以自定义与常量同值的另一个常量。</li>
<li>使用反射，对于不太重要的方法，我们可以使用反射来解决问题。</li>
</ul>


<h3>或然执行高版本API</h3>

<p>如果该段代码进行了API Level限制，确保高版本API不会在低版本设置执行，只需对这个警告设置为忽略即可。</p>

<h2>实战解决</h2>

<p>以下代码所属工程最低支持2.2系统，即API 8。</p>

<h3>NewApi有警报代码</h3>

<p>```java lineos:false
private void testNewApi() {</p>

<pre><code>PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).edit().putBoolean("first_use", false).apply();
</code></pre>

<p>}
```
上面代码中的apply方法为Android API 9引入，使用lint检查会提示警告。</p>

<h3>方案一</h3>

<p>按照API Level不同，选择不同的方法,对于API 9以下使用commit，API 9及其以上使用apply
```java lineos:false
private void testNewApi() {</p>

<pre><code>SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(this).edit();
editor.putBoolean("first_launch", false);
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.GINGERBREAD) {
  editor.apply();
} else {
  editor.commit();
}
</code></pre>

<p>}
```</p>

<h3>方案二</h3>

<p>对于确定不会在低版本运行的情况，我们可以增加@TargetApi加上对应的API引入的版本即可。
```java lineos:false
@TargetApi(Build.VERSION_CODES.GINGERBREAD)
private void testNewApi() {</p>

<pre><code>SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(this).edit();
editor.putBoolean("first_launch", false).apply();
</code></pre>

<p>}
```</p>

<h3>方案三</h3>

<p>同样确保新API不会在低版本运行，也可以忽略警报。
```java lineos:false
@SuppressLint(&ldquo;NewApi&rdquo;)
private void testNewApi() {</p>

<pre><code>SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(this).edit();
editor.putBoolean("first_launch", false).apply();
</code></pre>

<p>}
<code>
**但是这种方案不推荐**，是直接对方法的警告忽略，如果继续在方法中增加代码，则不利于发现问题，比如
</code>java lineos:false
@SuppressLint(&ldquo;NewApi&rdquo;)
private void testNewApi() {</p>

<pre><code>SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(this).edit();
editor.putBoolean("first_launch", false).apply();
"".isEmpty(); //新增加代码，不容易发现问题
</code></pre>

<p>}
```</p>

<h3>含有InlinedApi警告的代码</h3>

<p>下面代码过于简单，只是为了打印一个API 19引入的int常量值。
```java lineos:false
private void testInlinedApi() {</p>

<pre><code>Log.i("MainActivity", "inlinedValue=" + View.ACCESSIBILITY_LIVE_REGION_ASSERTIVE);
</code></pre>

<p>}
<code>
对于这个问题的方案很简答，就是自己定义一个常量，其值与高版本的API常量相同，然后使用这个自定义常量即可。如下代码
</code>java lineos:false
private void testInlinedApi() {</p>

<pre><code>final int VIEW_ACCESSIBILITY_LIVE_REGION_ASSERTIVE = 2;
Log.i("MainActivity", "inlinedValue=" + VIEW_ACCESSIBILITY_LIVE_REGION_ASSERTIVE);
</code></pre>

<p>}
```</p>

<h2>小问题</h2>

<ul>
<li>如果没有lint命令，需要将Android中的sdk/tools/目录加入PATH即可。</li>
</ul>


<p>{%include post/book_copyright.html %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[说说Android中的ANR]]></title>
    <link href="http://droidyue.com/blog/2015/07/18/anr-in-android/"/>
    <updated>2015-07-18T17:53:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/07/18/anr-in-android</id>
    <content type="html"><![CDATA[<p>有过Android开发经历的人都不会对ANR陌生，它和崩溃一样是程序设计的问题。本文将以较为深入的视角来介绍什么是ANR，出现场景，如何避免以及如何定位分析ANR,希望可以帮助大家在编写程序时有所帮助。</p>

<!--more-->


<h2>什么是ANR</h2>

<p>ANR全称<code>Application Not Responding</code>，意思就是程序未响应。如果一个应用无法响应用户的输入，系统就会弹出一个ANR对话框，如下图所示,用户可以自行选择继续等待亦或者是停止当前程序。</p>

<p>{%img <a href="http://7jpolu.com1.z0.glb.clouddn.com/android_anr.png">http://7jpolu.com1.z0.glb.clouddn.com/android_anr.png</a> %}</p>

<h2>出现场景</h2>

<ul>
<li>主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。</li>
<li>主线程中存在耗时的计算</li>
<li>主线程中错误的操作，比如Thread.wait或者Thread.sleep等</li>
</ul>


<p>Android系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框</p>

<ul>
<li>应用在<strong>5秒</strong>内未响应用户的输入事件（如按键或者触摸）</li>
<li>BroadcastReceiver未在<strong>10秒</strong>内完成相关的处理</li>
</ul>


<h2>如何避免</h2>

<p>基本的思路就是将IO操作在工作线程来处理，减少其他耗时操作和错误操作</p>

<ul>
<li>使用<a href="http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android/">AsyncTask</a>处理耗时IO操作。</li>
<li>使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。</li>
<li>使用<a href="http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur/">Handler</a>处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。</li>
<li>Activity的onCreate和onResume回调中尽量避免耗时的代码</li>
<li>BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。</li>
</ul>


<h2>画龙点睛</h2>

<p>通常100到200毫秒就会让人察觉程序反应慢，为了更加提升响应，可以使用下面的几种方法</p>

<ul>
<li>如果程序正在后台处理用户的输入，建议使用让用户得知进度，比如使用ProgressBar控件。</li>
<li>程序启动时可以选择加上欢迎界面，避免让用户察觉卡顿。</li>
<li>使用Systrace和TraceView找出影响响应的问题。</li>
</ul>


<h2>如何定位</h2>

<p>如果开发机器上出现问题，我们可以通过查看<code>/data/anr/traces.txt</code>即可，最新的ANR信息在最开始部分。我们从stacktrace中即可找到出问题的具体行数。本例中问题出现在MainActivity.java 27行，因为这里调用了Thread.sleep方法。
```java
root@htc_m8tl:/ # cat /data/anr/traces.txt | more</p>

<p>&mdash;&mdash;&ndash; pid 30307 at 2015-05-30 14:51:14 &mdash;&mdash;&ndash;
Cmd line: com.example.androidyue.bitmapdemo</p>

<p>JNI: CheckJNI is off; workarounds are off; pins=0; globals=272</p>

<p>DALVIK THREADS:
(mutexes: tll=0 tsl=0 tscl=0 ghl=0)</p>

<p>&ldquo;main&rdquo; prio=5 tid=1 TIMED_WAIT
  | group=&ldquo;main&rdquo; sCount=1 dsCount=0 obj=0x416eaf18 self=0x416d8650
  | sysTid=30307 nice=0 sched=0/0 cgrp=apps handle=1074565528
  | state=S schedstat=( 0 0 0 ) utm=5 stm=4 core=3
  at java.lang.VMThread.sleep(Native Method)
  at java.lang.Thread.sleep(Thread.java:1044)
  at java.lang.Thread.sleep(Thread.java:1026)
  at com.example.androidyue.bitmapdemo.MainActivity$1.run(MainActivity.java:27)
  at android.app.Activity.runOnUiThread(Activity.java:4794)
  at com.example.androidyue.bitmapdemo.MainActivity.onResume(MainActivity.java:33)
  at android.app.Instrumentation.callActivityOnResume(Instrumentation.java:1282)
  at android.app.Activity.performResume(Activity.java:5405)
```</p>

<p>如果是线上版本引起的，Google Play后台有相关的数据可以帮助查看分析并解决问题。</p>

<h2>细致分析</h2>

<p>  <strong>提问</strong>: BroadcastReceiver过了60秒居然没有ANR？ 现场代码如下
```java
public class NetworkReceiver extends BroadcastReceiver{</p>

<pre><code>private static final String LOGTAG = "NetworkReceiver";

@Override
public void onReceive(Context context, Intent intent) {
    Log.i(LOGTAG, "onReceive intent=" + intent);
    try {
        Thread.sleep(60000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    Log.i(LOGTAG, "onReceive end");
}
</code></pre>

<p>}
```
  <strong>回答</strong>：实际上已经发生了ANR，只是没有进行对话框弹出而已。这种ANR就是background ANR，即后台程序的ANR，我们可以通过过滤日志验证</p>

<p><code>java
adb logcat | grep "NetworkReceiver|ActivityManager|WindowManager"
I/NetworkReceiver( 4109): onReceive intent=Intent { act=android.net.conn.CONNECTIVITY_CHANGE flg=0x8000010 cmp=com.example.androidyue.bitmapdemo/.NetworkReceiver (has extras) }
I/ActivityManager(  462): No longer want com.android.exchange (pid 1054): empty #17
I/NetworkReceiver( 4109): onReceive end
W/BroadcastQueue(  462): Receiver during timeout: ResolveInfo{5342dde4 com.example.androidyue.bitmapdemo.NetworkReceiver p=0 o=0 m=0x108000}
E/ActivityManager(  462): ANR in com.example.androidyue.bitmapdemo
E/ActivityManager(  462): Reason: Broadcast of Intent { act=android.net.conn.CONNECTIVITY_CHANGE flg=0x8000010 cmp=com.example.androidyue.bitmapdemo/.NetworkReceiver (has extras) }
E/ActivityManager(  462): Load: 0.37 / 0.2 / 0.14
E/ActivityManager(  462): CPU usage from 26047ms to 0ms ago:
E/ActivityManager(  462):   0.4% 58/adbd: 0% user + 0.4% kernel / faults: 1501 minor
E/ActivityManager(  462):   0.3% 462/system_server: 0.1% user + 0.1% kernel
E/ActivityManager(  462):   0% 4109/com.example.androidyue.bitmapdemo: 0% user + 0% kernel / faults: 6 minor
E/ActivityManager(  462): 1.5% TOTAL: 0.5% user + 0.9% kernel + 0% softirq
E/ActivityManager(  462): CPU usage from 87ms to 589ms later:
E/ActivityManager(  462):   1.8% 58/adbd: 0% user + 1.8% kernel / faults: 30 minor
E/ActivityManager(  462):     1.8% 58/adbd: 0% user + 1.8% kernel
E/ActivityManager(  462): 4% TOTAL: 0% user + 4% kernel
W/ActivityManager(  462): Killing ProcessRecord{5326d418 4109:com.example.androidyue.bitmapdemo/u0a10063}: background ANR
I/ActivityManager(  462): Process com.example.androidyue.bitmapdemo (pid 4109) has died.
</code>
除了日志，我们还可以根据前面提到的查看traces.txt文件。</p>

<p><strong>提问</strong>:可以更容易了解background ANR么？</p>

<p><strong>回答</strong>:当然可以，在Android开发者选项&mdash;>高级&mdash;>显示所有”应用程序无响应“勾选即可对后台ANR也进行弹窗显示，方便查看了解程序运行情况。</p>

<h2>参考文章</h2>

<ul>
<li><a href="http://developer.android.com/intl/zh-cn/training/articles/perf-anr.html">Keeping Your App Responsive</a></li>
</ul>


<p>{%include post/book_copyright.html %}</p>
]]></content>
  </entry>
  
</feed>
