<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2015-05-15T22:37:50+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JAR包未加入APK程序]]></title>
    <link href="http://droidyue.com/blog/2015/05/15/jar-not-in-apk/"/>
    <updated>2015-05-15T20:45:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/05/15/jar-not-in-apk</id>
    <content type="html"><![CDATA[<p>前段时间打包遇到了一个问题，jar包不能加入到apk包中。从Eclipse中完全可以，一旦放到服务器端进行打包就出现了问题。</p>

<!--more-->


<p>使用<code>ant debug -d</code>得到的信息如下
```java
[dx] trouble processing:</p>

<pre><code>   [dx] bad class file magic (cafebabe) or version (0033.0000)
   [dx] ...while parsing com/solo/adsdk/network/a.class
   [dx] ...while processing com/solo/adsdk/network/a.class
   [dx]
   [dx] trouble processing:
   [dx] bad class file magic (cafebabe) or version (0033.0000)
   [dx] ...while parsing com/solo/adsdk/network/b.class
   [dx] ...while processing com/solo/adsdk/network/b.class
   [dx]
   [dx] trouble processing:
   [dx] bad class file magic (cafebabe) or version (0033.0000)
   [dx] ...while parsing com/solo/adsdk/network/AdsLoader.class
   [dx] ...while processing com/solo/adsdk/network/AdsLoader.class
   [dx]
   [dx] trouble processing:
   [dx] bad class file magic (cafebabe) or version (0033.0000)
   [dx] ...while parsing com/solo/adsdk/network/UrlConfig.class
   [dx] ...while processing com/solo/adsdk/network/UrlConfig.class
</code></pre>

<p>```
相比到这里，原因不言则明，原来是jar包的编译版本比工程编译的版本不一致，真实的情况是前后比后者编译版本高。
经过分析，jar包的编译环境是Java 7， 而工程打包的编译环境是Java 6.</p>

<h2>如何解决</h2>

<p>解决这个问题也简单，不出如下做法</p>

<ul>
<li>更换成Java 6编译出来的jar包</li>
<li>使用java 7 打包工程。</li>
</ul>


<h2>如何得知jar包编译版本</h2>

<h3>解压jar包</h3>

<p><code>java
jar fx android-support-v4.jar
</code>
解压后查看当前目录，会多出一个文件夹，这里是名字为android的文件夹。</p>

<h3>查看文件信息</h3>

<p><code>java
11:52 $ file android/support/v4/net/ConnectivityManagerCompat.class
android/support/v4/net/ConnectivityManagerCompat.class: compiled Java class data, version 49.0 (Java 1.5)
</code></p>

<h3>查找版本</h3>

<p>上面我们得到了<code>version 49.0 (Java 1.5)</code>，有些情况下我们得到的只有<code>version 49.0</code>需要查找下面的列表</p>

<h4>版本映射</h4>

<ul>
<li>45.3 = Java 1.1</li>
<li>46 = Java 1.2</li>
<li>47 = Java 1.3</li>
<li>48 = Java 1.4</li>
<li>49 = Java 5</li>
<li>50 = Java 6</li>
<li>51 = Java 7</li>
<li>52 = Java 8</li>
</ul>


<h3>参考文章</h3>

<ul>
<li><a href="http://stackoverflow.com/questions/3313532/what-version-of-javac-built-my-jar">What version of javac built my jar?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Play商店推广那些事]]></title>
    <link href="http://droidyue.com/blog/2015/05/11/google-play-tuiguang/"/>
    <updated>2015-05-11T21:43:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/05/11/google-play-tuiguang</id>
    <content type="html"><![CDATA[<p>Play商店是Android的官方商店，虽然在大陆无法访问，但是这里依旧是重要的版本发布市场，尤其是对于那些国际化的产品。对于拓宽海外市场，付费推广就是一部分不可忽视的措施。而Android付费推广必然就是Play商店推广。本文主要从技术方面讲解，如何统计推广数据，以及在开发过程中遇到的一些疑问和困惑。</p>

<!--more-->


<h2>生成推广链接</h2>

<p>想要进行推广，必须有推广链接。Google提供了生成推广链接的地址<a href="https://developers.google.com/analytics/devguides/collection/android/v2/campaigns#google-play-url-builder">Google Play URL Builder</a>,遗憾的是这个地址被墙了，不过可以使用<a href="http://www.digitangle.co.uk/toolsandresources/google-play-url-builder/#sthash.HLdt4vXJ.dpbs">这个地址</a>，可能稍微慢一点。</p>

<p><img class="<a" src="href="http://droidyueimg.qiniudn.com/play_url_builder.png">http://droidyueimg.qiniudn.com/play_url_builder.png</a>"></p>

<h3>简单描述</h3>

<ul>
<li>Package Name 必填  应用的包名，如com.example.application</li>
<li>Campaign Source 必填 推广的来源，比如google, citysearch, newsletter4</li>
<li>Campaign Medium 选填  推广的媒介，比如cpc, banner, email</li>
<li>Campaign Term   选填 推广的关键字 比如 running+shoes</li>
<li>Campaign Content 选填 推广内容描述</li>
<li>Campaign Name  选填 可以填写 产品名，推广代号或者是推广口号</li>
</ul>


<p>生成的推广地址就是<a href="https://play.google.com/store/apps/details?id=com.mx.browser&amp;referrer=utm_source%3Ddroidyue.com%26utm_medium%3Dadlink%26utm_term%3Dandroid%252Bbrowser%26utm_content%3DBest%2520and%2520Fast%2520Browser%26utm_campaign%3Dandroidyue_123">https://play.google.com/store/apps/details?id=com.mx.browser&amp;referrer=utm_source%3Ddroidyue.com%26utm_medium%3Dadlink%26utm_term%3Dandroid%252Bbrowser%26utm_content%3DBest%2520and%2520Fast%2520Browser%26utm_campaign%3Dandroidyue_123</a></p>

<h2>推广如何工作的</h2>

<p>有了上面的推广链接，我们有必要了解一下Play商店的推广是如何工作的。</p>

<p>  1.用户从网页或者应用中点击Play商店推广链接跳转到Play商店应用的页面下载。<br/>
  2.应用下载完成并安装后，Google Play商店会发送一个<strong>INSTALL_REFERRER</strong>的Intent广播，该Intent中包含了推广链接中的参数。<br/>
  3.应用收到<strong>INSTALL_REFERRER</strong>广播之后，从Intent中读取参数，上报推广数据。</p>

<h2>统计推广数据</h2>

<h3>1.manifest声明receiver，接收<strong>INSTALL_REFERRER</strong>广播</h3>

<p>```xml
<receiver android:name=".PlayCampaignReceiver" android:exported="true"></p>

<pre><code>&lt;intent-filter&gt;
            &lt;action android:name="com.android.vending.INSTALL_REFERRER" /&gt;
        &lt;/intent-filter&gt;       
</code></pre>

<p></receiver>
```</p>

<h3>2.实现PlayCampaignReceiver，处理<strong>INSTALL_REFERRER</strong>广播</h3>

<p>```java
package com.droidyue.playstorereferrertester;</p>

<p>import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.util.Log;</p>

<p>public class PlayCampaignReceiver extends BroadcastReceiver {</p>

<pre><code>private static final String LOGTAG = "PlayCampaignReceiver";
@Override
public void onReceive(Context context, Intent intent) {
    Log.i(LOGTAG, "onReceive intent=" + intent);
    //处理referrer参数
    String referrer = intent.getStringExtra("referrer");
    //some other code
}
</code></pre>

<p>}
```</p>

<h2>多个Receiver</h2>

<p>有些时候我们可能有这样的需求，我们需要多个Receiver监听<strong>INSTALL_REFERRER</strong>广播，其实是可以的。</p>

<h3>代码调用</h3>

<p>这一种是比较推荐的实现方式，比较简单，就是在一个Receiver的onReceive中，实例化另一个Receiver并调用其onReceive方法。
```java</p>

<p>public class PlayCampaignReceiver extends BroadcastReceiver {</p>

<pre><code>private static final String LOGTAG = "PlayCampaignReceiver";
@Override
public void onReceive(Context context, Intent intent) {
    Log.i(LOGTAG, "onReceive intent=" + intent);
    //调用另一个Receiver实例的onReceive方法
    new AnotherPlayCampaignReceiver().onReceive(context, intent);
}
</code></pre>

<p>}
```</p>

<h3>manifest声明</h3>

<p>通过manifest的增加另一个监听<strong>INSTALL_REFERRER</strong>广播的Receiver的形式理论上也可以，但是之前的Google文档中说这种方式有问题，不建议使用。之前Google统计关于市场推广的描述为</p>

<blockquote><p>Note: Only one BroadcastReceiver class can be specified per application. Should you need to incorporate two or more BroadcastReceivers from different SDKs, you will need to create your own BroadcastReceiver class that will receive all broadcasts and call the appropriate BroadcastReceivers for each type of Broadcast.</p></blockquote>

<h2>何时收到推广数据</h2>

<p>关于何时收到推广数据的问题争论颇多，基本上又两个答案：安装完成之后和打一次打开程序时。这两个答案可以说是都对或者都错。</p>

<p>在3.1之前，<strong>INSTALL_REFERRER</strong>广播 确实是在程序安装之后发送的。 <br/>
在3.1之后，<strong>INSTALL_REFERRER</strong>广播 就变成了在程序第一次启动的时候进行的。</p>

<p>那么这又是作何原因呢，其真实的原因就是在3.1 API 12之后，Android系统引入了停止状态，也就是说一个刚下载的程序，在用户手动点击图标启动之前，是收不到正常的广播的。只有当处于非停止状态的应用才能收到<strong>INSTALL_REFERRER</strong>广播。所以广播的发送就选择在程序第一次启动时。  更多关于<a href="http://droidyue.com/blog/2014/07/14/look-inside-android-package-stop-state-since-honeycomb-mr1/">Android中的停止状态</a></p>

<p>为了进一步验证这个发送广播实际，我在Play Store上传了一个测试程序，可以使用这个地址<a href="https://play.google.com/store/apps/details?id=com.droidyue.playstorereferrertester&amp;referrer=utm_source%3Ddroidyue.com%26utm_medium%3Dblog%26utm_term%3Dtest%252Bapp%26utm_content%3Dtest%252Bapp%26utm_campaign%3Dandroidyue_123456">https://play.google.com/store/apps/details?id=com.droidyue.playstorereferrertester&amp;referrer=utm_source%3Ddroidyue.com%26utm_medium%3Dblog%26utm_term%3Dtest%252Bapp%26utm_content%3Dtest%252Bapp%26utm_campaign%3Dandroidyue_123456</a>从Play Store下载测试一下，过滤日志<code>adb logcat | grep PlayCampaignReceiver</code>测试。</p>

<p>注意：这里的第一次安装可以是从Play Store 应用中点打开按钮，也可以是从Launcher中点击应用图标。前面两种情况都是可以接收到广播的。</p>

<h2>别的包也会收到么</h2>

<p>这也是一个被争论的问题，当然我也是通过上面的包验证了，答案就是不会的。<strong>INSTALL_REFERRER</strong>只会发给那个推广安装的程序。</p>

<h2>例外情况</h2>

<p>从网页到客户端的安装是无法发送<strong>INSTALL_REFERRER</strong>广播的。</p>

<h2>奇怪问题</h2>

<h3>协议为哪个</h3>

<p>其实有人会奇怪，究竟推广链接是market还是https协议，答案是都可以，但是推荐使用https协议的链接，首先的既定事实是Google Play URL Builder默认生成的就是https协议链接，另外https是一个被广泛采用的协议，设想如果一个market协议链接在PC浏览器上被点击是怎样的一种体验呢？答案不言自明。</p>

<h2>参考文章</h2>

<ul>
<li><a href="https://developers.google.com/analytics/devguides/collection/android/v2/campaigns#overview">Campaign Measurement </a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[避免Android中Context引起的内存泄露]]></title>
    <link href="http://droidyue.com/blog/2015/04/12/avoid-memory-leaks-on-context-in-android/"/>
    <updated>2015-04-12T21:28:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/04/12/avoid-memory-leaks-on-context-in-android</id>
    <content type="html"><![CDATA[<p>Context是我们在编写Android程序经常使用到的对象，意思为上下文对象。 常用的有Activity的Context还是有Application的Context。Activity用来展示活动界面，包含了很多的视图，而视图又含有图片，文字等资源。在Android中内存泄露很容易出现，而持有很多对象内存占用的Activity更加容易出现内存泄露，开发者需要特别注意这个问题。</p>

<p>本文讲介绍Android中Context，更具体的说是Activity内存泄露的情况，以及如何避免Activity内存泄露，加速应用性能。</p>

<!--more-->


<h2>Drawable引起的内存泄露</h2>

<p>Drawable引起内存泄露这个问题是比较隐晦，难以察觉的。在阅读了Romain Guy的<a href="http://android-developers.blogspot.com.tr/2009/01/avoiding-memory-leaks.html">Avoiding memory leaks</a>，结合grepcode查看源码才明白了。</p>

<p>在Android系统中，当我们进行了屏幕旋转，默认情况下，会销毁掉当前的Activity，并创建一个新的Activity并保持之前的状态。在这个过程中，Android系统会重新加载程序的UI视图和资源。假设我们有一个程序用到了一个很大的Bitmap图像，我们不想每次屏幕旋转时都重新加载这个Bitmap对象，最简单的办法就是将这个Bitmap对象使用static修饰。
```java
private static Drawable sBackground;</p>

<p>@Override
protected void onCreate(Bundle state) {
  super.onCreate(state);</p>

<p>  TextView label = new TextView(this);
  label.setText(&ldquo;Leaks are bad&rdquo;);</p>

<p>  if (sBackground == null) {</p>

<pre><code>sBackground = getDrawable(R.drawable.large_bitmap);
</code></pre>

<p>  }
  label.setBackgroundDrawable(sBackground);</p>

<p>  setContentView(label);
}
```
但是上面的方法在屏幕旋转时有可能引起内存泄露，无论是咋一看还是仔细看这段代码，都很难发现哪里引起了内存泄露。</p>

<p>当一个Drawable绑定到了View上，实际上这个View对象就会成为这个Drawable的一个callback成员变量，上面的例子中静态的sBackground持有TextView对象lable的引用，而lable只有Activity的引用，而Activity会持有其他更多对象的引用。sBackground生命周期要长于Activity。当屏幕旋转时，Activity无法被销毁，这样就产生了内存泄露问题。</p>

<p>2.3.7及以下版本Drawable的setCallback方法的实现
```java
public final void setCallback(Callback cb) {</p>

<pre><code>mCallback = cb;
</code></pre>

<p>}
<code>
好在从4.0.1开始，引入了[弱引用](http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/)处理这个问题，弱引用在GC回收时，不会阻止GC回收其指向的对象，避免了内存泄露问题。
</code>java
public final void setCallback(Callback cb) {</p>

<pre><code>mCallback = new WeakReference&lt;Callback&gt;(cb);
</code></pre>

<p>}
```</p>

<h2>单例引起的内存泄露</h2>

<p>单例是我们比较简单常用的一种设计模式,然而如果单例使用不当也会导致内存泄露。
比如这样一个例子,我们使用饿汉式初始化单例，AppSettings我们需要持有一个Context作为成员变量，如果我们按照下面的实现其实是有问题。
```java
public class AppSettings {</p>

<pre><code>private Context mAppContext;
private static AppSettings sInstance = new AppSettings();

//some other codes
public static AppSettings getInstance() {
    return sInstance;
}

public final void setup(Context context) {
    mAppContext = context;
}
</code></pre>

<p>}
```
sInstance作为静态对象，其生命周期要长于普通的对象，其中也包含Activity，当我们进行屏幕旋转，默认情况下，系统会销毁当前Activity，然后当前的Activity被一个单例持有，导致垃圾回收器无法进行回收，进而产生了内存泄露。</p>

<p>解决的方法就是不持有Activity的引用，而是持有Application的Context引用。代码如下修改
```java
public final void setup(Context context) {</p>

<pre><code>mAppContext = context.getApplicationContext();  
</code></pre>

<p>}
```
访问这里了解更多关于<a href="http://droidyue.com/blog/2015/01/11/looking-into-singleton/">单例模式的问题</a></p>

<h2>条条方法返回Context</h2>

<p>通常我们想要获取Context对象，主要有以下四种方法</p>

<ul>
<li>View.getContext,返回当前View对象的Context对象，通常是当前正在展示的Activity对象。</li>
<li>Activity.getApplicationContext,获取当前Activity所在的(应用)进程的Context对象，通常我们使用Context对象时，要优先考虑这个全局的进程Context。</li>
<li>ContextWrapper.getBaseContext():用来获取一个ContextWrapper进行装饰之前的Context，可以使用这个方法，这个方法在实际开发中使用并不多，也不建议使用。</li>
<li>Activity.this 返回当前的Activity实例，如果是UI控件需要使用Activity作为Context对象，但是默认的Toast实际上使用ApplicationContext也可以。</li>
</ul>


<h2>其他内存泄露问题</h2>

<ul>
<li><a href="http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android/">Android中糟糕的AsyncTask</a></li>
<li><a href="http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur/">Android中Handler引起的内存泄露</a></li>
<li><a href="http://droidyue.com/blog/2014/11/29/why-onsharedpreferencechangelistener-was-not-called/">Google为何这样设计OnSharedPreferenceChangeListener</a></li>
</ul>


<h2>避免内存泄露须谨记</h2>

<ul>
<li>不要让生命周期长于Activity的对象持有到Activity的引用</li>
<li>尽量使用Application的Context而不是Activity的Context</li>
<li>尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用（具体可以查看<a href="http://droidyue.com/blog/2014/10/02/the-private-modifier-in-java/">细话Java："失效"的private修饰符</a>了解）。如果使用静态内部类，将外部实例引用作为<a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">弱引用</a>持有。</li>
<li>垃圾回收不能解决内存泄露，了解<a href="http://droidyue.com/blog/2014/11/02/note-for-google-io-memory-management-for-android-chinese-edition/">Android中垃圾回收机制</a></li>
</ul>


<h2>参考文章</h2>

<ul>
<li><a href="http://android-developers.blogspot.com.tr/2009/01/avoiding-memory-leaks.html">Avoiding memory leaks</a></li>
<li><a href="http://stackoverflow.com/questions/10641144/difference-between-getcontext-getapplicationcontext-getbasecontext-and">Difference between getContext() , getApplicationContext() , getBaseContext() and “this”</a></li>
<li><a href="http://stackoverflow.com/questions/1026973/android-whats-the-difference-between-the-various-methods-to-get-a-context">Android &ndash; what&rsquo;s the difference between the various methods to get a Context?</a></li>
</ul>


<h2>好书推荐</h2>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B009VV6EG8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B009VV6EG8&amp;linkCode=as2&amp;tag=droidyue-23">Android应用性能优化</a></li>
<li><a href="http://www.amazon.cn/gp/product/B00IOB0K1Q/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00IOB0K1Q&amp;linkCode=as2&amp;tag=droidyue-23">图灵程序设计丛书:Java性能优化权威指南</a></li>
<li><a href="http://www.amazon.cn/gp/product/B009GT0H4U/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B009GT0H4U&amp;linkCode=as2&amp;tag=droidyue-23">Java程序性能优化:让你的Java程序更快、更稳定</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[士别三年，我的最新个人作品]]></title>
    <link href="http://droidyue.com/blog/2015/02/28/my-android-work-akoi/"/>
    <updated>2015-02-28T20:43:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/02/28/my-android-work-akoi</id>
    <content type="html"><![CDATA[<p>这个应用是我的最新的作品，一个解决了自己需求的App。</p>

<h2>这是神马App</h2>

<p>拷译是一款超级便捷的翻译工具，其理念就是拷贝即翻译。通常情况下，我们在阅读外文文章时遇到不懂的单词，常见的步骤就是，复制单词，然后切换到桌面，打开字典，进行翻译，理解了意思之后，然后退回到阅读软件，其实就在这些繁琐的过程中，我们阅读很容易被打断，进而影响阅读外文的效率。拷译则解决了这个问题，在阅读软件中遇到了生词，我们只需要复制一下，然后生词对应的意思就能立刻出来，省去了繁琐的切换，让你专注阅读不分心。</p>

<!--more-->


<h2>高清无码大图</h2>

<p><img class="<a" src="href="http://droidyueimg.qiniudn.com/akoi_ui.png">http://droidyueimg.qiniudn.com/akoi_ui.png</a>">
<img class="<a" src="href="http://droidyueimg.qiniudn.com/akoi_target_language.png">http://droidyueimg.qiniudn.com/akoi_target_language.png</a>">
<img class="<a" src="href="http://droidyueimg.qiniudn.com/akoi_result_new.png">http://droidyueimg.qiniudn.com/akoi_result_new.png</a>"></p>

<h2>等饭时的脑洞</h2>

<p>一个周末的晚上，我去附近的春和饺子馆买饭，为了避免在那里吃堂食吸二手烟，我决定打包带走，去之前使用Pocket离线了一篇关于Java运行时数据区的英文文章，于是边等饭边阅读文章，发现了一个不懂的单词，这时候我的做法是复制单词，按Home键退回桌面，找到词典进入，贴出单词，然后查看答案，再退回到Pocket继续阅读。</p>

<p>此时此刻，程序的优越性体现出来了，当剪切板内容变化是由回调通知的，既然我可以拿到复制的内容，我可以使用一个Web服务API翻译这个内容，然后将这些操作放到Service中，将取到的结果以Toast形式展示不就可以了么。当饭好了之后，提着打包的饭屁颠屁颠地回去了。。。。。</p>

<h2>完成前的瞬间</h2>

<ul>
<li>想法出来之后，吃完晚饭花了两个小时解决了技术问题，做出了一个可用的原型</li>
<li>一周以后，邀请小伙伴设计师大麦讨论问题，讨论结果显示位置和应用的功能。</li>
<li>最近的周末，催大麦给我做启动图标，在三里屯请我吃了顿饭，然后去央视大裤衩附近的他的公司逼着他做图。</li>
</ul>


<h2>为什么加广告</h2>

<p>我确实是在应用里面加了广告了，想必使用QQ手机管家这样的工具都能提示的。</p>

<p>国内版本加入的是<a href="https://www.youmi.net/account/register?r=OTU2Ng==">有米广告</a>,之前一直在用有米广告，感觉很不错，感兴趣的朋友可以试一试。</p>

<p>主要的原因还是增加一点收入，毕竟在帝都公交地铁都涨价了，另外加入的广告属于可以接受的，不存在强制弹出的问题，而且广告并非是时刻展示，只有用户触发类似推荐应用时才出现，属于无干扰的类型。</p>

<h2>下载地址</h2>

<p><img class="<a" src="href="http://droidyueimg.qiniudn.com/akoi_qrcode_download.png">http://droidyueimg.qiniudn.com/akoi_qrcode_download.png</a>"></p>

<h2>特别感谢</h2>

<ul>
<li>大麦 我的御用设计师，帮我做图标。多次往返于宋家庄与西北旺之间，辛苦。</li>
</ul>


<h2>最后的话</h2>

<h3>其他词典有这个功能</h3>

<p>确实，当我有了上面的想法之后，查了一下市场上的应用，确实有几款有这样的功能。但是还是有一些不同的，因为依托了百度翻译的技术，支持的语言相对较多。只做复制翻译操作。</p>

<h3>博客没更新</h3>

<p>确实写这个小应用还是比较花时间的，周末的时间，回到家的时间，零零散散的时间，导致最近博客更新减慢，多有抱歉哈。</p>

<h3>沉默三年</h3>

<p>确实距离上次写应用已经三年了，三年前自己还在大学的时候，写过几个拿不出手的应用，那时候自己找图，写的App一点儿技术含量都没有。现在写这个应用完全是解决自己的需求，如果同时能帮助其他人，那么这个应用也是值得的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中处理Touch Icon的方案]]></title>
    <link href="http://droidyue.com/blog/2015/01/18/deal-with-touch-icon-in-android/"/>
    <updated>2015-01-18T21:23:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/01/18/deal-with-touch-icon-in-android</id>
    <content type="html"><![CDATA[<p>苹果的Touch Icon相对我们都比较熟悉，是苹果为了支持网络应用（或者说网页）添加到桌面需要的图标，有了这些Touch Icon的网页链接更加和Native应用更相像了。由于苹果设备IPod，IPhone,IPad等设备广泛，很多网页都提供了touch icon这种图标资源。由于Android中并没有及早的有一份这样的标准，当我们想把网页添加到桌面时，仍然需要使用苹果的Touch Icon。</p>

<!--more-->


<h2>Touch Icon</h2>

<p>当我们想让一个网页比较完美地添加到桌面，通常情况下我们需要设置一个png图片文件作为apple-touch-icon。比如
<code>html
&lt;link rel="apple-touch-icon" href="http://droidyue.com/custom_icon.png"&gt;
</code>
如果想支持IPhone和IPad，我们需要使用sizes属性来制定多个图片，默认sizes的值为60 x 60。
<code>html
&lt;link rel="apple-touch-icon" href="touch-icon-iphone.png"&gt;
&lt;link rel="apple-touch-icon" sizes="76x76" href="touch-icon-ipad.png"&gt;
&lt;link rel="apple-touch-icon" sizes="120x120" href="touch-icon-iphone-retina.png"&gt;
&lt;link rel="apple-touch-icon" sizes="152x152" href="touch-icon-ipad-retina.png"&gt;
</code>
在IOS7之前，苹果系统会对添加到桌面的图标进行圆角化等视觉上的处理，为了不让其处理，我们可以使用apple-touch-icon-precomposed来作为rel的值实现。</p>

<p>更多关于Touch Icon的信息，可以访问<a href="https://developer.apple.com/library/mac/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html">水果开发者网站</a>了解更多。</p>

<h2>Android中有缺陷的实现</h2>

<p>在Android WebView提供了处理Touch Icon的回调，<code>onReceivedTouchIconUrl(WebView view, String url,boolean precomposed)</code>该方法返回了对我们有用的touch icon的url，和是否为预组合（在IOS中不需要进行视觉处理）。虽然有这些数据，我们可以进行处理，但是这其中是有问题的，就是我们不好确定文件的大小，来选择适合的图片。</p>

<p>举个例子,如下一个网页的源码，其中sizes的顺序不规律
<code>html
&lt;link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://www.qiyipic.com/20130423143600/fix/H5-72x72.png"&gt;
&lt;link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://www.qiyipic.com/20130423143600/fix/H5-114x114.png"&gt;
&lt;link rel="apple-touch-icon-precomposed" sizes="57x57" href="http://www.qiyipic.com/20130423143600/fix/H5-57x57.png"&gt;
&lt;link rel="apple-touch-icon-precomposed"  href="http://www.qiyipic.com/20130423143600/fix/H5-0x0.png"&gt;
</code>
加载网页，onReceivedTouchIconUrl输出的日志
<code>bash
I/MainActivity( 6995): onReceivedTouchIconUrl url=http://www.qiyipic.com/20130423143600/fix/H5-0x0.png;precomposed=true
I/MainActivity( 6995): onReceivedTouchIconUrl url=http://www.qiyipic.com/20130423143600/fix/H5-57x57.png;precomposed=true
I/MainActivity( 6995): onReceivedTouchIconUrl url=http://www.qiyipic.com/20130423143600/fix/H5-114x114.png;precomposed=true
I/MainActivity( 6995): onReceivedTouchIconUrl url=http://www.qiyipic.com/20130423143600/fix/H5-72x72.png;precomposed=true
</code>
从上面的输出来看，基本上是后面（书写）的元素先打印出来，所以这个回调的缺陷如下</p>

<ul>
<li>由于Touch Icon url地址没有硬性规定，不能根据url包含某些尺寸来判断使用哪个icon</li>
<li>由于网页编写touch icon元素相对随意，不能根据onReceivedTouchIconUrl调用先后来决定使用哪个icon</li>
<li>回调中没有sizes属性值，不好确定使用哪个icon</li>
<li>如果我们选取质量最高的图片，然后进行适当压缩处理或许可以解决问题，但是将全部icon下载下来或者根据Head头信息总感觉不怎么好。</li>
</ul>


<h2>改进方法</h2>

<p>既然WebView没有现成的方法满足我们的需求，只好自己来实现。其实实现方法还是比较简单地就是js脚本注入检测网页元素中得touch icon，返回json数据。</p>

<h3>JavaScript方法</h3>

<p>下面的JS代码所做的功能为查找所有为touch icon的link元素，包含正常的还标记为precomposed。然后将这些link元素的属性存入json数据，最后返回给Java代码中对应的回调。
```javascript
var touchIcons = [];
function gatherTouchIcons(elements) {</p>

<pre><code>var normalTouchIconLength = elements.length;
var currentElement;
for (var i =0; i &lt; normalTouchIconLength;i++) {
    currentElement = elements[i];
    var size;
    if (currentElement.hasAttribute('sizes')) {
        size = currentElement.sizes[0];
    } else {
        size = '';
    }
    var info = {'sizes':size, 'rel': currentElement.rel, 'href': currentElement.href};
    touchIcons.push(info);
}
</code></pre>

<p>}</p>

<p>function obtainTouchIcons() {</p>

<pre><code>normalElements = document.querySelectorAll("link[rel='apple-touch-icon']");
precomposedElements = document.querySelectorAll("link[rel='apple-touch-icon-precomposed']");
gatherTouchIcons(normalElements);
gatherTouchIcons(precomposedElements);
var info = JSON.stringify(touchIcons);
window.app_native.onReceivedTouchIcons(document.URL, info);
</code></pre>

<p>}
obtainTouchIcons();
```</p>

<h3>Java代码</h3>

<p>这里为了便于理解还是全部贴出了demo的源码，demo中当网页加载完成之后注入上面的js代码获取touch icon信息，然后返回给java的回调方法中。如果不清楚Java和JavaScript交互，可以访问<a href="http://droidyue.com/blog/2014/09/20/interaction-between-java-and-javascript-in-android/">Android中Java和JavaScript交互</a>了解更多。
```java
package com.example.obtaintouchicon;</p>

<p>import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;</p>

<p>import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.webkit.JavascriptInterface;
import android.webkit.WebChromeClient;
import android.webkit.WebView;
import android.webkit.WebViewClient;</p>

<p>public class MainActivity extends Activity {</p>

<pre><code>protected String LOGTAG = "MainActivity";

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    WebView webView = new WebView(this);
    webView.getSettings().setJavaScriptEnabled(true);
    webView.setWebViewClient(new WebViewClient() {
        @Override
        public void onPageFinished(WebView view, String url) {
            super.onPageFinished(view, url);
            final String touchIconJsCode = getTouchIconJsCode();
            Log.i(LOGTAG , "onPageFinished url = " + url + ";touchIconJsCode=" + touchIconJsCode);
            view.loadUrl("javascript:" + touchIconJsCode);
        }
    });
    webView.addJavascriptInterface(new JsObject(), "app_native");
    webView.loadUrl("http://192.168.1.5:8000/html/touchicon.html");
}


private class JsObject {

    @JavascriptInterface
    public void onReceivedTouchIcons(String url, String json) {
        Log.i(LOGTAG, "onReceivedTouchIcons url=" + url + ";json=" + json);
    }
}

private String getTouchIconJsCode() {
    StringBuilder total = new StringBuilder();
    InputStream inputStream = null;
    BufferedReader bufferReader = null;
    try {
        inputStream = getAssets().open("touchicon.js");
        bufferReader = new BufferedReader(new InputStreamReader(inputStream));
        String line;
        while ((line = bufferReader.readLine()) != null) {
            total.append(line);
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (null != inputStream) {
            try {
                inputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    return total.toString();
}
</code></pre>

<p>}
```</p>

<h3>返回的JSON数据</h3>

<p>```java
[</p>

<pre><code>{
    "sizes":"72x72",
    "rel":"apple-touch-icon-precomposed",
    "href":"http://www.qiyipic.com/20130423143600/fix/H5-72x72.png"
},
{
    "sizes":"114x114",
    "rel":"apple-touch-icon-precomposed",
    "href":"http://www.qiyipic.com/20130423143600/fix/H5-114x114.png"
},
{
    "sizes":"57x57",
    "rel":"apple-touch-icon-precomposed",
    "href":"http://www.qiyipic.com/20130423143600/fix/H5-57x57.png"
},
{
    "sizes":"",
    "rel":"apple-touch-icon-precomposed",
    "href":"http://www.qiyipic.com/20130423143600/fix/H5-0x0.png"
}
</code></pre>

<p>]
```
我们可以对得到的JSON数据按照需要处理。</p>

<h2>Google会改进么</h2>

<p>答案是会，而且已经改进，但Google修改的不是onReceivedTouchIconUrl这个方法，而是Google正在推行自己的一套规则。</p>

<p>在Chrome上，Google增加了这样一个元素，这是Google提供的为网页程序定义元数据的方法。
<code>html
&lt;link rel="manifest" href="manifest.json"&gt;
</code>
在元数据json中，你可以自定义title，起始页，程序是横屏还是竖屏展示。一个简单地json实例如下，这里我们可以看到其中icons中存在多个类似touch icon的图标，src代表图标路径，sizes代表大小，type就是mimetype，density指的是Android中的屏幕密度（这样更加Android化了）。
```java
{
  &ldquo;name&rdquo;: &ldquo;Web Application Manifest Sample&rdquo;,
  &ldquo;icons&rdquo;: [</p>

<pre><code>{
  "src": "launcher-icon-0-75x.png",
  "sizes": "36x36",
  "type": "image/png",
  "density": "0.75"
},
{
  "src": "launcher-icon-1x.png",
  "sizes": "48x48",
  "type": "image/png",
  "density": "1.0"
},
{
  "src": "launcher-icon-1-5x.png",
  "sizes": "72x72",
  "type": "image/png",
  "density": "1.5"
},
{
  "src": "launcher-icon-2x.png",
  "sizes": "96x96",
  "type": "image/png",
  "density": "2.0"
},
{
  "src": "launcher-icon-3x.png",
  "sizes": "144x144",
  "type": "image/png",
  "density": "3.0"
},
{
  "src": "launcher-icon-4x.png",
  "sizes": "192x192",
  "type": "image/png",
  "density": "4.0"
}
</code></pre>

<p>  ],
  &ldquo;start_url&rdquo;: &ldquo;index.html&rdquo;,
  &ldquo;display&rdquo;: &ldquo;standalone&rdquo;,
  &ldquo;orientation&rdquo;: &ldquo;landscape&rdquo;
}
```
关于Google这套新的标准，可以参考<a href="https://developer.chrome.com/multidevice/android/installtohomescreen">Add to Homescreen</a></p>

<p>但是由于目前，这种标准实施率相对比较低，所以我们还是需要使用苹果的touch icon。</p>

<h2>推荐阅读</h2>

<ul>
<li><a href="https://mathiasbynens.be/notes/touch-icons">Everything you always wanted to know about touch icons</a></li>
</ul>


<h2>源码下载</h2>

<ul>
<li><a href="http://pan.baidu.com/s/1dDD3gZZ">http://pan.baidu.com/s/1dDD3gZZ</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
