<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2015-10-01T13:42:34+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android性能调优利器StrictMode]]></title>
    <link href="http://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode/"/>
    <updated>2015-09-26T20:50:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode</id>
    <content type="html"><![CDATA[<p>作为Android开发，日常的开发工作中或多或少要接触到性能问题，比如我的Android程序运行缓慢卡顿，并且常常出现ANR对话框等等问题。既然有性能问题，就需要进行性能优化。正所谓工欲善其事，必先利其器。一个好的工具，可以帮助我们发现并定位问题，进而有的放矢进行解决。本文主要介绍StrictMode 在Android 应用开发中的应用和一些问题。</p>

<!--more-->


<h2>什么是StrictMode</h2>

<p>StrictMode意思为严格模式，是用来检测程序中违例情况的开发者工具。最常用的场景就是检测主线程中本地磁盘和网络读写等耗时的操作。</p>

<h3>严在哪里</h3>

<p>既然叫做严格模式，那么又严格在哪些地方呢？<br/>
在Android中，主线程，也就是UI线程，除了负责处理UI相关的操作外，还可以执行文件读取或者数据库读写操作（从Android 4.0 开始，网络操作禁止在主线程中执行，否则会抛出<a href="http://droidyue.com/blog/2014/11/08/look-into-android-dot-os-dot-networkonmainthreadexception/">NetworkOnMainThreadException</a>）。使用严格模式，系统检测出主线程违例的情况会做出相应的反应，如日志打印，弹出对话框亦或者崩溃等。换言之，严格模式会将应用的违例细节暴露给开发者方便优化与改善。</p>

<h3>具体能检测什么</h3>

<p>严格模式主要检测两大问题，一个是线程策略，即TreadPolicy，另一个是VM策略，即VmPolicy。</p>

<h3>ThreadPolicy</h3>

<p>线程策略检测的内容有</p>

<ul>
<li>自定义的耗时调用 使用<strong>detectCustomSlowCalls()</strong>开启</li>
<li>磁盘读取操作 使用<strong>detectDiskReads()</strong>开启</li>
<li>磁盘写入操作 使用<strong>detectDiskWrites()</strong>开启</li>
<li>网络操作  使用<strong>detectNetwork()</strong>开启</li>
</ul>


<h3>VmPolicy</h3>

<p>虚拟机策略检测的内容有</p>

<ul>
<li>Activity泄露 使用<strong>detectActivityLeaks()</strong>开启</li>
<li>未关闭的Closable对象泄露  使用<strong>detectLeakedClosableObjects()</strong>开启</li>
<li>泄露的Sqlite对象  使用<strong>detectLeakedSqlLiteObjects()</strong>开启</li>
<li>检测实例数量 使用<strong>setClassInstanceLimit()</strong>开启</li>
</ul>


<h2>工作原理</h2>

<p>其实StrictMode实现原理也比较简单，以IO操作为例，主要是通过在open，read，write，close时进行监控。<code>libcore.io.BlockGuardOs</code>文件就是监控的地方。以open为例，如下进行监控。</p>

<p>```java
@Override
public FileDescriptor open(String path, int flags, int mode) throws ErrnoException {</p>

<pre><code>BlockGuard.getThreadPolicy().onReadFromDisk();
if ((mode &amp; O_ACCMODE) != O_RDONLY) {
    BlockGuard.getThreadPolicy().onWriteToDisk();
}
return os.open(path, flags, mode);
</code></pre>

<p>}
<code>
其中**onReadFromDisk()**方法的实现，代码位于StrictMode.java中。
</code>
public void onReadFromDisk() {</p>

<pre><code>if ((mPolicyMask &amp; DETECT_DISK_READ) == 0) {
    return;
}
if (tooManyViolationsThisLoop()) {
    return;
}
BlockGuard.BlockGuardPolicyException e = new StrictModeDiskReadViolation(mPolicyMask);
e.fillInStackTrace();
startHandlingViolationException(e);
</code></pre>

<p>}
```</p>

<h2>如何使用</h2>

<p>关于StrictMode如何使用，最重要的就是如何启用严格模式。</p>

<h3>放在哪里</h3>

<p>严格模式的开启可以放在Application或者Activity以及其他组件的onCreate方法。为了更好地分析应用中的问题，建议放在Application的onCreate方法中。</p>

<h3>简单启用</h3>

<p>以下的代码启用全部的ThreadPolicy和VmPolicy违例检测
```java
if (IS_DEBUG &amp;&amp; Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {</p>

<pre><code>StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectAll().penaltyLog().build());
StrictMode.setVmPolicy(new VmPolicy.Builder().detectAll().penaltyLog().build());
</code></pre>

<p>}
```
严格模式需要在debug模式开启，不要在release版本中启用。</p>

<p>同时，严格模式自API 9 开始引入，某些API方法也从 API 11 引入。使用时应该注意 API 级别。</p>

<p>如有需要，也可以开启部分的严格模式。</p>

<h3>查看结果</h3>

<p>严格模式有很多种报告违例的形式，但是想要分析具体违例情况，还是需要查看日志，终端下过滤StrictMode就能得到违例的具体stacktrace信息。
<code>bash
adb logcat | grep StrictMode
</code></p>

<h2>解决违例</h2>

<ul>
<li>如果是主线程中出现文件读写违例，建议使用工作线程（必要时结合Handler）完成。</li>
<li>如果是对SharedPreferences写入操作，在API 9 以上 建议优先调用apply而非commit。</li>
<li>如果是存在未关闭的Closable对象，根据对应的stacktrace进行关闭。</li>
<li>如果是SQLite对象泄露，根据对应的stacktrace进行释放。</li>
</ul>


<p>举个例子</p>

<p>以主线程中的文件写入为例，引起违例警告的代码
```java
public void writeToExternalStorage() {</p>

<pre><code>File externalStorage = Environment.getExternalStorageDirectory();
File destFile = new File(externalStorage, "dest.txt");
try {
    OutputStream output = new FileOutputStream(destFile, true);
    output.write("droidyue.com".getBytes());
    output.flush();
    output.close();
} catch (FileNotFoundException e) {
    e.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
}
</code></pre>

<p>}
<code>
引起的警告为
</code>bash
D/StrictMode( 9730): StrictMode policy violation; ~duration=20 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=31 violation=2
D/StrictMode( 9730):    at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1176)
D/StrictMode( 9730):    at libcore.io.BlockGuardOs.open(BlockGuardOs.java:106)
D/StrictMode( 9730):    at libcore.io.IoBridge.open(IoBridge.java:390)
D/StrictMode( 9730):    at java.io.FileOutputStream.<init>(FileOutputStream.java:88)
D/StrictMode( 9730):    at com.example.strictmodedemo.MainActivity.writeToExternalStorage(MainActivity.java:56)
D/StrictMode( 9730):    at com.example.strictmodedemo.MainActivity.onCreate(MainActivity.java:30)
D/StrictMode( 9730):    at android.app.Activity.performCreate(Activity.java:4543)
<code>
因为上述属于主线程中的IO违例，解决方法就是讲写入操作放入工作线程。
</code>
public void writeToExternalStorage() {</p>

<pre><code>new Thread() {
    @Override
    public void run() {
        super.run();
        File externalStorage = Environment.getExternalStorageDirectory();
        File destFile = new File(externalStorage, "dest.txt");
        try {
            OutputStream output = new FileOutputStream(destFile, true);
            output.write("droidyue.com".getBytes());
            output.flush();
            output.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}.start();
</code></pre>

<p>}
<code>
然而这并非完善，因为OutputStream.write方法可能抛出IOException，导致存在OutputStream对象未关闭的情况，仍然需要改进避免出现Closable对象未关闭的违例。改进如下
</code>java
public void writeToExternalStorage() {</p>

<pre><code>new Thread() {
    @Override
    public void run() {
        super.run();
        File externalStorage = Environment.getExternalStorageDirectory();
        File destFile = new File(externalStorage, "dest.txt");
        OutputStream output = null;
        try {
            output = new FileOutputStream(destFile, true);
            output.write("droidyue.com".getBytes());
            output.flush();
            output.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (null != output) {
                try {
                    output.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}.start();
</code></pre>

<p>}
```</p>

<h2>检测内存泄露</h2>

<p>通常情况下，检测内存泄露，我们需要使用MAT对heap dump 文件进行分析，这种操作不困难，但也不容易。使用严格模式，只需要过滤日志就能发现内存泄露。</p>

<p>这里以Activity为例说明，首先我们需要开启对检测Activity泄露的违例检测。使用上面的detectAll或者detectActivityLeaks()均可。其次写一段能够产生Activity泄露的代码。
```
public class LeakyActivity extends Activity{</p>

<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    MyApplication.sLeakyActivities.add(this);
}
</code></pre>

<p>}
<code>
MyApplication中关于sLeakyActivities的部分实现
</code>java
public class MyApplication extends Application {</p>

<pre><code>public static final boolean IS_DEBUG = true;
public static ArrayList&lt;Activity&gt; sLeakyActivities = new ArrayList&lt;Activity&gt;();
</code></pre>

<p>}
```</p>

<p>当我们反复进入LeakyActivity再退出，过滤StrictMode就会得到这样的日志
<code>bash
E/StrictMode( 2622): class com.example.strictmodedemo.LeakyActivity; instances=2; limit=1
E/StrictMode( 2622): android.os.StrictMode$InstanceCountViolation: class com.example.strictmodedemo.LeakyActivity; instances=2; limit=1
E/StrictMode( 2622):    at android.os.StrictMode.setClassInstanceLimit(StrictMode.java:1)
</code>
分析日志，LeakyActivity本应该是只存在一份实例，但现在出现了2个，说明LeakyActivity发生了内存泄露。</p>

<p>严格模式除了可以检测Activity的内存泄露之外，还能自定义检测类的实例泄露。从API 11 开始，系统提供的这个方法可以实现我们的需求。
<code>
public StrictMode.VmPolicy.Builder setClassInstanceLimit (Class klass, int instanceLimit)
</code>
举个栗子，比如一个浏览器中只允许存在一个SearchBox实例，我们就可以这样设置已检测SearchBox实例的泄露
<code>
StrictMode.setVmPolicy(new VmPolicy.Builder().setClassInstanceLimit(SearchBox.class, 1).penaltyLog().build());
</code></p>

<h2>noteSlowCall</h2>

<p>StrictMode从 API 11开始允许开发者自定义一些耗时调用违例，这种自定义适用于自定义的任务执行类中，比如我们有一个进行任务处理的类，为TaskExecutor。
```
public class TaskExecutor {</p>

<pre><code>public void execute(Runnable task) {
    task.run();
}
</code></pre>

<p>}
<code>
先需要跟踪每个任务的耗时情况，如果大于500毫秒需要提示给开发者，noteSlowCall就可以实现这个功能，如下修改代码
</code>java
public class TaskExecutor {</p>

<pre><code>private static long SLOW_CALL_THRESHOLD = 500;
public void executeTask(Runnable task) {
    long startTime = SystemClock.uptimeMillis();
    task.run();
    long cost = SystemClock.uptimeMillis() - startTime;
    if (cost &gt; SLOW_CALL_THRESHOLD) {
        StrictMode.noteSlowCall("slowCall cost=" + cost);
    }
}
</code></pre>

<p>}
<code>
执行一个耗时2000毫秒的任务
</code>bash
TaskExecutor executor = new TaskExecutor();
executor.executeTask(new Runnable() {</p>

<pre><code>@Override
public void run() {
    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>});
<code>
得到的违例日志，注意其中`~duration=20 ms`并非耗时任务的执行时间，而我们的自定义信息`msg=slowCall cost=2000`才包含了真正的耗时。
</code>bash
D/StrictMode(23890): StrictMode policy violation; ~duration=20 ms: android.os.StrictMode$StrictModeCustomViolation: policy=31 violation=8 msg=slowCall cost=2000
D/StrictMode(23890):    at android.os.StrictMode$AndroidBlockGuardPolicy.onCustomSlowCall(StrictMode.java:1163)
D/StrictMode(23890):    at android.os.StrictMode.noteSlowCall(StrictMode.java:1974)
D/StrictMode(23890):    at com.example.strictmodedemo.TaskExecutor.executeTask(TaskExecutor.java:17)
D/StrictMode(23890):    at com.example.strictmodedemo.MainActivity.onCreate(MainActivity.java:36)
D/StrictMode(23890):    at android.app.Activity.performCreate(Activity.java:4543)
D/StrictMode(23890):    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1071)
D/StrictMode(23890):    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2158)
D/StrictMode(23890):    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2237)
D/StrictMode(23890):    at android.app.ActivityThread.access$600(ActivityThread.java:139)
D/StrictMode(23890):    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1262)
D/StrictMode(23890):    at android.os.Handler.dispatchMessage(Handler.java:99)
D/StrictMode(23890):    at android.os.Looper.loop(Looper.java:156)
D/StrictMode(23890):    at android.app.ActivityThread.main(ActivityThread.java:5005)
D/StrictMode(23890):    at java.lang.reflect.Method.invokeNative(Native Method)
D/StrictMode(23890):    at java.lang.reflect.Method.invoke(Method.java:511)
D/StrictMode(23890):    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:784)
D/StrictMode(23890):    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:551)
D/StrictMode(23890):    at dalvik.system.NativeStart.main(Native Method)
```</p>

<h2>其他技巧</h2>

<p>除了通过日志查看之外，我们也可以在开发者选项中开启严格模式，开启之后，如果主线程中有执行时间长的操作，屏幕则会闪烁，这是一个更加直接的方法。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/strictmode_developer_tools.png">http://7jpolu.com1.z0.glb.clouddn.com/strictmode_developer_tools.png</a>"></p>

<h2>问题来了</h2>

<h3>日志的时间靠谱么</h3>

<p>在下面的过滤日志中，我们看到下面的一个IO操作要消耗31毫秒，这是真的么<br/>
<code>bash
D/StrictMode( 2921): StrictMode policy violation; ~duration=31 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=31 violation=2
D/StrictMode( 2921):    at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1176)
D/StrictMode( 2921):    at libcore.io.BlockGuardOs.read(BlockGuardOs.java:148)
D/StrictMode( 2921):    at libcore.io.IoBridge.read(IoBridge.java:422)
D/StrictMode( 2921):    at java.io.FileInputStream.read(FileInputStream.java:179)
D/StrictMode( 2921):    at java.io.InputStreamReader.read(InputStreamReader.java:244)
D/StrictMode( 2921):    at java.io.BufferedReader.fillBuf(BufferedReader.java:130)
D/StrictMode( 2921):    at java.io.BufferedReader.readLine(BufferedReader.java:354)
D/StrictMode( 2921):    at com.example.strictmodedemo.MainActivity.testReadContentOfFile(MainActivity.java:65)
D/StrictMode( 2921):    at com.example.strictmodedemo.MainActivity.onCreate(MainActivity.java:28)
D/StrictMode( 2921):    at android.app.Activity.performCreate(Activity.java:4543)
</code></p>

<p>从上面的stacktrace可以看出testReadContentOfFile方法中包含了文件读取IO操作，至于是否为31毫秒，我们可以利用秒表的原理计算一下，即在方法调用的地方如下记录
<code>java
long startTime = System.currentTimeMillis();
testReadContentOfFile();
long cost = System.currentTimeMillis() - startTime;
Log.d(LOGTAG, "cost = " + cost);
</code>
得到的日志中上述操作耗时9毫秒，非31毫秒。
<code>bash
D/MainActivity(20996): cost = 9
</code>
注：通常情况下StrictMode给出的耗时相对实际情况偏高，并不是真正的耗时数据。</p>

<h2>注意</h2>

<ul>
<li>在线上环境即Release版本不建议开启严格模式。</li>
<li>严格模式无法监控JNI中的磁盘IO和网络请求。</li>
<li>应用中并非需要解决全部的违例情况，比如有些IO操作必须在主线程中进行。</li>
</ul>


<p><script type="text/javascript" src="http://droidyue.b0.upaiyun.com/js/blog/book_copyright.js"></script>
<script type="text/javascript">
	showBookCopyright();
</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android进程线程调度之cgroups]]></title>
    <link href="http://droidyue.com/blog/2015/09/17/android-process-and-thread-schedule-cgroups/"/>
    <updated>2015-09-17T21:17:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/09/17/android-process-and-thread-schedule-cgroups</id>
    <content type="html"><![CDATA[<p>做Android开发的同学们，了解cgroups的同学其实不多，cgroups是什么意思呢，在操作系统中有着什么样的作用，以及Android中的cgroups有哪些，各有什么用呢，本文将会进行逐一剖析。</p>

<!--more-->


<h2>先看定义</h2>

<p>下面的引用为维基百科的<a href="https://zh.wikipedia.org/wiki/Cgroups">cgroups的定义</a></p>

<blockquote><p>cgroups，其名称源自控制组群（control groups）的简写，是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。</p></blockquote>

<p>维基百科的解释言简意赅，无需赘述，下面以例子讲解如何使用cgroups。</p>

<h2>结合示例</h2>

<p>以下会以Fedora这个Linux发行版为例，介绍如何使用cgroups限制进程的CPU使用率。</p>

<p>这里我们使用一个死循环的Python脚本用来消耗CPU，文件名为loop.py，。
```python</p>

<h1>!/usr/bin/env python</h1>

<h1>coding=utf-8</h1>

<p>i = 0
while True:</p>

<pre><code>i = i + 1
</code></pre>

<p>```</p>

<p>执行脚本<code>python loop.py</code>，使用top查看该进程的CPU使用情况,CPU使用率接近100%。
<img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/cpu_cost_no_limit.png">http://7jpolu.com1.z0.glb.clouddn.com/cpu_cost_no_limit.png</a>"></p>

<p>然后我们将会通过修改配置，利用cgroups将该进程的CPU使用率降低到10%</p>

<p>首先查看当前系统的cgroups
<code>bash
16:31:57-androidyue/tmp$ sudo mount -t cgroup
[sudo] password for androidyue:
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)
cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)
cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)
</code></p>

<p>然后创建一个cgroup,控制CPU使用率。
<code>bash
cd /sys/fs/cgroup/cpu
sudo mkdir cpu_test
</code></p>

<p>接下来查看刚刚创建的cpu_test
<code>bash
17:04:54-androidyue/sys/fs/cgroup/cpu$ ls cpu_test/
cgroup.clone_children  cgroup.procs  cpuacct.usage         cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  notify_on_release
cgroup.event_control   cpuacct.stat  cpuacct.usage_percpu  cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat    tasks
</code></p>

<p>完成这一目标修改涉及到的文件有</p>

<p>cpu.cfs_period_us
设置该cgroup请求到CPU资源分配的周期，单位为微秒（这里使用us代替微秒单位µs）。</p>

<p>cpu.cfs_quota_us
设置cgroup组内的进程在一次CPU分配周期（即cpu.cfs_period_us指定的值）内可以执行的时间。</p>

<p>如果我们想要设置该cpu_test组内的cpu使用率为10%，我们需要这样修改
<code>
echo 1000000 &gt; cpu.cfs_period_us
echo 100000 &gt; cpu.cfs_quota_us
</code>
注意上述修改需要使用root身份登陆，即<code>sudo -i</code>,下面的将进程加入cgroup同样需要root身份。</p>

<p>将上图中的进程ID 写入到cpu_test下的tasks文件中，并查看tasks验证是否加入成功
<code>bash
17:12:27-root/sys/fs/cgroup/cpu/cpu_test$ sudo echo 12093 &gt; tasks
17:12:41-root/sys/fs/cgroup/cpu/cpu_test$ cat tasks
12093
</code></p>

<p>再次查看进程id为12093的CPU使用率，已成功降低到10%左右。
<img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/cpu_cost_with_limit.png">http://7jpolu.com1.z0.glb.clouddn.com/cpu_cost_with_limit.png</a>"></p>

<h2>cgroups在Android中的应用</h2>

<p>在Android中也存在cgroups，涉及到CPU的目前只有两个，一个是apps，路径为<code>/dev/cpuctl/apps</code>。另一个是bg_non_interactive，路径为<code>/dev/cpuctl/apps/bg_non_interactive</code></p>

<h3>cpu.share</h3>

<p>cpu.share文件中保存了整数值，用来设置cgroup分组任务获得CPU时间的相对值。举例来说，cgroup A和cgroup B的cpu.share值都是1024，那么cgroup A 与cgroup B中的任务分配到的CPU时间相同，如果cgroup C的cpu.share为512，那么cgroup C中的任务获得的CPU时间是A或B的一半。</p>

<p>apps下的cpu.share 值为1024
<code>bash
root@htc_m8tl:/dev/cpuctl/apps # cat cpu.shares
1024
</code>
bg_non_interactive下的cpu_share值为52
<code>bash
root@htc_m8tl:/dev/cpuctl/apps/bg_non_interactive # cat cpu.shares
52
</code>
也就是说apps分组与bg_non_interactive分组cpu.share值相比接近于20:1。由于Android中只有这两个cgroup，也就是说apps分组中的应用可以利用95%的CPU，而处于bg_non_interactive分组中的应用则只能获得5%的CPU利用率。</p>

<h2>cpu.rt_period_us与cpu.rt_runtime_us</h2>

<p>cpu.rt_period_us用来设置cgroup获得CPU资源的周期，单位为微秒。
cpu.rt_runtime_us用来设置cgroup中的任务可以最长获得CPU资源的时间，单位为微秒。设定这个值可以访问某个cgroup独占CPU资源。最长的获取CPU资源时间取决于逻辑CPU的数量。比如cpu.rt_runtime_us设置为200000（0.2秒），cpu.rt_period_us设置为1000000（1秒）。在单个逻辑CPU上的获得时间为每秒为0.2秒。 2个逻辑CPU，获得的时间则是0.4秒。</p>

<p>apps分组下的两个配置的值
<code>bash
root@htc_m8tl:/dev/cpuctl/apps # cat cpu.rt_period_us
1000000
root@htc_m8tl:/dev/cpuctl/apps # cat cpu.rt_runtime_us
800000
</code>
即单个逻辑CPU下每一秒内可以获得0.8秒的执行时间。</p>

<p>bg_non_interactive分组下的两个配置的值
<code>bash
root@htc_m8tl:/dev/cpuctl/apps/bg_non_interactive # cat cpu.rt_period_us
1000000
root@htc_m8tl:/dev/cpuctl/apps/bg_non_interactive # cat cpu.rt_runtime_us
700000
</code>
即单个逻辑CPU下每一秒可以获得0.7秒的执行时间。</p>

<h3>花落谁家</h3>

<p>在Android中，一个应用（进程）既可以由apps切换到bg_non_interactive，也可以切换回来。</p>

<h4>Activity</h4>

<p>当一个Activity处于可见的状态下，那么这个应用进程就属于apps分组。</p>

<h4>Service</h4>

<p>当Service调用startForeground方法后，那么这个应用进程则是归类于apps分组
<code>java
Notification.Builder  builder = new Notification.Builder(this);
builder.setContentTitle("Title");
Notification notification = builder.build();
startForeground(notification.hashCode(), notification);
</code></p>

<h3>如何确定进程的cgroups</h3>

<p>其实确定过程也很简单，总共分三步。</p>

<p>第一步，进入已经root的Android设备终端
<code>
11:10 $ adb shell
root@htc_m8tl:/ # su
root@htc_m8tl:/ #
</code></p>

<p>第二步，目标应用的进程id，这里以我们的demo程序（包名为com.droidyue.androidthreadschedule）为例。得到的进程id为22871
<code>
root@htc_m8tl:/ # ps | grep com.droidyue
u0_a1434  22871 23723 970040 54304 ffffffff 400a045c S com.droidyue.androidthreadschedule
</code></p>

<p>第三步，利用进程id查看其所在的cgroups
<code>
2|root@htc_m8tl:/ # cat  /proc/22871/cgroup
3:cpu:/apps
2:memory:/
1:cpuacct:/uid/11434
</code></p>

<p>通过以上三步，<del>我们就能把大象关冰箱里</del>,我们就能得到进程所在的cgroups分组。</p>

<h2>利用cgroups我们可以做什么</h2>

<p>其实对于一般应用来说，能做的事情少之又少。对于有需要的应用可以使用Service.startForeground方法来获取更多的CPU资源，但并不建议盲目去这样做，还是要根据自身应用需要实现。</p>

<p>另外，个人认为最大的收获，就是我们可以参照cgroups的分组的思想来设计有类似场景的方案解决实际问题。</p>

<h3>同系列文章</h3>

<ul>
<li><a href="/blog/2015/09/05/android-process-and-thread-schedule-nice/?droid_refer=series">剖析Android中进程与线程调度之nice</a></li>
</ul>


<p><script type="text/javascript" src="http://droidyue.b0.upaiyun.com/js/blog/book_copyright.js"></script>
<script type="text/javascript">
	showBookCopyright();
</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剖析Android中进程与线程调度之nice]]></title>
    <link href="http://droidyue.com/blog/2015/09/05/android-process-and-thread-schedule-nice/"/>
    <updated>2015-09-05T11:35:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/09/05/android-process-and-thread-schedule-nice</id>
    <content type="html"><![CDATA[<p>在计算机操作系统中，进程是进行资源分配和调度的基本单位，同时每个进程之内也可以存在多个线程。那么在Android系统（Linux Kernel）中，进程是如何去抢占资源，线程又是如何根据优先级切换呢，本文将尝试剖析这个问题，研究nice在Linux以及Android系统中的应用。</p>

<!--more-->


<h2>一些概念</h2>

<ul>
<li>进程 是计算机系统中，程序运行的实体，也是线程的容器。</li>
<li>线程 是进程中实际执行单位，一个线程是程序执行流的最小单元。在一个进程中可以有多个线程存在。</li>
</ul>


<h2>nice与进程调度</h2>

<p>Linux中，使用nice value（以下成为nice值）来设定一个进程的优先级，系统任务调度器根据nice值合理安排调度。</p>

<ul>
<li>nice的取值范围为-20到19。</li>
<li>通常情况下，nice的默认值为0。视具体操作系统而定。</li>
<li>nice的值越大，进程的优先级就越低，获得CPU调用的机会越少，nice值越小，进程的优先级则越高，获得CPU调用的机会越多。</li>
<li>一个nice值为-20的进程优先级最高，nice值为19的进程优先级最低。</li>
<li>父进程fork出来的子进程nice值与父进程相同。父进程renice，子进程nice值不会随之改变。</li>
</ul>


<h3>词源考究</h3>

<p>nice这个命令的来源几乎没有资料提到，于是便尝试自己来推断一下。在诸如词霸，沪江等词典给出的意思均为<code>好的；美好的；可爱的；好心的，友好的</code>。而有道词典则稍微给出了一个其他词典没有的<code>和蔼的</code>。个人认为有道给出的这个比较合理。要想做到和蔼，就需要做到谦让，因此或多或少牺牲自己一点，成全他人。所以nice值越高，越和蔼，但是自己的优先级也会越低。</p>

<h3>renice</h3>

<p>对于一个新的进程我们可以按照下面的代码为一个进程设定nice值。
<code>bash
nice -n 10 adb logcat
</code>
对于已经创建的进程，我们可以使用renice来修改nice值
<code>
sudo renice -n 0 -p 24161
</code>
该命令需要使用root权限，-p对应的值为进程id。</p>

<p>注意renice命令在Linux发行版中-n 的值应该为进程的目标优先级。而Mac下-n，则是代表对当前权限的增加值。
比如在Mac下，讲一个进程的nice值由19改成10，可以这样操作<code>sudo renice -n -9  -p 24161</code>,这一点需要注意，避免掉进坑里。</p>

<h3>Android中的nice</h3>

<p>由于Android基于Linux Kernel，在Android中也存在nice值。但是一般情况下我们无法控制，原因如下：</p>

<ul>
<li>Android系统并不像其他Linux发行版那样便捷地使用nice命令操作。</li>
<li>renice需要root权限，一般应用无法实现。</li>
</ul>


<h2>线程调度</h2>

<p>虽然对于进程的优先级，我们无法控制，但是我们可以控制进程中的线程的优先级。在Android中有两种线程的优先级，一种为Android API版本，另一种是 Java 原生版本。</p>

<h3>Android API</h3>

<p>Android中的线程优先级别目前规定了如下，了解了进程优先级与nice值的关系，那么线程优先级与值之间的关系也就更加容易理解。</p>

<ul>
<li>THREAD_PRIORITY_DEFAULT，默认的线程优先级，值为0。</li>
<li>THREAD_PRIORITY_LOWEST，最低的线程级别，值为19。</li>
<li>THREAD_PRIORITY_BACKGROUND 后台线程建议设置这个优先级，值为10。</li>
<li>THREAD_PRIORITY_FOREGROUND 用户正在交互的UI线程，代码中无法设置该优先级，系统会按照情况调整到该优先级，值为-2。</li>
<li>THREAD_PRIORITY_DISPLAY 也是与UI交互相关的优先级界别，但是要比THREAD_PRIORITY_FOREGROUND优先，代码中无法设置，由系统按照情况调整，值为-4。</li>
<li>THREAD_PRIORITY_URGENT_DISPLAY 显示线程的最高级别，用来处理绘制画面和检索输入事件，代码中无法设置成该优先级。值为-8。</li>
<li>THREAD_PRIORITY_AUDIO 声音线程的标准级别，代码中无法设置为该优先级，值为 -16。</li>
<li>THREAD_PRIORITY_URGENT_AUDIO 声音线程的最高级别，优先程度较THREAD_PRIORITY_AUDIO要高。代码中无法设置为该优先级。值为-19。</li>
<li>THREAD_PRIORITY_MORE_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微优先，值为-1。</li>
<li>THREAD_PRIORITY_LESS_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微落后一些，值为1。</li>
</ul>


<p>使用Android API为线程设置优先级也很简单，只需要在线程执行时调用android.os.Process.setThreadPriority方法即可。这种在线程运行时进行修改优先级，效果类似renice。
```
new Thread () {</p>

<pre><code>@Override
public void run() {
    super.run();
    android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
</code></pre>

<p>}.start();
```</p>

<h3>Java原生API</h3>

<p>Java为Thread提供了三个级别的设置，</p>

<ul>
<li>MAX_PRIORITY，相当于android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY，值为10。</li>
<li>MIN_PRIORITY，相当于android.os.Process.THREAD_PRIORITY_LOWEST，值为0。</li>
<li>NORM_PRIORITY，相当于android.os.Process.THREAD_PRIORITY_DEFAULT，值为5。</li>
</ul>


<p>使用setPriority我们可以为某个线程设置优先级，使用getPriority可以获得某个线程的优先级。</p>

<p>在Android系统中，不建议使用Java原生的API，因为Android提供的API划分的级别更多，更适合在Android系统中进行设定细致的优先级。</p>

<h2>注意</h2>

<p>Android API的线程优先级和Java原生API的优先级是相对独立的，比如使用android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)后，使用Java原生API,Thread.getPriority()得到的值不会改变。如下面代码：
```
new Thread() {</p>

<pre><code>@Override
public void run() {
    super.run();
    Log.i(LOGTAG, "Java Thread Priority Before=" + Thread.currentThread().getPriority());
    Process.setThreadPriority(Process.THREAD_PRIORITY_LOWEST);
    Log.i(LOGTAG, "Java Thread Priority=" + Thread.currentThread().getPriority());
}
</code></pre>

<p>}.start();
<code>
上述代码的运行日志为
</code>
I/MainActivity( 3679): Java Thread Priority Before=5
I/MainActivity( 3679): Java Thread Priority=5
```</p>

<p>由于上面的这一点缺陷，导致我们在分析ANR trace时需要注意，在下面的ANR日志信息中，<code>prio=5</code>中proi的值对应的Java原生API的线程优先级。而<code>nice=-6</code>中的nice表示的Android API版本的线程优先级。</p>

<p><code>
"main" prio=5 tid=1 NATIVE
  | group="main" sCount=1 dsCount=0 obj=0x41690f18 self=0x4167e650
  | sysTid=1765 nice=-6 sched=0/0 cgrp=apps handle=1074196888
  | state=S schedstat=( 0 0 0 ) utm=5764 stm=3654 core=2
  #00  pc 00022624  /system/lib/libc.so (__futex_syscall3+8)
  #01  pc 0000f054  /system/lib/libc.so (__pthread_cond_timedwait_relative+48)
  #02  pc 0000f0b4  /system/lib/libc.so (__pthread_cond_timedwait+64)
</code></p>

<h2>避免ANR</h2>

<p>我在之前的文章<a href="http://droidyue.com/blog/2015/07/18/anr-in-android/">说说Android中的ANR</a>中提到使用WorkerThread处理耗时IO操作，同时将WorkerThread的优先级降低，对于耗时IO操作，比如读取数据库，文件等，我们可以设置该workerThread优先级为THREAD_PRIORITY_BACKGROUND，以此降低与主线程竞争的能力。</p>

<h3>同系列文章</h3>

<ul>
<li><a href="/blog/2015/09/17/android-process-and-thread-schedule-cgroups/?droid_refer=series">剖析Android中进程与线程调度之cgroups</a></li>
</ul>


<p><script type="text/javascript" src="http://droidyue.b0.upaiyun.com/js/blog/book_copyright.js"></script>
<script type="text/javascript">
	showBookCopyright();
</script>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入讲解Android中Activity launchMode]]></title>
    <link href="http://droidyue.com/blog/2015/08/16/dive-into-android-activity-launchmode/"/>
    <updated>2015-08-16T21:22:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/08/16/dive-into-android-activity-launchmode</id>
    <content type="html"><![CDATA[<p>Android系统中的Activity可以说一件很赞的设计，它在内存管理上良好的设计，使得多任务管理在Android系统中运行游刃有余。但是Activity绝非启动展示在屏幕而已，其启动方式也大有学问，本文讲具体介绍Activity的启动模式的诸多细节，纠正一些开发中可能错误的观点，帮助大家深入理解Activity。</p>

<!--more-->


<h2>行文之前</h2>

<p>在正式行文之前，先介绍一些文章提到的概念</p>

<ul>
<li>文章后续会提到Task，这里的Task指的是与用户交互的Activity实例的集合。</li>
<li>Task中的Activity实例以栈的形式存放，这个栈就是Activity的回退栈。</li>
</ul>


<p><strong>本文图片较多，在看图时，请注意观察Activity顶部的title，来区分具体Activity。</strong></p>

<h2>为何有启动模式</h2>

<p>应用中的每一个Activity都是进行不同的事物处理。以邮件客户端为例，InboxActivity目的就是为了展示收件箱，这个Activity不建议创建成多个实例。而ComposeMailActivity则是用来撰写邮件，可以实例化多个此Activity对象。合理地设计Activity对象是否使用已有的实例还是多次创建，会使得交互设计更加良好，也能避免很多问题。至于想要达到前面的目标，就需要使用今天的Activity启动模式。</p>

<h2>如何使用</h2>

<p>使用很简单，只需要在manifest中对应的Activity元素加入<strong>android:launchMode</strong>属性即可。如下述代码
```xml
&lt;activity</p>

<pre><code>android:name=".SingleTaskActivity"
android:label="singleTask launchMode"
android:launchMode="singleTask"&gt;
</code></pre>

<p></activity>
```</p>

<p>接下来就是介绍launchMode的四个值的时刻了。</p>

<h2>standard</h2>

<p>这是launchMode的默认值，Activity不包含android:launchMode或者显示设置为standard的Activity就会使用这种模式。</p>

<p>一旦设置成这个值，<strong>每当有一次Intent请求，就会创建一个新的Activity实例</strong>。举个例子，如果有10个撰写邮件的Intent，那么就会创建10个ComposeMailActivity的实例来处理这些Intent。结果很明显，这种模式会创建某个Activity的多个实例。</p>

<h3>Android 5.0之前的表现</h3>

<p>这种Activity新生成的实例会放入发送Intent的Task的栈的顶部。下图为启动同一程序内的Activity。
<img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/pre_lollipop_standard_activity_in_same_app.jpg">http://7jpolu.com1.z0.glb.clouddn.com/pre_lollipop_standard_activity_in_same_app.jpg</a>" title="pre_lollipop_standard_activity_in_same_app" ></p>

<p>下面的图片展示跨程序之间调用，新生成的Activity实例会放入发送Intent的Task的栈的顶部，尽管它们属于不同的程序。
<img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/pre_lollipop_standard_activity_across_app.jpg">http://7jpolu.com1.z0.glb.clouddn.com/pre_lollipop_standard_activity_across_app.jpg</a>" title="pre_lollipop_standard_activity_across_app" ></p>

<p>但是当我们打开任务管理器，则会有一点奇怪，应为显示的任务是Gallery，展示的界面确实另一个程序的Activity（因为其位于Task的栈顶）。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/pre_lollipop_task_manager_across_app.jpg">http://7jpolu.com1.z0.glb.clouddn.com/pre_lollipop_task_manager_across_app.jpg</a>"></p>

<p>这时候如果我们从Gallery应用切换到拨号应用，再返回到Gallery，看到的还是这个非Gallery的Activity，如果我们想要对Gallery进行操作，必须按Back键返回到Gallery界面才可以。确实有点不太合理。</p>

<h3>Android 5.0及之后表现</h3>

<p>对于同一应用内部Activity启动和5.0之前表现一样，变化的就是不同应用之间Activity启动变得合理了。</p>

<p>跨应用之间启动Activity，会创建一个新的Task，新生成的Activity就会放入刚创建的Task中。如下图</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/lollipop_across_app_new_task.jpg">http://7jpolu.com1.z0.glb.clouddn.com/lollipop_across_app_new_task.jpg</a>"></p>

<p>同时任务管理器查看任务也显得更加合理了。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/lollipop_task_manager_standard.jpg">http://7jpolu.com1.z0.glb.clouddn.com/lollipop_task_manager_standard.jpg</a>"></p>

<p>假设之前存在我们的测试程序，然后从Gallery又分享文件到我们的测试程序，则对应的任务管理器展示效果如下。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/lollipop_standard_across_app_alread_exists.jpg">http://7jpolu.com1.z0.glb.clouddn.com/lollipop_standard_across_app_alread_exists.jpg</a>"></p>

<p>使用场景：standard这种启动模式适合于撰写邮件Activity或者社交网络消息发布Activity。如果你想为每一个intent创建一个Activity处理，那么就是用standard这种模式。</p>

<h2>singleTop</h2>

<p>singleTop其实和standard几乎一样，使用singleTop的Activity也可以创建很多个实例。唯一不同的就是，<strong>如果调用的目标Activity已经位于调用者的Task的栈顶，则不创建新实例，而是使用当前的这个Activity实例，并调用这个实例的onNewIntent方法</strong>。
<img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/singletop.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singletop.jpg</a>">
在singleTop这种模式下，我们需要处理应用这个模式的Activity的onCreate和onNewIntent两个方法，确保逻辑正常。</p>

<h3>使用场景</h3>

<p>关于singleTop一个典型的使用场景就是搜索功能。假设有一个搜索框，每次搜索查询都会将我们引导至SearchActivity查看结果，为了更好的交互体验，我们在结果页顶部也放置这样的搜索框。</p>

<p>假设一下，SearchActivity启动模式为standard，那么每一个搜索都会创建一个新的SearchActivity实例，10次查询就是10个Activity。当我们想要退回到非SearchActivity，我们需要按返回键10次，这显然太不合理了。</p>

<p>但是如果我们使用singleTop的话，如果SearchActivity在栈顶，当有了新的查询时，不再重新创建SearchAc实例，而是使用当前的SearchActivity来更新结果。当我们需要返回到非SearchActivity只需要按一次返回键即可。使用了singleTop显然比之前要合理。</p>

<h3>总结</h3>

<ul>
<li>只有在调用者和目标Activity在同一Task中，并且目标Activity位于栈顶，才使用现有目标Activity实例，否则创建新的目标Activity实例。</li>
<li>如果是外部程序启动singleTop的Activity，在Android 5.0之前新创建的Activity会位于调用者的Task中，5.0及以后会放入新的Task中。</li>
</ul>


<h2>singleTask</h2>

<p>singleTask这个模式和前面提到的standard和singleTop截然不同。<strong>使用singleTask启动模式的Activity在系统中只会存在一个实例</strong>。如果这个实例已经存在，intent就会通过onNewIntent传递到这个Activity。否则新的Activity实例被创建。</p>

<h3>同一程序内</h3>

<p>如果系统中不存在singleTask Activity的实例，那么就需要创建这个Activity的实例，并且将这个实例放入和调用者相同的Task中并位于栈顶。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/singletask_inapp_create_new_instance.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singletask_inapp_create_new_instance.jpg</a>"></p>

<p>如果singleTask Activity实例已然存在，那么在Activity回退栈中，所有位于该Activity上面的Activity实例都将被销毁掉（销毁过程会调用Activity生命周期回调），这样使得singleTask Activity实例位于栈顶。与此同时，Intent会通过onNewIntent传递到这个SingleTask Activity实例。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/singletask_sameapp_instance_exists.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singletask_sameapp_instance_exists.jpg</a>"></p>

<p>然而在Google关于singleTask的<a href="http://developer.android.com/guide/components/tasks-and-back-stack.html">文档</a>有这样一段描述</p>

<blockquote><p>The system creates a new task and instantiates the activity at the root of the new task.</p></blockquote>

<p>意思为 系统会创建一个新的Task，并创建Activity实例放入这个新的Task的底部。</p>

<p>然而实际并非如此，在我的例子中，singleTask Activity并创建并放入了调用者所在的Task，而不是放入新的Task，使用<code>adb shell dumpsys activity</code>便可以进行验证。
```java
Task id #239
  TaskRecord{428efe30 #239 A=com.thecheesefactory.lab.launchmode U=0 sz=2}
  Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=com.thecheesefactory.lab.launchmode/.StandardActivity }</p>

<pre><code>Hist #1: ActivityRecord{429a88d0 u0 com.thecheesefactory.lab.launchmode/.SingleTaskActivity t239}
  Intent { cmp=com.thecheesefactory.lab.launchmode/.SingleTaskActivity }
  ProcessRecord{42243130 18965:com.thecheesefactory.lab.launchmode/u0a123}
Hist #0: ActivityRecord{425fec98 u0 com.thecheesefactory.lab.launchmode/.StandardActivity t239}
  Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=com.thecheesefactory.lab.launchmode/.StandardActivity }
  ProcessRecord{42243130 18965:com.thecheesefactory.lab.launchmode/u0a123}
</code></pre>

<p><code>
然而想要实现文档的描述也并非不可能，我们需要在设置launchMode为singleTask的同时，再加上taskAffinity属性即可。
</code>xml
&lt;activity</p>

<pre><code>android:name=".SingleTaskActivity"
android:label="singleTask launchMode"
android:launchMode="singleTask"
android:taskAffinity=""&gt;
</code></pre>

<p></activity>
```
完成上面的修改，我们看一下效果，Task的变化如下图</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/singleTaskTaskAffinity.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singleTaskTaskAffinity.jpg</a>">
同时，系统中的任务管理器效果也会相应变化</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/singletask_task_affinity_task_manger.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singletask_task_affinity_task_manger.jpg</a>"></p>

<h3>跨应用之间</h3>

<p>在跨应用Intent传递时，如果系统中不存在singleTask Activity的实例，那么讲创建一个新的Task，然后创建SingleTask Activity的实例，将其放入新的Task中。Task变化如下。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/singletask_across_app_no_instance.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singletask_across_app_no_instance.jpg</a>">
系统的任务管理器也会如下变化</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/singletask_acrossapp_no_instance_taskmanager.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singletask_acrossapp_no_instance_taskmanager.jpg</a>"></p>

<p>如果singleTask Activity所在的应用进程存在，但是singleTask Activity实例不存在，那么从别的应用启动这个Activity，新的Activity实例会被创建，并放入到所属进程所在的Task中，并位于栈顶位置。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/singletask_acrossapp_application_exists_activity_nonexists.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singletask_acrossapp_application_exists_activity_nonexists.jpg</a>"></p>

<p>更复杂的一种情况，如果singleTask Activity实例存在，从其他程序被启动，那么这个Activity所在的Task会被移到顶部，并且在这个Task中，位于singleTask Activity实例之上的所有Activity将会被正常销毁掉。如果我们按返回键，那么我们首先会回退到这个Task中的其他Activity，直到当前Task的Activity回退栈为空时，才会返回到调用者的Task。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/singletask_acrossapp_instance_exists_and_back.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singletask_acrossapp_instance_exists_and_back.jpg</a>"></p>

<p>在上图中，当Task2中的相册启动分享调用Task1中的singleTask Activity，而该Activity实例存在，并位于Task1中回退栈中的第三个位置（从上到下顺序），那么位于该Activity上面的两个Activity实例将会被销毁掉，使得该Activity实例位于栈顶。此时Task1中的回退栈只剩两个Activity，如果点击返回，那么会退到的不是相册应用，而是singleTask Activity栈位置下面的Activity，再次点击返回方可返回相册应用。</p>

<h3>使用场景</h3>

<p>该模式的使用场景多类似于邮件客户端的收件箱或者社交应用的时间线Activity。上述两种场景需要对应的Activity只保持一个实例即可，但是也要谨慎使用这种模式，因为它可以在用户未感知的情况下销毁掉其他Activity。</p>

<h2>singleInstance</h2>

<p>这个模式和singleTask差不多，因为他们在系统中都只有一份实例。唯一不同的就是存放singleInstance Activity实例的Task只能存放一个该模式的Activity实例。如果从singleInstance Activity实例启动另一个Activity，那么这个Activity实例会放入其他的Task中。同理，如果singleInstance Activity被别的Activity启动，它也会放入不同于调用者的Task中。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/singleInstance_new_instance.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singleInstance_new_instance.jpg</a>">
虽然是两个task，但是在系统的任务管理器中，却始终显示一个，即位于顶部的Task中。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/singleInstances_taskmanager.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singleInstances_taskmanager.jpg</a>"></p>

<p>另外当我们从任务管理器进入这个应用，是无法通过返回键会退到Task1的。</p>

<p>好在有办法解决这个问题，就是之前提到的<code>taskAffinity=""</code>，为launchMode为singleInstance的Activity加入这个属性即可。
```xml
&lt;activity</p>

<pre><code>android:name=".SingleInstanceActivity"
android:label="singleInstance launchMode"
android:launchMode="singleInstance"
android:taskAffinity=""&gt;
</code></pre>

<p></activity>
```
再次运行修改的代码，查看任务管理器，这样的结果就合理了。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/singleinstance_task_affinity.jpg">http://7jpolu.com1.z0.glb.clouddn.com/singleinstance_task_affinity.jpg</a>"></p>

<h3>使用情况</h3>

<p>这种模式的使用情况比较罕见，在Launcher中可能使用。或者你确定你需要使Activity只有一个实例。建议谨慎使用。</p>

<h2>Intent Flags</h2>

<p>除了在manifest文件中设置launchMode之外，还可以在Intnet中设置flag达到同样的效果。如下述代码就可以让StandardActivity已singleTop模式启动。
<code>java
Intent intent = new Intent(StandardActivity.this, StandardActivity.class);
intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
startActivity(intent);
</code></p>

<p>关于Intent Flags这里暂不做重点介绍，具体可以参考<a href="http://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_BROUGHT_TO_FRONT">官方文档</a></p>

<h2>原文信息</h2>

<ul>
<li><a href="http://inthecheesefactory.com/blog/understand-android-activity-launchmode/en">Understand Android Activity&rsquo;s launchMode: standard, singleTop, singleTask and singleInstance</a></li>
</ul>


<h2>One More Thing</h2>

<p>为了更深刻理解，建议多读几次。如果文章有问题，请在下方评论指出。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[探究android:largeHeap]]></title>
    <link href="http://droidyue.com/blog/2015/08/01/dive-into-android-large-heap/"/>
    <updated>2015-08-01T17:10:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/08/01/dive-into-android-large-heap</id>
    <content type="html"><![CDATA[<p>在日常的Android开发中，我们必然遇到过OutOfMemoryError这样的崩溃，产生的原因无外乎两点，一是内存过小不够用，二是程序设计有误，导致不能释放内存，其中后者情况较多。在解决这个问题时，我们亦或多或少听到android:largeHeap，然而这个概念又是什么呢，它该如何使用，存在哪些问题呢。本文讲比较全面介绍Android中的largeHeap帮助各位全面深入了解这个概念。</p>

<!--more-->


<h2>磨刀不误砍柴工</h2>

<p>为了便于理解，先简单介绍一些和文章相关的基础概念。</p>

<ul>
<li>通常，一个Android程序在运行时会启动一个Dalvik虚拟机（暂不讨论ART模式）</li>
<li>虚拟机的运行时内存一般由堆和栈两大部分构成。</li>
<li>栈是存储方法调用的一片内存数据区。</li>
<li>堆内存占据了虚拟机的大部分内存空间，程序执行时产生的对象就分配在堆内存上。</li>
<li>如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。</li>
</ul>


<p>如若具体了解堆和栈，请参考文章<a href="http://droidyue.com/blog/2014/12/07/differences-between-stack-and-heap-in-java/">Java中的堆和栈的区别</a>和<a href="http://droidyue.com/blog/2014/12/21/java-runtime-data-areas/">JVM运行时的数据区</a></p>

<h2>largeHeap介绍</h2>

<p>一个应用如果使用了largeHeap，会请求系统为Dalvik虚拟机分配更大的内存空间。使用起来也很方便，只需在manifest文件application节点加入<strong>android:largeHeap=&ldquo;true&rdquo;</strong>即可。
```xml
&lt;application android:icon=&ldquo;@drawable/icon&rdquo;</p>

<pre><code>android:allowBackup="false"
android:label="@string/app_name" 
android:debuggable="true" 
android:theme="@android:style/Theme.Black"
android:largeHeap="true"
</code></pre>

<blockquote><p>```</p></blockquote>

<h2>largeHeap有多大</h2>

<p>在Android中，有如下两个方法可以帮助我们查看当前内存大小</p>

<ul>
<li>ActivityManager.getMemoryClass()获得内用正常情况下内存的大小</li>
<li>ActivityManager.getLargeMemoryClass()可以获得开启largeHeap最大的内存大小</li>
</ul>


<p>然而largeHeap这个最大值是如何决定的呢？想要了解这个问题，我们就需要看一下Android系统中的一个文件。</p>

<p>这个文件路径是<code>/system/build.prop</code>，由于文件比较大，这里我们只截取关于dalvik内存的配置信息，如下。
<code>java
dalvik.vm.heapstartsize=8m
dalvik.vm.heapgrowthlimit=192m
dalvik.vm.heapsize=512m
dalvik.vm.heaptargetutilization=0.75
dalvik.vm.heapminfree=2m
dalvik.vm.heapmaxfree=8m
</code></p>

<p>上面有诸多配置，但从字面意思也不难理解，为了正确理解，有必要逐一解释一下。</p>

<p><strong>dalvik.vm.heapstartsize=8m</strong></p>

<p>相当于虚拟机的 -Xms配置，该项用来设置堆内存的初始大小。</p>

<p><strong>dalvik.vm.heapgrowthlimit=192m</strong></p>

<p>相当于虚拟机的 -XX:HeapGrowthLimit配置，该项用来设置一个标准的应用的最大堆内存大小。一个标准的应用就是没有使用android:largeHeap的应用。</p>

<p><strong>dalvik.vm.heapsize=512m</strong></p>

<p>相当于虚拟机的 -Xmx配置，该项设置了使用android:largeHeap的应用的最大堆内存大小。</p>

<p><strong>dalvik.vm.heaptargetutilization=0.75</strong></p>

<p>相当于虚拟机的 -XX:HeapTargetUtilization,该项用来设置当前理想的堆内存利用率。其取值位于0与1之间。当GC进行完垃圾回收之后，Dalvik的堆内存会进行相应的调整，通常结果是当前存活的对象的大小与堆内存大小做除法，得到的值为这个选项的设置，即这里的0.75。注意，这只是一个参考值，<a href="http://grepcode.com/file/repo1.maven.org/maven2/org.robovm/robovm-rt/1.0.0/dalvik/system/VMRuntime.java#VMRuntime.setTargetHeapUtilization%28float%29">Dalvik虚拟机也可以忽略此设置</a>。</p>

<p><strong>dalvik.vm.heapminfree=2m</strong>与<strong>dalvik.vm.heapmaxfree=8m</strong></p>

<p>dalvik.vm.heapminfree对应的是-XX:HeapMinFree配置，用来设置单次堆内存调整的最小值。<strong>dalvik.vm.heapmaxfree</strong>对应的是-XX:HeapMaxFree配置，用来设置单次堆内存调整的最大值。通常情况下，还需要结合上面的 -XX:HeapTargetUtilization的值，才能确定内存调整时，需要调整的大小。</p>

<h2>largeHeap需要权限么</h2>

<p>为何有此疑问呢？ 原因是这样的。 首先一个设备的内存是固定的，当我们使用了largeHeap之后就可以使我们的程序内存增加，但这部分增加的内存有可能是源自被系统杀掉的后台程序。所以，使用largeHeap理论上是有可能杀掉其他的程序的。</p>

<p>然而，结果就是不需要权限，Google在一开始就是这样，只需要简单在Application元素上加入android:largeHeap=&ldquo;true"就能正常使用。</p>

<h2>largeHeap对GC的影响</h2>

<p>拥有了更多的内存，是不是就意味着要花更多的时间遍历对象垃圾回收呢？其实不然。</p>

<p>首先largeHeap自Android 4.0开始支持，而并发的垃圾回收方式从Android 2.3开始引入。</p>

<p>在引入并发垃圾回收之前，系统采用了Stop-the-World回收方式，进行一次垃圾回收通常消耗几百毫秒，这是很影响交互和响应的。</p>

<p>引入并发垃圾回收之后,在GC开始和结束的阶段会有短暂的暂停时间，通常在10毫秒以内。</p>

<p>因此在支持largeHeap的系统上都采用了并发垃圾回收，GC的Pause Time不会很长，对交互响应影响甚微。</p>

<h2>慎用largeHeap</h2>

<p>对于largeHeap的使用，我们该持有的谨慎的态度，largeHeap可以使用，但是要谨慎。</p>

<p>对于本身对内存要求过大的图片或者视频应用，我们可以使用largeHeap。</p>

<p>除上面的情况，如果仅仅是为了解决OutOfMemoryError这样的问题，而尝试使用largeHeap分配更大内存的这种指标不治本的方法不可取。对待这样的OOM问题，建议阅读以下几篇文章，了解Android中内存泄露和垃圾回收，从代码上去查找问题，从根本上解决问题。</p>

<h2>推荐文章</h2>

<ul>
<li><a href="http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur/">Android中Handler引起的内存泄露</a></li>
<li><a href="http://droidyue.com/blog/2015/04/12/avoid-memory-leaks-on-context-in-android/">避免Android中Context引起的内存泄露</a></li>
<li><a href="http://droidyue.com/blog/2014/11/02/note-for-google-io-memory-management-for-android-chinese-edition/">Google IO：Android内存管理主题演讲记录</a></li>
</ul>


<p><script type="text/javascript" src="http://droidyue.b0.upaiyun.com/js/blog/book_copyright.js"></script>
<script type="text/javascript">
	showBookCopyright();
</script>
</p>
]]></content>
  </entry>
  
</feed>
