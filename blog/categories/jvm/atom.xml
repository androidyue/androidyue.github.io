<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JVM | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/jvm/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2016-01-24T16:14:24+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入探索Java 8 Lambda表达式]]></title>
    <link href="http://droidyue.com/blog/2015/11/28/article-java-8-lambdas-a-peek-under-the-hood/"/>
    <updated>2015-11-28T19:05:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/11/28/article-java-8-lambdas-a-peek-under-the-hood</id>
    <content type="html"><![CDATA[<h2>版权说明</h2>

<p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/Java-8-Lambdas-A-Peek-Under-the-Hood">http://www.infoq.com/cn/articles/Java-8-Lambdas-A-Peek-Under-the-Hood</a>。如需转载，请与 InfoQ 中文站联系。</p>

<h2>正文</h2>

<p>2014年3月，Java 8发布，Lambda表达式作为一项重要的特性随之而来。或许现在你已经在使用Lambda表达式来书写简洁灵活的代码。比如，你可以使用Lambda表达式和新增的流相关的API，完成如下的大量数据的查询处理：
```
int total = invoices.stream()</p>

<pre><code>                .filter(inv -&gt; inv.getMonth() == Month.JULY)
                .mapToInt(Invoice::getAmount)
                .sum();
</code></pre>

<p>```
上面的示例代码描述了如何从一打发票中计算出7月份的应付款总额。其中我们使用Lambda表达式过滤出7月份的发票，使用方法引用来提取出发票的金额。</p>

<!--more-->


<p>到这里，你可能会对Java编译器和JVM内部如何处理Lambda表达式和方法引用比较好奇。可能会提出这样的问题，Lambda表达式会不会就是匿名内部类的语法糖呢？毕竟上面的示例代码可以使用匿名内部类实现，将Lambda表达式的方法体实现移到匿名内部类对应的方法中即可，但是我们并不赞成这样做。如下为匿名内部类实现版本：
```
int total = invoices.stream()</p>

<pre><code>                .filter(new Predicate&lt;Invoice&gt;() {
                    @Override
                    public boolean test(Invoice inv) {
                        return inv.getMonth() == Month.JULY;
                    }
                })
                .mapToInt(new ToIntFunction&lt;Invoice&gt;() {
                    @Override
                    public int applyAsInt(Invoice inv) {
                        return inv.getAmount();
                    }
                })
                .sum();
</code></pre>

<p>```</p>

<p>本文将会介绍为什么Java编译器没有采用内部类的形式处理Lambda表达式，并解密Lambda表达式和方法引用的内部实现。接着介绍字节码生成并简略分析Lambda表达式理论上的性能。最后，我们将讨论一下实践中Lambda表达式的性能问题。</p>

<h2>为什么匿名内部类不好？</h2>

<p>实际上，匿名内部类存在着影响应用性能的问题。</p>

<p>首先，编译器会为每一个匿名内部类创建一个类文件。创建出来的类文件的名称通常按照这样的规则 ClassName$1， 其中ClassName就是匿名内部类定义所属的类的名称，ClassName后面需要接上$符合和数字。生成如此多的文件就会带来问题，因为类在使用之前需要加载类文件并进行验证，这个过程则会影响应用的启动性能。类文件的加载很有可能是一个耗时的操作，这其中包含了磁盘IO和解压JAR文件。</p>

<p>假设Lambda表达式翻译成匿名内部类，那么每一个Lambda表达式都会有一个对应的类文件。随着匿名内部类进行加载，其必然要占用JVM中的元空间（从Java 8开始永久代的一种替代实现）。如果匿名内部类的方法被JIT编译成机器代码，则会存储到代码缓存中。同时，匿名内部类都需要实例化成独立的对象。以上关于匿名内部类的种种会使得应用的内存占用增加。因此我们有必要引入新的缓存机制减少过多的内存占用，这也就意味着我们需要引入某种抽象层。</p>

<p>最重要的，一旦Lambda表达式使用了匿名内部类实现，就会限制了后续Lambda表达式实现的更改，降低了其随着JVM改进而改进的能力。</p>

<p>我们看一下下面的这段代码：
```
import java.util.function.Function;
public class AnonymousClassExample {</p>

<pre><code>Function&lt;String, String&gt; format = new Function&lt;String, String&gt;() {
    public String apply(String input){
        return Character.toUpperCase(input.charAt(0)) + input.substring(1);
    }
};
</code></pre>

<p>}
<code>
使用这个命令我们可以检查任何类文件生成的字节码
</code>
javap -c -v ClassName
<code>
示例中使用Function创建的匿名内部类对应的字节码如下：
</code>
0: aload_0     <br/>
1: invokespecial #1 // Method java/lang/Object.&ldquo;<init>&rdquo;:()V
4: aload_0     <br/>
5: new           #2 // class AnonymousClassExample$1
8: dup         <br/>
9: aload_0     <br/>
10: invokespecial #3 // Method AnonymousClass$1.&ldquo;<init>&rdquo;:(LAnonymousClassExample;)V
13: putfield      #4 // Field format:Ljava/util/function/Function;
16: return<br/>
```
上述字节码的含义如下：</p>

<ul>
<li>第5行，使用字节码操作new创建了类型AnonymousClassExample$1的一个对象，同时将新创建的对象的的引用压入栈中。</li>
<li>第8行，使用dup操作复制栈上的引用。</li>
<li>第10行，上面的复制的引用被指令invokespecial消耗使用，用来初始化匿名内部类实例。</li>
<li>第13行，栈顶依旧是创建的对象的引用，这个引用通过putfield指令保存到AnonymousClassExample类的format属性中。</li>
</ul>


<p>AnonymousClassExample$1就是由编译器生成的匿名内部类的名称。如果想更加验证的话，你可以检查AnonymousClassExample$1这个类文件，你会发现这个类就是Function接口的实现。</p>

<p>将Lambda表达式翻译成匿名内部类会限制以后可能进行的优化（比如缓存）。因为一旦使用了翻译成匿名内部类形式，那么Lambda表达式则和匿名内部类的字节码生成机制绑定。因而，Java语言和JVM工程师需要设计一个稳定并且具有足够信息的二进制表示形式来支持以后的JVM实现策略。下面的部分将介绍不使用匿名内部类机制，Lambda表达式是如何工作的。</p>

<h2>Lambdas表达式和invokedynamic</h2>

<p>为了解决前面提到的担心，Java语言和JVM工程师决定将翻译策略推迟到运行时。利用Java 7引入的invokedynamic字节码指令我们可以高效地完成这一实现。将Lambda表达式转化成字节码只需要如下两步：</p>

<p>1.生成一个invokedynamic调用点，也叫做Lambda工厂。当调用时返回一个Lambda表达式转化成的<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html">函数式接口</a>实例。</p>

<p>2.将Lambda表达式的方法体转换成方法供invokedynamic指令调用。</p>

<p>为了阐明上述的第一步，我们这里举一个包含Lambda表达式的简单类：
```
import java.util.function.Function;</p>

<p>public class Lambda {</p>

<pre><code>Function&lt;String, Integer&gt; f = s -&gt; Integer.parseInt(s);
</code></pre>

<p>}
<code>
查看上面的类经过编译之后生成的字节码：
</code>
0: aload_0
1: invokespecial #1 // Method java/lang/Object.&ldquo;<init>&rdquo;:()V
4: aload_0
5: invokedynamic #2, 0 // InvokeDynamic</p>

<pre><code>              #0:apply:()Ljava/util/function/Function;
</code></pre>

<p>10: putfield #3 // Field f:Ljava/util/function/Function;
13: return
```
需要注意的是，方法引用的编译稍微有点不同，因为javac不需要创建一个合成的方法，javac可以直接访问该方法。</p>

<p>Lambda表达式转化成字节码的第二步取决于Lambda表达式是否为对变量捕获。Lambda表达式方法体需要访问外部的变量则为对变量捕获，反之则为对变量不捕获。</p>

<p>对于不进行变量捕获的Lambda表达式，其方法体实现会被提取到一个与之具有相同签名的静态方法中，这个静态方法和Lambda表达式位于同一个类中。比如上面的那段Lambda表达式会被提取成类似这样的方法：
```
static Integer lambda$1(String s) {</p>

<pre><code>return Integer.parseInt(s);
</code></pre>

<p>}
```
需要注意的是，这里的$1并不是代表内部类，这里仅仅是为了展示编译后的代码而已。</p>

<p>对于捕获变量的Lambda表达式情况有点复杂，同前面一样Lambda表达式依然会被提取到一个静态方法中，不同的是被捕获的变量同正常的参数一样传入到这个方法中。在本例中，采用通用的翻译策略预先将被捕获的变量作为额外的参数传入方法中。比如下面的示例代码：
<code>
int offset = 100;
Function&lt;String, Integer&gt; f = s -&gt; Integer.parseInt(s) + offset;
</code>
对应的翻译后的实现方法为：
```
static Integer lambda$1(int offset, String s) {</p>

<pre><code>return Integer.parseInt(s) + offset;
</code></pre>

<p>}
```</p>

<p>需要注意的是编译器对于Lambda表达式的翻译策略并非固定的，因为这样invokedynamic可以使编译器在后期使用不同的翻译实现策略。比如，被捕获的变量可以放入数组中。如果Lambda表达式用到了类的实例的属性，其对应生成的方法可以是实例方法，而不是静态方法，这样可以避免传入多余的参数。</p>

<h2>性能分析</h2>

<p>Lambda表达式最主要的优势表现在性能方面，虽然使用它很轻松的将很多行代码缩减成一句，但是其内部实现却不这么简单。下面对内部实现的每一步进行性能分析。</p>

<p>第一步就是连接，对应的就是我们上面提到的Lambda工厂。这一步相当于匿名内部类的类加载过程。来自Oracle的Sergey Kuksenko发布过相关的<a href="http://www.google.com/url?q=http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Fjvmls2013kuksen-2014088.pdf&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNEvk_uT2Gf5fi6oU2cBm29FJ9X0ZA">性能报告</a>，并且他也在2013 <a href="https://www.google.com/url?q=https%3A%2F%2Fmedianetwork.oracle.com%2Fvideo%2Fplayer%2F2623576348001&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHq8XfMibI94INM3Zl8UGzk-kKbew">JVM语言大会</a>就该话题做过<a href="http://www.oracle.com/technetwork/java/jvmls2013kuksen-2014088.pdf">分享</a>。报告表明，Lambda工厂的预热准备需要消耗时间，并且这个过程比较慢。伴随着更多的调用点连接，代码被频繁调用后（比如被JIT编译优化）性能会提升。另一方面如果连接处于不频繁调用的情况，那么Lambda工厂方式也会比匿名内部类加载要快，最高可达100倍。</p>

<p>第二步就是捕获变量。正如我们前面提到的，如果是不进行捕获变量，这一步会自动进行优化，避免在基于Lambda工厂实现下额外创建对象。对于匿名内部类而言，这一步对应的是创建外部类的实例，为了优化内部类这一步的问题，我们需要手动的修改代码，如创建一个对象，并将它设置给一个静态的属性。如下述代码：
```java
// Hoisted Function
public static final Function&lt;String, Integer> parseInt = new Function&lt;String, Integer>() {</p>

<pre><code>public Integer apply(String arg) {
    return Integer.parseInt(arg);
}
</code></pre>

<p>};</p>

<p>// Usage:
int result = parseInt.apply(“123”);
```</p>

<p>第三部就是真实方法的调用。在这一步中匿名内部类和Lambda表达式执行的操作相同，因此没有性能上的差别。不进行捕获的Lambda表达式要比进行static优化过的匿名内部类较优。进行变量捕获的Lambda表达式和匿名内部类表达式性能大致相同。</p>

<p>在这一节中，我们明显可以看到Lambda表达式的实现表现良好，匿名内部类通常需要我们手动的进行优化来避免额外对象生成，而对于不进行变量捕获的Lambda表达式，JVM已经为我们做好了优化。</p>

<h2>实践中的性能分析</h2>

<p>理解了Lambda的性能模型很是重要，但是实际应用中的总体性能如何呢？我们在使用Java 8 编写了一些软件项目，一般都取得了很好的效果。非变量捕获的Lambda表达式给我们带来了很大的帮助。这里有一个很特殊的例子描述了关于优化方向的一些有趣的问题。</p>

<p>这个例子的场景是代码需要运行在一个要求GC暂定时间越少越好的系统上。因而我们需要避免创建大量的对象。在这个工程中，我们使用了大量的Lambda表达式来实现回调处理。然而在这些使用Lambda实现的回调中很多并没有捕获局部变量，而是需要引用当前类的变量或者调用当前类的方法。然而目前仍需要对象分配。下面就是我们提到的例子的代码：
```java
public MessageProcessor() {}</p>

<p>public int processMessages() {</p>

<pre><code>return queue.read(obj -&gt; {
    if (obj instanceof NewClient) {
        this.processNewClient((NewClient) obj);
    } 
    ...
});
</code></pre>

<p>}
```</p>

<p>有一个简单的办法解决这个问题，我们将Lambda表达式的代码提前到构造方法中，并将其赋值给一个成员属性。在调用点我们直接引用这个属性即可。下面就是修改后的代码：
```java
private final Consumer<Msg> handler;</p>

<p>public MessageProcessor() {</p>

<pre><code>handler = obj -&gt; {
    if (obj instanceof NewClient) {
        this.processNewClient((NewClient) obj);
    }
    ...
};
</code></pre>

<p>}</p>

<p>public int processMessages() {</p>

<pre><code>return queue.read(handler);
</code></pre>

<p>}
```
然而上面的修改后代码给却给整个工程带来了一个严重的问题：性能分析表明，这种修改产生很大的对象申请，其产生的内存申请在总应用的60%以上。</p>

<p>类似这种无关上下文的优化可能带来其他问题。</p>

<p>  1.纯粹为了优化的目的，使用了非惯用的代码写法，可读性会稍差一些。<br/>
  2.内存分配方面的问题，示例中为MessageProcessor增加了一个成员属性，使得MessageProcessor对象需要申请更大的内存空间。Lambda表达式的创建和捕获位于构造方式中，使得MessageProcessor的构造方法调用缓慢一些。</p>

<p>我们遇到这种情况，需要进行内存分析，结合合理的业务用例来进行优化。有些情况下，我们使用成员属性确保为经常调用的Lambda表达式只申请一个对象，这样的缓存策略大有裨益。任何性能调优的科学的方法都可以进行尝试。</p>

<p>上述的方法也是其他程序员对Lambda表达式进行优化应该使用的。书写整洁，简单，函数式的代码永远是第一步。任何优化，如上面的提前代码作为成员属性，都必须结合真实的具体问题进行处理。变量捕获并申请对象的Lambda表达式并非不好，就像我们我们写出<code>new Foo()</code>代码并非一无是处一样。</p>

<p>除此之外，我们想要写出最优的Lambda表达式，常规书写很重要。如果一个Lambda表达式用来表示一个简单的方法，并且没有必要对上下文进行捕获，大多数情况下，一切以简单可读即可。</p>

<h2>总结</h2>

<p>在这片文章中，我们研究了Lambda表达式不是简单的匿名内部类的语法糖，为什么匿名内部类不是Lambda表达式的内部实现机制以及Lambda表达式的具体实现机制。对于大多数情况来说，Lambda表达式要比匿名内部类性能更优。然而现状并非完美，基于测量驱动优化，我们仍然有很大的提升空间。</p>

<p>Lambda表达式的这种实现形式并非Java 8 所有。Scala曾经通过生成匿名内部类的形式支持Lambda表达式。在Scala 2.12版本，Lambda的实现形式替换为Java 8中的Lambda 工厂机制。后续其他可以在JVM上运行的语言也可能支持Lambda的这种机制。</p>

<h2>关于作者</h2>

<p>Richard Warburton是一位资深专家，善于技术攻坚。最近，他写了一个关于<a href="http://tinyurl.com/java8lambdas">Java 8 Lambda表达式</a>的书，由O'Reilly出版，同时他也在<a href="http://java8training.com/">java8training</a>网站为Java程序员教授函数式编程。他涉猎的领域相当广泛，如数据分析，静态分析，编译器和网络协议等领域。他是伦敦Java协会的Leader，并举办OpenJdk hack活动。他进行了多次演讲，曾在Devoxx, JavaOne, JFokus, Devoxx UK, Geecon, Oredev, JAX London 和 Codemotion等会议做分享。除上述之外，他还是Warwick大学的计算机科学博士。</p>

<p>Raoul-Gabriel Urma是剑桥大学计算机科学的博士生。他也是Manning出版社出版的<a href="http://manning.com/urma/">Java 8 in Action: Lambdas, streams, and functional-style programming</a>的联合作者。他发表过10多篇论文，也在国际会议做过20多场分享。他既在诸如Google，eBay，Oracle和Goldman Sachs这样的大公司工作过，也参与过小的创业公司。Raoul也是皇家艺术协会的一员。他的Twitter是@raoulUK。</p>

<p>Mario Fusco是来自Red Hat的高级软件工程师，他的工作是开发Drools核心开发和JBoss规则引擎。他有着相当丰富的Java经验，参与并领导了很多业界企业级的项目。他的兴趣是函数式编程和领域专用语言。由于对着两项的热爱，他创建了一个叫做lambdaj的开源库，目的是提供一个管理集合的Java DSL实现，使得使用更加函数式编码化。他的Twitter ID是@mariofusco。</p>

<p><strong>查看英文原文：</strong><a href="http://www.infoq.com/articles/Java-8-Lambdas-A-Peek-Under-the-Hood">Java 8 Lambdas &ndash; A Peek Under the Hood</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你的Java代码对JIT编译友好么？]]></title>
    <link href="http://droidyue.com/blog/2015/09/12/is-your-java-code-jit-friendly/"/>
    <updated>2015-09-12T18:16:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/09/12/is-your-java-code-jit-friendly</id>
    <content type="html"><![CDATA[<h2>版权说明</h2>

<p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/Java-Application-Hostile-to-JIT-Compilation">你的Java代码对JIT编译友好么？</a>。如需转载，请与 InfoQ 中文站联系。</p>

<h2>摘要</h2>

<p>在JVM中，即时编译器（以下简称JIT）是很重要的一部分，可以帮助应用大幅度提升执行效率。但是很多程序却并不能很好地利用JIT的高性能优化能力。本文中，我们将通过研究一些简单的例子找出程序代码对JIT不友好的问题。</p>

<!--more-->


<p>JIT编译器是Java虚拟机（以下简称JVM）中效率最高并且最重要的组成部分之一。但是很多的程序并没有充分利用JIT的高性能优化能力，很多开发者甚至也并不清楚他们的程序有效利用JIT的程度。</p>

<p>在本文中，我们将介绍一些简单的方法来验证你的程序是否对JIT友好。这里我们并不打算覆盖诸如JIT编译器工作原理这些细节。只是提供一些简单基础的检测和方法来帮助你的代码对JIT友好，进而得到优化。</p>

<p>JIT编译的关键一点就是JVM会自动地监控正在被解释器执行的方法。一旦某个方法被视为频繁调用，这个方法就会被标记，进而编译成本地机器指令。这些频繁执行的方法的编译由后台的一个JVM线程来完成。在编译完成之前，JVM会执行这个方法的解释执行版本。一旦该方法编译完成，JVM会使用将方法调度表中该方法的解释的版本替换成编译后的版本。</p>

<p>Hotspot虚拟机有很多JIT编译优化的技术，但是其中最重要的一个优化技术就是内联。在内联的过程中，JIT编译器有效地将一个方法的方法体提取到其调用者中，从而减少虚方法调用。举个例子，看如下的代码：
```
public int add(int x, int y) {</p>

<pre><code>return x + y;
</code></pre>

<p>}</p>

<p>int result = add(a, b);
<code>
当内联发生之后，上述代码会变成
</code>
int result = a + b;
```</p>

<p>上面的变量a和b替换了方法的参数，并且add方法的方法体已经复制到了调用者的区域。使用内联可以为程序带来很多好处，比如
  * 不会引起额外的性能损失
  * 减少指针的间接引用
  * 不需要对内联方法进行虚方法查找</p>

<p>另外，通过将方法的实现复制到调用者中，JIT编译器处理的代码增多，使得后续的优化和更多的内联成为可能。</p>

<p>内联取决于方法的大小。缺省情况下，含有35个字节码或更少的方法可以进行内联操作。对于被频繁调用的方法，临界值可以达到325个字节。我们可以通过设置-XX:MaxInlineSize=# 选项来修改最大的临界值，通过设置‑XX:FreqInlineSize=#选项来修改频繁调用的方法的临界值。但是在没有正确的分析的情况下，我们不应该修改这些配置。因为盲目地修改可能会对程序的性能带来不可预料的影响。</p>

<p>由于内联会对代码的性能有大幅提升，因此让尽可能多的方法达到内联条件尤为重要。这里我们介绍一款叫做Jarscan的工具来帮助我们检测程序中有多少方法是对内联友好的。</p>

<p>Jarscan工具是分析JIT编译的JITWatch开源工具套件中的一部分。和在运行时分析JIT日志的主工具不同，Jarscan是一款静态分析jar文件的工具。该工具的输出结果格式为CSV，结果中包含了超过频繁调用方法临界值的方法等信息。JITWatch和Jarscan是AdoptOpenJDK工程的一部分，该工程由Chris Newland领导。</p>

<p>在使用Jarscan并得到分析结果之前，需要从AdoptOpenJDK Jenkins网站下载二进制工具（<a href="https://adopt-openjdk.ci.cloudbees.com/job/jitwatch/jdk=JDK_1.7/ws/lastSuccessfulBuild/artifact/jitwatch-1.0.0-SNAPSHOT-JDK_1.7.tar.gz">Java 7 工具</a>，<a href="https://adopt-openjdk.ci.cloudbees.com/job/jitwatch/jdk=OpenJDK8/ws/lastSuccessfulBuild/artifact/jitwatch-1.0.0-SNAPSHOT-OpenJDK8.tar.gz">Java 8 工具</a>）。</p>

<p>运行很简单，如下所示
<code>
./jarScan.sh &lt;jars to analyse&gt;
</code>
更多关于Jarscan的细节可以访问<a href="https://github.com/AdoptOpenJDK/jitwatch/wiki/JarScan">AdoptOpenJDK wiki</a>进行了解。</p>

<p>上面产生的报告对于开发团队的开发工作很有帮助，根据报告结果，他们可以查找程序中是否包含了过大而不能JIT编译的关键路径方法。上面的操作依赖于手动执行。但是为了以后的自动化，可以开启Java的-XX:+PrintCompilation 选项。开启这个选项会生成如下的日志信息：
<code>
37    1      java.lang.String::hashCode (67 bytes)
124   2  s!  java.lang.ClassLoader::loadClass  (58 bytes)
</code>
其中，第一列表示从进程启动到JIT编译发生经过的时间，单位为毫秒。第二列表示的是编译id，表明该方法正在被编译（在Hotspot中一个方法可以多次去优化和再优化）。第三列表示的是附加的一些标志信息，比如s代表synchronized，！代表有异常处理。最后两列分别代表正在编译的方法名称和该方法的字节大小。</p>

<p>关于PrintCompilation输出的更多细节，Stephen Colebourne写过一篇博客文章详细介绍日志结果中各列的具体含义，感兴趣的可以访问<a href="http://blog.joda.org/2011/08/printcompilation-jvm-flag.html">这里</a>阅读。</p>

<p>PrintCompilation的输出结果会提供运行时正在编译的方法的信息，Jarscan工具的输出结果可以告诉我们哪些方法不能进行JIT编译。结合两者，我们就可以清楚地知道哪些方法进行了编译，哪些没有进行。另外，PrintCompilation选项可以在线上环境使用，因为开启这个选项几乎不会影响JIT编译器的性能。</p>

<p>但是，PrintCompilation也存在着两个小问题，有时候会显得不是那么方便：</p>

<p>  1.输出的结果中未包含方法的签名，如果存在重载方法，区分起来则比较困难。<br/>
  2.Hotspot虚拟机目前不能将结果输出到单独的文件中，目前只能是以标准输出的形式展示。</p>

<p>上述的第二个问题的影响在于PrintCompilation的日志会和其他常用的日志混在一起。对于大多数服务器端程序来说，我们需要一个过滤进程来将PrintCompilation的日志过滤到一个独立的日志中。最简单的判断一个方法否是JIT友好的途径就是遵循下面这个简单的步骤：</p>

<p>  1.确定程序中位于要处理的关键路径上的方法。<br/>
  2.检查这些方法没有出现在Jarscan的输出结果中。<br/>
  3.检查这些方法确实出现在了PrintCompilation的输出结果中。</p>

<p>如果一个方法超过了内联的临界值，大多数情况下最常用的方法就是讲这个重要的方法拆分成多个可以进行内联的小方法，这样修改之后通常会获取更好的执行效率。但是对于所有的性能优化而言，优化之前的执行效率需要测量记录，并且需要需要同优化后的数据进行对比之后，才能决定是否进行优化。为了性能优化而做出的改变不应该是盲目的。</p>

<p>几乎所有的Java程序都依赖大量的提供关键功能的库。Jarscan可以帮助我们检测哪些库或者框架的方法超过了内联的临界值。举一个具体的例子，我们这里检查JVM主要的运行时库 rt.jar文件。</p>

<p>为了让结果有点意思，我们分别比较Java 7 和Java 8，并查看这个库的变化。在开始之前我们需要安装Java 7 和 Java8 JDK。首先，我们分别运行Jarscan扫描各自的rt.jar文件，并得到用来后续分析的报告结果：
```</p>

<pre><code>$ ./jarScan.sh /Library/Java/JavaVirtualMachines/jdk1.7.0_71.jdk/Contents/Home/jre/lib/rt.jar
</code></pre>

<blockquote><p>large_jre_methods_7u71.txt</p>

<pre><code>$ ./jarScan.sh /Library/Java/JavaVirtualMachines/jdk1.8.0_25.jdk/Contents/Home/jre/lib/rt.jar
</code></pre>

<p>large_jre_methods_8u25.txt
<code>
上述操作结束之后，我们得到两个CSV文件，一个是JDK 7u71的结果，另一个是JDK 8u25。然后我们看一看不同的版本内联情况有哪些变化。首先，一个最简单的判断验证方式，看一看不同版本的JRE中有多少对JIT不友好的方法。
</code>
 $ wc -l large_jre_methods_*
 3684 large_jre_methods_7u71.txt
 3576 large_jre_methods_8u25.txt
<code>
我们可以看到，相比Java 7，Java 8 少了100多个内联不友好的方法。下面继续深入研究，看看一些关键的包的变化。为了便于理解如何操作，我们再次介绍一下Jarscan的输出结果。Jarscan的输出结果有如下3个属性组成：
</code>
 &ldquo;<package>&rdquo;,&ldquo;<method name and signature>&rdquo;,<num of bytes>
<code>
了解了上述的格式，我们可以利用一些Unix文本处理的工具来研究报告结果。比如，我们想看一下Java 7 和 Java 8 这两个版本中java.lang包下哪些方法变得内联友好了：
</code>
 $ cat large_jre_methods_7u71.txt large_jre_methods_8u25.txt | grep -i
  ^\&ldquo;java.lang | sort | uniq -c
```</p></blockquote>

<p>上面的语句使用grep命令过滤出每份报告中以java.lang开头的行，即只显示位于包java.lang中的类的内联不友好的方法。sort | uniq -c 是一个比较老的Unix小技巧，首先将讲行信息进行排序（相同的信息将聚集到一起），然后对上面的排序数据进行去重操作。另外本命令还会统计一个当前行信息重复的次数，这个数据位于每一行信息的最开始部分。让我们看一下上述命令的执行结果：
<code>
$ cat large_jre_methods_7u71.txt large_jre_methods_8u25.txt | grep -i ^\"java.lang | sort | uniq -c
2 "java.lang.CharacterData00","int getNumericValue(int)",835
2 "java.lang.CharacterData00","int toLowerCase(int)",1339
2 "java.lang.CharacterData00","int toUpperCase(int)",1307
// ... skipped output
2 "java.lang.invoke.DirectMethodHandle","private static java.lang.invoke.LambdaForm makePreparedLambdaForm(java.lang.invoke.MethodType,int)",613
1 "java.lang.invoke.InnerClassLambdaMetafactory","private java.lang.Class spinInnerClass()",497
// ... more output ----
</code></p>

<p>报告中，以2（这是使用了uniq -c 对相同的信息计算数量的结果）最为起始的条目说明这些方法在Java 7 和Java 8 中起字节码大小没有改变。虽然这并不能完全肯定地说明这些方法的字节码没有改变，但通常我们也可以视为没有改变。重复次数为1的方法有如下的情况：<br/>
  a)方法的字节码已经改变。<br/>
  b)这些方法为新的方法。</p>

<p>我们看一下以1开始的行数据
```</p>

<pre><code>1 "java.lang.invoke.AbstractValidatingLambdaMetafactory","void
</code></pre>

<p>validateMetafactoryArgs()&ldquo;,864</p>

<pre><code>1 "java.lang.invoke.InnerClassLambdaMetafactory","private
</code></pre>

<p>java.lang.Class spinInnerClass()&ldquo;,497</p>

<pre><code>1 "java.lang.reflect.Executable","java.lang.String
sharedToGenericString(int,boolean)",329
</code></pre>

<p>```</p>

<p>上面三个对内联不友好的方法全部来自Java 8，因此这属于新方法的情况。前两个方法与lamda表达式实现相关，第三个方法和反射子系统中继承层级调整有关。在这里，这个改变就是在Java 8 中引入了方法和构造器可以继承的通用基类。</p>

<p>最后，我们看一看JDK核心库一些令人惊讶的特性：
<code>
  $ grep -i ^\"java.lang.String large_jre_methods_8u25.txt
  "java.lang.String","public java.lang.String[] split(java.lang.String,int)",326
  "java.lang.String","public java.lang.String toLowerCase(java.util.Locale)",431
  "java.lang.String","public java.lang.String toUpperCase(java.util.Locale)",439
</code>
从上面的日志我们可以了解到，即使是Java 8 中一些java.lang.String中一些关键的方法还是处于内联不友好的状态。尤其是toLowerCase和toUpperCase这两个方法居然过大而无法内联，着实让人感到奇怪。但是，这两个方法由于要处理UTF-8数据而不是简单的ASCII数据，进而增加了方法的复杂性和大小，因而超过了内联友好的临界值。</p>

<p>对于性能要求较高并且确定只处理ASCII数据的程序，通常我们需要实现一个自己的StringUtils类。该类中包含一些静态的方法来实现上述内联不友好的方法的功能，但这些静态方法既保持紧凑型又能到达内联的要求。</p>

<p>上述我们讨论的改进都是大部分基于静态分析。除此之外，使用强大的JITWatch工具可以帮助我们更好地优化。JITWatch工具需要设置-XX:+LogCompilation选项开启日志打印。其打印出来的日志为XML格式，而非PrintCompilation简单的文本输出，并且这些日志比较大，通常会到达几百MB。它会影响正在运行的程序（默认情况下主要来自日志输出的影响），因此这个选项不适合在线上的生产环境使用。</p>

<p>PrintCompilation和Jarscan结合使用并不困难，但却提供了简单且很有实际作用的一步，尤其是对于开发团队打算研究其程序中即时编译执行情况时。大多数情况下，在性能优化中，一个快速的分析可以帮助我们完成一些容易实现的目标。</p>

<h2>关于作者</h2>

<p>Ben Evans是jClarity公司的CEO，jClarity是一家致力于Java和JVM性能分析研究的创业公司。除此之外他还是London Java Community的负责人之一并在Java Community Process Executive Committee有一席之地。他之前的项目有Google IPO性能测试，金融交易系统，90年代知名电影网站等。</p>

<p><strong>查看英文原文：</strong><a href="Your%20Java%20Application%20Hostile%20to%20JIT%20Compilation?">Is Your Java Application Hostile to JIT Compilation?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java永久代去哪儿了]]></title>
    <link href="http://droidyue.com/blog/2015/08/22/where-has-the-java-permgen-gone/"/>
    <updated>2015-08-22T17:01:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/08/22/where-has-the-java-permgen-gone</id>
    <content type="html"><![CDATA[<h2>版权说明</h2>

<p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/Java-PERMGEN-Removed">Java永久代去哪儿了</a>。如需转载，请与 InfoQ 中文站联系。</p>

<h2>摘要</h2>

<p>在JDK8之前，类的元数据和常量都存放在一个与堆内存相邻的数据区，即永久代。但是在这种情况下有一个问题，如果类的元数据大小超过了应用的可分配内存，那么就会出现内存溢出问题。在JDK8之后，永久代被移除，原本存储在永久代的数据将存放在一个叫做元空间的本地内存区域。</p>

<!--more-->


<p>在Java虚拟机（以下简称JVM）中，类包含其对应的元数据，比如类的层级信息，方法数据和方法信息（如字节码，栈和变量大小），运行时常量池，已确定的符号引用和虚方法表。</p>

<p>在过去（当自定义类加载器使用不普遍的时候），类几乎是“静态的”并且很少被卸载和回收，因此类也可以被看成“永久的”。另外由于类作为JVM实现的一部分，它们不由程序来创建，因为它们也被认为是“非堆”的内存。</p>

<p>在JDK8之前的HotSpot虚拟机中，类的这些“永久的”数据存放在一个叫做永久代的区域。永久代一段连续的内存空间，我们在JVM启动之前可以通过设置-XX:MaxPermSize的值来控制永久代的大小，32位机器默认的永久代的大小为64M，64位的机器则为85M。永久代的垃圾回收和老年代的垃圾回收是绑定的，一旦其中一个区域被占满，这两个区都要进行垃圾回收。但是有一个明显的问题，由于我们可以通过‑XX:MaxPermSize 设置永久代的大小，一旦类的元数据超过了设定的大小，程序就会耗尽内存，并出现内存溢出错误(OOM)。</p>

<p><strong>备注</strong>：在JDK7之前的HotSpot虚拟机中，纳入字符串常量池的字符串被存储在永久代中，因此导致了一系列的性能问题和内存溢出错误。想要了解这些永久代移除这些字符串的信息，请访问<a href="http://bugs.java.com/view_bug.do?bug_id=6962931">这里</a>查看。</p>

<h2>辞永久代，迎元空间</h2>

<p>随着Java8的到来，我们再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域就是我们要提到的元空间。</p>

<p>这项改动是很有必要的，因为对永久代进行调优是很困难的。永久代中的元数据可能会随着每一次Full GC发生而进行移动。并且为永久代设置空间大小也是很难确定的，因为这其中有很多影响因素，比如类的总数，常量池的大小和方法数量等。</p>

<p>同时，HotSpot虚拟机的每种类型的垃圾回收器都需要特殊处理永久代中的元数据。将元数据从永久代剥离出来，不仅实现了对元空间的无缝管理，还可以简化Full GC以及对以后的并发隔离类元数据等方面进行优化。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/removal_of_permen_gen.jpg">http://7jpolu.com1.z0.glb.clouddn.com/removal_of_permen_gen.jpg</a>"></p>

<h2>移除永久代的影响</h2>

<p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。因此，我们就不会遇到永久代存在时的内存溢出错误，也不会出现泄漏的数据移到交换区这样的事情。最终用户可以为元空间设置一个可用空间最大值，如果不进行设置，JVM会自动根据类的元数据大小动态增加元空间的容量。</p>

<p><strong>注意</strong>：永久代的移除并不代表自定义的类加载器泄露问题就解决了。因此，你还必须监控你的内存消耗情况，因为一旦发生泄漏，会占用你的大量本地内存，并且还可能导致交换区交换更加糟糕。</p>

<h2>元空间内存管理</h2>

<p>元空间的内存管理由元空间虚拟机来完成。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。在元空间中，类和其元数据的生命周期和其对应的类加载器是相同的。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。</p>

<p>我们从行文到现在提到的元空间稍微有点不严谨。准确的来说，每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。</p>

<p>元空间虚拟机负责元空间的分配，其采用的形式为组块分配。组块的大小因类加载器的类型而异。在元空间虚拟机中存在一个全局的空闲组块列表。当一个类加载器需要组块时，它就会从这个全局的组块列表中获取并维持一个自己的组块列表。当一个类加载器不再存活，那么其持有的组块将会被释放，并返回给全局组块列表。类加载器持有的组块又会被分成多个块，每一个块存储一个单元的元信息。组块中的块是线性分配（指针碰撞分配形式）。组块分配自内存映射区域。这些全局的虚拟内存映射区域以链表形式连接，一旦某个虚拟内存映射区域清空，这部分内存就会返回给操作系统。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/mmap_virtual_space.jpg">http://7jpolu.com1.z0.glb.clouddn.com/mmap_virtual_space.jpg</a>"></p>

<p>上图展示的是虚拟内存映射区域如何进行元组块的分配。类加载器1和3表明使用了反射或者为匿名类加载器，他们使用了特定大小组块。 而类加载器2和4根据其内部条目的数量使用小型或者中型的组块。</p>

<h2>元空间调优与工具</h2>

<p>正如上面提到的，元空间虚拟机控制元空间的增长。但是有些时候我们想限制其增长，比如通过显式在命令行中设置-XX:MaxMetaspaceSize。默认情况下，-XX:MaxMetaspaceSize的值没有限制，因此元空间甚至可以延伸到交换区，但是这时候当我们进行本地内存分配时将会失败。</p>

<p>对于一个64位的服务器端JVM来说，其默认的–XX:MetaspaceSize值为21MB。这就是初始的高水位线。一旦触及到这个水位线，Full GC将会被触发并卸载没有用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，这个高水位线则上升。如果释放空间过多，则高水位线下降。如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志我们可以观察到Full GC多次调用。为了避免频繁的GC，建议将–XX:MetaspaceSize设置为一个相对较高的值。</p>

<p>经过多次GC之后，元空间虚拟机自动调节高水位线，以此来推迟下一次垃圾回收到来。</p>

<p>有这样两个选项 ‑XX:MinMetaspaceFreeRatio和‑XX:MaxMetaspaceFreeRatio，他们类似于GC的FreeRatio选项，用来设置元空间空闲比例的最大值和最小值。我们可以通过命令行对这两个选项设置对应的值。</p>

<p>下面是一些改进的工具，用来获取更多关于元空间的信息。</p>

<ul>
<li>jmap -clstats PID 打印类加载器数据。（-clstats是-permstat的替代方案，在JDK8之前，-permstat用来打印类加载器的数据）。下面的例子输出就是DaCapo’s Avrora benchmark程序的类加载器数据
```bash
$ jmap -clstats <PID>
Attaching to process ID 6476, please wait&hellip;
Debugger attached successfully.
Server compiler detected.
JVM version is 25.5-b02
finding class loader instances ..done.
computing per loader stat ..done.
please wait.. computing liveness.liveness analysis may be inaccurate &hellip;
class_loader classes    bytes parent_loader     alive? type</li>
</ul>


<p><bootstrap>     655  1222734     null   live   <internal>
0x000000074004a6c0  0   0   0x000000074004a708  dead    java/util/ResourceBundle$RBClassLoader@0x00000007c0053e20
0x000000074004a760  0   0     null      dead    sun/misc/Launcher$ExtClassLoader@0x00000007c002d248
0x00000007401189c8  1   1471 0x00000007400752f8 dead    sun/reflect/DelegatingClassLoader@0x00000007c0009870
0x000000074004a708  116   316053    0x000000074004a760   dead   sun/misc/Launcher$AppClassLoader@0x00000007c0038190
0x00000007400752f8  538  773854 0x000000074004a708   dead   org/dacapo/harness/DacapoClassLoader@0x00000007c00638b0
total = 6   1310   2314112          N/A    alive=1, dead=5  N/A  <br/>
```</p>

<ul>
<li><strong>jstat -gc LVMID</strong> 用来打印元空间的信息，具体内容如下</li>
</ul>


<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/jstat.jpg">http://7jpolu.com1.z0.glb.clouddn.com/jstat.jpg</a>">
  * <strong>jcmd PID GC.class_stats</strong> 一个新的诊断命令，用来连接到运行的JVM并输出详尽的类元数据的柱状图。</p>

<p><strong>注意</strong>：在JDK 6 build 13下，需要加上<strong>‑XX:+UnlockDiagnosticVMOptions</strong> 才能正确使用jcmd这个命令。</p>

<p>```
$ jcmd <PID> help GC.class_stats
9522:
GC.class_stats
Provide statistics about Java class meta data. Requires -XX:+UnlockDiagnosticVMOptions.</p>

<p>Impact: High: Depends on Java heap size and content.</p>

<p>Syntax : GC.class_stats [options] [<columns>]</p>

<p>Arguments:</p>

<pre><code>columns : [optional] Comma-separated list of all the columns to show. If not specified, the following columns are shown: InstBytes,KlassBytes,CpAll,annotations,MethodCount,Bytecodes,MethodAll,ROAll,RWAll,Total (STRING, no default value)
</code></pre>

<p>Options: (options must be specified using the <key> or <key>=<value> syntax)</p>

<pre><code>-all : [optional] Show all columns (BOOLEAN, false)
-csv : [optional] Print in CSV (comma-separated values) format for spreadsheets (BOOLEAN, false)
-help : [optional] Show meaning of all the columns (BOOLEAN, false)
</code></pre>

<p>```
<strong>提示</strong>：如果想了解字段的更多信息，请访问<a href="https://bugs.openjdk.java.net/secure/attachment/11600/ver_010_help.txt">这里</a></p>

<p>使用jcmd的示例输出
```
 $ jcmd <PID> GC.class_stats</p>

<p>7140:
Index Super InstBytes KlassBytes annotations   CpAll MethodCount Bytecodes MethodAll   ROAll   RWAll   Total ClassName</p>

<pre><code>1   -1  426416      480         0       0           0       0       0   24  576     600 [C
2   -1  290136      480         0       0           0       0       0   40  576     616 [Lavrora.arch.legacy.LegacyInstr;
3   -1  269840      480         0       0           0       0       0   24  576     600 [B
4   43  137856      648         0   19248       129     4886    25288   16368   30568   46936 java.lang.Class
5   43  136968      624         0   8760        94      4570    33616   12072   32000   44072 java.lang.String
6   43  75872       560         0   1296        7       149     1400    880 2680    3560 java.util.HashMap$Node
7   836     57408       608         0   720         3       69      1480    528 2488    3016 avrora.sim.util.MulticastFSMProbe
8   43  55488       504         0   680         1       31      440     280 1536    1816 avrora.sim.FiniteStateMachine$State
9   -1  53712       480         0       0           0       0       0   24  576     600 [Ljava.lang.Object;
</code></pre>

<p>   10   -1  49424       480         0       0           0       0       0   24  576     600 [I
   11   -1  49248       480         0       0           0       0       0   24  576     600 [Lavrora.sim.platform.ExternalFlash$Page;
   12   -1  24400       480         0       0           0       0       0   32  576     608 [Ljava.util.HashMap$Node;
   13   394     21408       520         0   600         3       33      1216    432 2080    2512 avrora.sim.AtmelInterpreter$IORegBehavior
   14   727     19800       672         0   968         4       71      1240    664 2472    3136 avrora.arch.legacy.LegacyInstr$MOVW
…<snipped>
…<snipped>
1299  1300      0       608         0   256         1       5       152     104 1024    1128 sun.util.resources.LocaleNamesBundle
 1300  1098         0       608         0   1744        10      290     1808    1176    3208    4384 sun.util.resources.OpenListResourceBundle
 1301  1098         0       616         0   2184        12      395     2200    1480    3800    5280 sun.util.resources.ParallelListResourceBundle</p>

<pre><code>        2244312     794288      2024 2260976    12801   561882   3135144 1906688 4684704 6591392 Total
            34.0%   12.1%       0.0%   34.3%        -   8.5%    47.6%   28.9%   71.1%  100.0%
</code></pre>

<p>Index Super InstBytes KlassBytes annotations   CpAll MethodCount Bytecodes MethodAll   ROAll   RWAll   Total ClassName
```</p>

<h2>存在的问题</h2>

<p>前面已经提到，元空间虚拟机采用了组块分配的形式，同时区块的大小由类加载器类型决定。类信息并不是固定大小，因此有可能分配的空闲区块和类需要的区块大小不同，这种情况下可能导致碎片存在。元空间虚拟机目前并不支持压缩操作，所以碎片化是目前最大的问题。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/fragment_issue.jpg">http://7jpolu.com1.z0.glb.clouddn.com/fragment_issue.jpg</a>"></p>

<h2>关于作者</h2>

<p>Monica Beckwith是一位在硬件行业有着10多年经验的性能研究工程师。她目前在Servergy公司任性能架构师一职。该公司为一家提供高效服务器的创业公司。此外，Monica曾在Sun，Oracle和AMD等公司致力于服务器端JVM优化。Monica还是JavaOne 2013会议的演讲嘉宾。想要关注的可以在twitter上查找@mon_beck。</p>

<p><strong>查看英文原文：</strong><a href="http://www.infoq.com/articles/Java-PERMGEN-Removed">Where Has the Java PermGen Gone?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的字符串常量池]]></title>
    <link href="http://droidyue.com/blog/2014/12/21/string-literal-pool-in-java/"/>
    <updated>2014-12-21T19:09:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/12/21/string-literal-pool-in-java</id>
    <content type="html"><![CDATA[<p>Java中字符串对象创建有两种形式，一种为字面量形式，如<code>String str = "droid";</code>，另一种就是使用<strong>new</strong>这种标准的构造对象的方法，如<code>String str = new String("droid");</code>，这两种方式我们在代码编写时都经常使用，尤其是字面量的方式。然而这两种实现其实存在着一些性能和内存占用的差别。这一切都是源于JVM为了减少字符串对象的重复创建，其维护了一个特殊的内存，这段内存被成为字符串常量池或者字符串字面量池。</p>

<!--more-->


<h2>工作原理</h2>

<p>当代码中出现字面量形式创建字符串对象时，JVM首先会对这个字面量进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回，否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用。</p>

<h2>举例说明</h2>

<h3>字面量创建形式</h3>

<p><code>java
String str1 = "droid";
</code>
JVM检测这个字面量，这里我们认为没有内容为<code>droid</code>的对象存在。JVM通过字符串常量池查找不到内容为<code>droid</code>的字符串对象存在，那么会创建这个字符串对象，然后将刚创建的对象的引用放入到字符串常量池中,并且将引用返回给变量str1。</p>

<p>如果接下来有这样一段代码
<code>java
String str2 = "droid";
</code>
同样JVM还是要检测这个字面量，JVM通过查找字符串常量池，发现内容为"droid"字符串对象存在，于是将已经存在的字符串对象的引用返回给变量str2。注意这里不会重新创建新的字符串对象。</p>

<p>验证是否为str1和str2是否指向同一对象，我们可以通过这段代码
<code>java
System.out.println(str1 == str2);
</code>
结果为<code>true</code>。</p>

<h3>使用new创建</h3>

<p><code>java
String str3 = new String("droid");
</code>
当我们使用了new来构造字符串对象的时候，不管字符串常量池中有没有相同内容的对象的引用，新的字符串对象都会创建。因此我们使用下面代码测试一下，
<code>java
String str3 = new String("droid");
System.out.println(str1 == str3);
</code>
结果如我们所想，为<code>false</code>，表明这两个变量指向的为不同的对象。</p>

<h3>intern</h3>

<p>对于上面使用new创建的字符串对象，如果想将这个对象的引用加入到字符串常量池，可以使用intern方法。</p>

<p>调用intern后，首先检查字符串常量池中是否有该对象的引用，如果存在，则将这个引用返回给变量，否则将引用加入并返回给变量。
<code>java
String str4 = str3.intern();
System.out.println(str4 == str1);
</code>
输出的结果为<code>true</code>。</p>

<h2>疑难问题</h2>

<h3>前提条件？</h3>

<p>字符串常量池实现的前提条件就是Java中String对象是不可变的，这样可以安全保证多个变量共享同一个对象。如果Java中的String对象可变的话，一个引用操作改变了对象的值，那么其他的变量也会受到影响，显然这样是不合理的。</p>

<h3>引用 or 对象</h3>

<p>字符串常量池中存放的时引用还是对象，这个问题是最常见的。字符串常量池存放的是对象引用，不是对象。<strong>在Java中，对象都创建在堆内存中</strong>。</p>

<p>更新验证，收到的很多评论也在讨论这个问题，我简单的进行了验证。
验证环境
```
22:18:54-androidyue~/Videos$ cat /etc/os-release
NAME=Fedora
VERSION=&ldquo;17 (Beefy Miracle)&rdquo;
ID=fedora
VERSION_ID=17
PRETTY_NAME=&ldquo;Fedora 17 (Beefy Miracle)&rdquo;
ANSI_COLOR=&ldquo;0;34&rdquo;
CPE_NAME=&ldquo;cpe:/o:fedoraproject:fedora:17&rdquo;</p>

<p>22:19:04-androidyue~/Videos$ java -version
java version &ldquo;1.7.0_25&rdquo;
OpenJDK Runtime Environment (fedora-2.3.12.1.fc17-x86_64)
OpenJDK 64-Bit Server VM (build 23.7-b01, mixed mode)
<code>
验证思路：以下的Java程序读取一个大小为82M的视频文件，以字符串形式进行intern操作。
</code>bash
22:01:17-androidyue~/Videos$ ll -lh | grep why_to_learn.mp4
-rw-rw-r&mdash;. 1 androidyue androidyue  82M Oct 20  2013 why_to_learn.mp4
<code>
验证代码
</code>java
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;</p>

<p>public class TestMain {</p>

<pre><code>private static String fileContent;
public static void main(String[] args) {
    fileContent = readFileToString(args[0]);
    if (null != fileContent) {
        fileContent = fileContent.intern();
        System.out.println("Not Null");
    }
}


private static String readFileToString(String file) {
    BufferedReader reader = null;
    try {
        reader = new BufferedReader(new FileReader(file));
        StringBuffer buff = new StringBuffer();
        String line;
        while ((line = reader.readLine()) != null) {
            buff.append(line);
        }
        return buff.toString();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (null != reader) {
            try {
                reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    return null;
}
</code></pre>

<p>}</p>

<p><code>
由于字符串常量池存在于堆内存中的永久代，适用于Java8之前。我们通过设置永久代一个很小的值来进行验证。如果字符串对象存在字符串常量池中，那么必然抛出`java.lang.OutOfMemoryError permgen space`错误。
</code>bash
java -XX:PermSize=6m TestMain ~/Videos/why_to_learn.mp4
```
运行证明程序没有抛出OOM，其实这个不能很好的证明存储的是对象还是引用。</p>

<p>但是这个至少证明了字符串的实际内容对象char[]不存放在字符串常量池中。既然这样的话，其实字符串常量池存储字符串对象还是字符串对象的引用反而不是那么重要。但个人还是倾向于存储的为引用。</p>

<h3>优缺点</h3>

<p>字符串常量池的好处就是减少相同内容字符串的创建，节省内存空间。</p>

<p>如果硬要说弊端的话，就是牺牲了CPU计算时间来换空间。CPU计算时间主要用于在字符串常量池中查找是否有内容相同对象的引用。不过其内部实现为HashTable，所以计算成本较低。</p>

<h3>GC回收？</h3>

<p>因为字符串常量池中持有了共享的字符串对象的引用，这就是说是不是会导致这些对象无法回收？</p>

<p>首先问题中共享的对象一般情况下都比较小。据我查证了解，在早期的版本中确实存在这样的问题，但是随着<a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">弱引用</a>的引入，目前这个问题应该没有了。</p>

<p>关于这个问题，可以具体了解这片文章<a href="http://mindprod.com/jgloss/interned.html#GC">interned Strings : Java Glossary</a></p>

<h3>intern使用？</h3>

<p>关于使用intern的前提就是你清楚自己确实需要使用。比如，我们这里有一份上百万的记录，其中记录的某个值多次为<strong>美国加利福尼亚州</strong>，我们不想创建上百万条这样的字符串对象，我们可以使用intern只在内存中保留一份即可。关于intern更深入的了解请参考<a href="http://tech.meituan.com/in_depth_understanding_string_intern.html">深入解析String#intern</a>。</p>

<h3>总有例外？</h3>

<p>你知道下面的代码，会创建几个字符串对象，在字符串常量池中保存几个引用么？
<code>java
String test = "a" + "b" + "c";
</code>
答案是只创建了一个对象，在常量池中也只保存一个引用。我们使用javap反编译看一下即可得知。
```java
17:02 $ javap -c TestInternedPoolGC
Compiled from &ldquo;TestInternedPoolGC.java&rdquo;
public class TestInternedPoolGC extends java.lang.Object{
public TestInternedPoolGC();
  Code:
   0:   aload_0
   1:   invokespecial   #1; //Method java/lang/Object.&ldquo;<init>&rdquo;:()V
   4:   return</p>

<p>public static void main(java.lang.String[])   throws java.lang.Exception;
  Code:
   0:   ldc #2; //String abc
   2:   astore_1
   3:   return
```
看到了么，实际上在编译期间，已经将这三个字面量合成了一个。这样做实际上是一种优化，避免了创建多余的字符串对象，也没有发生字符串拼接问题。关于字符串拼接，可以查看<a href="http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/">Java细节：字符串的拼接</a>。</p>

<h2>参考文章</h2>

<ul>
<li><a href="http://blog.jamesdbloom.com/JVMInternals.html">JVMInternals</a></li>
<li><a href="http://www.javaranch.com/journal/200409/ScjpTipLine-StringsLiterally.html">Strings, Literally</a></li>
<li><a href="http://theopentutorials.com/tutorials/java/strings/string-literal-pool/">STRING LITERAL POOL</a></li>
<li><a href="http://mindprod.com/jgloss/interned.html">interned Strings : Java Glossary</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM运行时的数据区]]></title>
    <link href="http://droidyue.com/blog/2014/12/21/java-runtime-data-areas/"/>
    <updated>2014-12-21T18:59:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/12/21/java-runtime-data-areas</id>
    <content type="html"><![CDATA[<p>理解JVM运行时的数据区是Java编程中的进阶部分。我们在开发中都遇到过一个很头疼的问题就是OutOfMemoryError（内存溢出错误），但是如果我们了解JVM的内部实现和其运行时的数据区的工作机制，那么前面的问题就会迎刃而解。在这片文章中，我们将简单了解JVM中有哪些运行时数据区以及这些数据区的工作机制。</p>

<!--more-->


<h2>JVM运行时数据区分类</h2>

<ul>
<li>程序计数器 (Program Counter (PC) Register)</li>
<li>JVM栈 (Java Virtual Machine Stacks)</li>
<li>堆内存 (Heap Memory)</li>
<li>方法区 (Method Area)</li>
<li>运行时常量池 (Run-time Constant Pool)</li>
<li>本地方法栈 (Native Method Stacks)</li>
</ul>


<h3>有图才能说</h3>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/JVM_runtime_data_areas.png">http://7jpolu.com1.z0.glb.clouddn.com/JVM_runtime_data_areas.png</a>" title="jvm runtime data areas" ></p>

<h3>按线程持有划分</h3>

<p>查看上面的图，可以得知以上六个数据区其实线程私有还是共享，可以分为如下两种。</p>

<ul>
<li><strong>单个线程私有</strong>(Managed Per-Thread) 属于这一种的数据区包含 程序计数器， JVM栈还有本地方法栈。 每个线程都私有这三个数据区，这些数据区在其所属的线程创建时初始化，并随着所属线程结束被销毁。</li>
<li><strong>多个线程共享</strong>  属于这一种的数据区包含 堆内存，方法区和运行时常量池。这些数据区可以被每一个线程访问，他们随着JVM启动而初始化，同时伴随JVM关闭而销毁。</li>
</ul>


<h2>程序计数器</h2>

<p>在通用的计算机体系中，程序计数器用来记录当前正在执行的指令，在JVM中也是如此。程序计数器是线程私有，所以当一个新的线程创建时，程序计数器也会创建。由于Java是支持多线程，Java中的程序计数器用来记录当前线程中正在执行的指令。如果当前正在执行的方法是本地方法，那么此刻程序计数器的值为<strong>undefined</strong>。注意这个区域是唯一一个不抛出OutOfMemoryError的运行时数据区。</p>

<h2>JVM栈</h2>

<p>在介绍JVM栈之前，简单介绍一个概念，栈帧</p>

<h3>栈帧</h3>

<p>一个栈帧随着一个方法的调用开始而创建，这个方法调用完成而销毁。栈帧内存放者方法中的局部变量，操作数栈等数据。</p>

<p>JVM栈只对栈帧进行存储，压栈和出栈操作。栈内存的大小可以有两种设置，固定值和根据线程需要动态增长。在JVM栈这个数据区可能会发生抛出两种错误。</p>

<ul>
<li>StackOverflowError 出现在栈内存设置成固定值的时候，当程序执行需要的栈内存超过设定的固定值会抛出这个错误。</li>
<li>OutOfMemoryError   出现在栈内存设置成动态增长的时候，当JVM尝试申请的内存大小超过了其可用内存时会抛出这个错误。</li>
</ul>


<h2>堆数据区</h2>

<p>堆数据区是用来存放对象和数组（特殊的对象）。堆内存由多个线程共享。堆内存随着JVM启动而创建。众所周知，Java中有一个很好的特性就是自动垃圾回收。垃圾回收就操作这个数据区来回收对象进而释放内存。如果堆内存剩余的内存不足以满足于对象创建，JVM会抛出OutOfMemoryError错误。</p>

<h2>方法区</h2>

<p>在JVM规范中，方法区被视为堆内存的一个逻辑部分。这一点可能由于具体的JVM实现而不同，甚至在方法区不实现垃圾回收处理也是可以的。方法区和堆内存一样被多个线程访问，方法区中存放类的信息，比如类加载器引用，属性，方法代码和构造方法和常量等。当方法区的可用内存无法满足内存分配需求时，JVM会抛出OutOfMemoryError错误。</p>

<h2>运行时常量池</h2>

<p>运行时常量池创建在方法区，当一个类或者一个接口被创建的时候，JVM会创建一个运行时常量池。一个运行时常量池实际上是一个类或者接口的class文件中常量池表（constant_pool table）的运行时展示形式。一个运行时常量池包含了多种类型的常量，从诸如运行时可以确定的数值型字面量到运行时才能决定的方法和属性引用。当运行时常量池无法满足于内存分配需求时，JVM会抛出OutOfMemoryError错误。</p>

<h2>本地方法栈</h2>

<p>一个支持native方法调用的JVM实现，需要有这样一个数据区，就是本地方法栈，Java官方对于本地方法的定义为<code>methods written in a language other than the Java programming language</code>，就是使用非Java语言实现的方法，但是通常我们指的一般为C或者C++，因此这个栈也有着<strong>C栈</strong>这一称号。一个不支持本地方法执行的JVM没有必要实现这个数据区域。本地方法栈基本和JVM栈一样，其大小也是可以设置为固定值或者动态增加，因此也会对应抛出StackOverflowError和OutOfMemoryError错误。</p>

<h2>译文信息</h2>

<ul>
<li>原文出处<a href="http://javapapers.com/core-java/java-jvm-run-time-data-areas/">Java JVM Run-time Data Areas</a> 原文有些东西偏于隐晦，译文有这方面的修改。</li>
<li>翻译文章参考<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html">Chapter 2. The Structure of the Java Virtual Machine</a></li>
</ul>


<p>注：本文介绍JVM运行时数据相对比较概括，以后会有更加详细的针对单个数据区的介绍。</p>
]]></content>
  </entry>
  
</feed>
