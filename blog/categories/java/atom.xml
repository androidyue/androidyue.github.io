<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2014-11-24T22:20:57+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[译文：理解Java中的弱引用]]></title>
    <link href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/"/>
    <updated>2014-10-12T09:56:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java</id>
    <content type="html"><![CDATA[<p>不久之前，我面试了一些求职Java高级开发工程师的应聘者。我常常会面试他们说，“你能给我介绍一些Java中得弱引用吗？”，如果面试者这样说，“嗯，是不是垃圾回收有关的？”，我就会基本满意了，我并不期待回答是一篇诘究本末的论文描述。</p>

<p>然而事与愿违，我很吃惊的发现，在将近20多个有着平均5年开发经验和高学历背景的应聘者中，居然只有两个人知道弱引用的存在，但是在这两个人之中只有一个人真正了解这方面的知识。在面试过程中，我还尝试提示一些东西，来看看有没有人突然说一声“原来是这个啊”，结果很是让我失望。我开始困惑，为什么这块的知识如此不被重视，毕竟弱引用是一个很有用途的特性，况且这个特性已经在7年前 Java 1.2发布时便引入了。</p>

<!--more-->


<p>好吧，这里我不期待你看完本文之后成为一个弱引用方面的专家，但是我认为至少你应该了解什么是弱引用，如何使用它们，并且什么场景使用。既然它们是一些不知名的概念，我简单就着前面的三个问题来说明一下。</p>

<h2>强引用(Strong Reference)</h2>

<p>强引用就是我们经常使用的引用，其写法如下
<code>java
StringBuffer buffer = new StringBuffer();
</code>
上面创建了一个StringBuffer对象，并将这个对象的（强）引用存到变量buffer中。是的，就是这个小儿科的操作（请原谅我这样的说法）。强引用最重要的就是它能够让引用变得强（Strong），这就决定了它和垃圾回收器的交互。具体来说，如果一个对象通过一串强引用链接可到达(Strongly reachable)，它是不会被回收的。如果你不想让你正在使用的对象被回收，这就正是你所需要的。</p>

<h3>但是强引用如此之强</h3>

<p>在一个程序里，将一个类设置成不可被扩展是有点不太常见的，当然这个完全可以通过类标记成final实现。或者也可以更加复杂一些，就是通过内部包含了未知数量具体实现的工厂方法返回一个接口(Interface)。举个例子，我们想要使用一个叫做Widget的类，但是这个类不能被继承，所以无法增加新的功能。</p>

<p>但是我们如果想追踪Widget对象的额外信息，我们该怎么办？ 假设我们需要记录每个对象的序列号，但是由于Widget类并不包含这个属性，而且也不能扩展导致我们也不能增加这个属性。其实一点问题也没有，HashMap完全可以解决上述的问题。</p>

<p><code>java
serialNumberMap.put(widget, widgetSerialNumber);
</code>
这表面看上去没有问题，但是widget对象的强引用很有可能会引发问题。我们可以确信当一个widget序列号不需要时，我们应该将这个条目从map中移除。如果我们没有移除的话，可能会导致内存泄露，亦或者我们手动移除时删除了我们正在使用的widgets，会导致有效数据的丢失。其实这些问题很类似，这就是没有垃圾回收机制的语言管理内存时常遇到的问题。但是我们不用去担心这个问题，因为我们使用的时具有垃圾回收机制的Java语言。</p>

<p>另一个强引用可能带来的问题就是缓存,尤其是像图片这样的大文件的缓存。假设你有一个程序需要处理用户提供的图片，通常的做法就是做图片数据缓存，因为从磁盘加载图片代价很大，并且同时我们也想避免在内存中同时存在两份一样的图片数据。</p>

<p>缓存被设计的目的就是避免我们去再次加载哪些不需要的文件。你会很快发现在缓存中会一直包含一个到已经指向内存中图片数据的引用。使用强引用会强制图片数据留在内存，这就需要你来决定什么时候图片数据不需要并且手动从缓存中移除，进而可以让垃圾回收器回收。因此你再一次被强制做垃圾回收器该做的工作，并且人为决定是该清理到哪一个对象。</p>

<h2>弱引用(Weak Reference)</h2>

<p>弱引用简单来说就是将对象留在内存的能力不是那么强的引用。使用WeakReference，垃圾回收器会帮你来决定引用的对象何时回收并且将对象从内存移除。创建弱引用如下</p>

<p><code>java
WeakReference&lt;Widget&gt; weakWidget = new WeakReference&lt;Widget&gt;(widget);
</code></p>

<p>使用weakWidget.get()就可以得到真实的Widget对象，因为弱引用不能阻挡垃圾回收器对其回收，你会发现（当没有任何强引用到widget对象时）使用get时突然返回null。</p>

<p>解决上述的widget序列数记录的问题，最简单的办法就是使用Java内置的WeakHashMap类。WeakHashMap和HashMap几乎一样，唯一的区别就是它的键（不是值!!!）使用WeakReference引用。当WeakHashMap的键标记为垃圾的时候，这个键对应的条目就会自动被移除。这就避免了上面不需要的Widget对象手动删除的问题。使用WeakHashMap可以很便捷地转为HashMap或者Map。</p>

<h3>引用队列(Reference Queue)</h3>

<p>一旦弱引用对象开始返回null，该弱引用指向的对象就被标记成了垃圾。而这个弱引用对象（非其指向的对象）就没有什么用了。通常这时候需要进行一些清理工作。比如WeakHashMap会在这时候移除没用的条目来避免保存无限制增长的没有意义的弱引用。</p>

<p>引用队列可以很容易地实现跟踪不需要的引用。当你在构造WeakReference时传入一个ReferenceQueue对象，当该引用指向的对象被标记为垃圾的时候，这个引用对象会自动地加入到引用队列里面。接下来，你就可以在固定的周期，处理传入的引用队列，比如做一些清理工作来处理这些没有用的引用对象。</p>

<h2>四种引用</h2>

<p>Java中实际上有四种强度不同的引用，从强到弱它们分别是，强引用，软引用，弱引用和虚引用。上面部分介绍了强引用和弱引用，下面介绍剩下的两个，软引用和虚引用。</p>

<h2>软引用（Soft Reference）</h2>

<p>软引用基本上和弱引用差不多，只是相比弱引用，它阻止垃圾回收期回收其指向的对象的能力强一些。如果一个对象是弱引用可到达，那么这个对象会被垃圾回收器接下来的回收周期销毁。但是如果是软引用可以到达，那么这个对象会停留在内存更时间上长一些。当内存不足时垃圾回收器才会回收这些软引用可到达的对象。</p>

<p>由于软引用可到达的对象比弱引用可达到的对象滞留内存时间会长一些，我们可以利用这个特性来做缓存。这样的话，你就可以节省了很多事情，垃圾回收器会关心当前哪种可到达类型以及内存的消耗程度来进行处理。</p>

<h2>虚引用 （Phantom Reference）</h2>

<p>与软引用，弱引用不同，虚引用指向的对象十分脆弱，我们不可以通过get方法来得到其指向的对象。它的唯一作用就是当其指向的对象被回收之后，自己被加入到引用队列，用作记录该引用指向的对象已被销毁。</p>

<p>当弱引用的指向对象变得弱引用可到达，该弱引用就会加入到引用队列。这一操作发生在对象析构或者垃圾回收真正发生之前。理论上，这个即将被回收的对象是可以在一个不符合规范的析构方法里面重新复活。但是这个弱引用会销毁。虚引用只有在其指向的对象从内存中移除掉之后才会加入到引用队列中。其get方法一直返回null就是为了阻止其指向的几乎被销毁的对象重新复活。</p>

<p>虚引用使用场景主要由两个。它允许你知道具体何时其引用的对象从内存中移除。而实际上这是Java中唯一的方式。这一点尤其表现在处理类似图片的大文件的情况。当你确定一个图片数据对象应该被回收，你可以利用虚引用来判断这个对象回收之后在继续加载下一张图片。这样可以尽可能地避免可怕的内存溢出错误。</p>

<p>第二点，虚引用可以避免很多析构时的问题。finalize方法可以通过创建强引用指向快被销毁的对象来让这些对象重新复活。然而，一个重写了finalize方法的对象如果想要被回收掉，需要经历两个单独的垃圾收集周期。在第一个周期中，某个对象被标记为可回收，进而才能进行析构。但是因为在析构过程中仍有微弱的可能这个对象会重新复活。这种情况下，在这个对象真实销毁之前，垃圾回收器需要再次运行。因为析构可能并不是很及时，所以在调用对象的析构之前，需要经历数量不确定的垃圾收集周期。这就意味着在真正清理掉这个对象的时候可能发生很大的延迟。这就是为什么当大部分堆被标记成垃圾时还是会出现烦人的内存溢出错误。</p>

<p>使用虚引用，上述情况将引刃而解，当一个虚引用加入到引用队列时，你绝对没有办法得到一个销毁了的对象。因为这时候，对象已经从内存中销毁了。因为虚引用不能被用作让其指向的对象重生，所以其对象会在垃圾回收的第一个周期就将被清理掉。</p>

<p>显而易见，finalize方法不建议被重写。因为虚引用明显地安全高效，去掉finalize方法可以虚拟机变得明显简单。当然你也可以去重写这个方法来实现更多。这完全看个人选择。</p>

<h2>总结</h2>

<p>我想看到这里，很多人开始发牢骚了，为什么你要讲一个过去十年的老古董API呢，好吧，以我的经验看，很多的Java程序员并不是很了解这个知识，我认为有一些深入的理解是很必要的，同时我希望大家能从本文中收获一些东西。</p>

<h2>原文信息</h2>

<ul>
<li>文章出自  <a href="https://weblogs.java.net/blog/enicholas/archive/2006/05/understanding_w.html">Understanding Weak References</a></li>
<li>作者为<a href="https://www.java.net/blogs/enicholas">Ethan Nicholas</a>，Yahoo! Publishing Tools team Leader，Yahoo! SiteBuilder Web程序的早期作者。</li>
</ul>


<h2>附注信息</h2>

<p>本文涉及到很多概念对于初次接触的人相对比较难以理解，建议结合英文原文进行研究。</p>

<h3>Java高阶推荐</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00H1FXTNM/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00H1FXTNM&linkCode=as2&tag=droidyue-23">Java虚拟机规范(Java SE 7版)</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00H1FXTNM" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B00IOB0K1Q/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00IOB0K1Q&linkCode=as2&tag=droidyue-23">图灵程序设计丛书:Java性能优化权威指南</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00IOB0K1Q" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B00D2ID4PK/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00D2ID4PK&linkCode=as2&tag=droidyue-23">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00D2ID4PK" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[腾讯云分析问题]]></title>
    <link href="http://droidyue.com/blog/2014/10/12/tencent-analytics-issues/"/>
    <updated>2014-10-12T09:47:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/10/12/tencent-analytics-issues</id>
    <content type="html"><![CDATA[<p>今天使用腾讯云分析按照给出的文档开始集成，遇到了一个问题。</p>

<p><code>bash
E/AndroidRuntime( 4606): FATAL EXCEPTION: pool-1-thread-1
E/AndroidRuntime( 4606): java.lang.NoClassDefFoundError: com.tencent.mid.api.MidService
E/AndroidRuntime( 4606):    at com.tencent.stat.j.run(Unknown Source)
E/AndroidRuntime( 4606):    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1076)
E/AndroidRuntime( 4606):    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:569)
E/AndroidRuntime( 4606):    at java.lang.Thread.run(Thread.java:864)
</code></p>

<!--more-->


<h2>原因</h2>

<p>其实原因就是腾讯云分析的文档严重过时了，解决方法就是<strong>在Build Path 除了加入mta-sdk-x.x.x.jar,还要加入mid-sdk-x.x.jar</strong>。</p>

<p>但是腾讯的文档只介绍说集成mta-sdk-x.x.x.jar，我想可能那是大概0.x版本SDK的教程吧。</p>

<h2>吐个槽吧</h2>

<h3>霸王条款</h3>

<p>据说想要知道应用宝的下载数据（下载次数）必须集成腾讯云分析。这是在扛KPI，还是一贯的本性呢？</p>

<h3>过时冗余的文档</h3>

<p>前面提到了文档的严重过时失效，而且其文档存在严重的冗余，据我所知有三处文档，SDK下载包中一份，帮助中心一份，应用管理页面一份。如此这样，一旦修改，成本还是比较大的。</p>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00BSXRLR8/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00BSXRLR8&linkCode=as2&tag=droidyue-23">Android讲义哪家强</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00BSXRLR8" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B00LVHTI9U/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00LVHTI9U&linkCode=as2&tag=droidyue-23">每个人的第一行代码</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00LVHTI9U" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B0052VL2WC/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0052VL2WC&linkCode=as2&tag=droidyue-23">谁说菜鸟不会数据分析</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B0052VL2WC" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[细话Java："失效"的private修饰符]]></title>
    <link href="http://droidyue.com/blog/2014/10/02/the-private-modifier-in-java/"/>
    <updated>2014-10-02T17:24:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/10/02/the-private-modifier-in-java</id>
    <content type="html"><![CDATA[<p>在Java编程中，使用private关键字修饰了某个成员，只有这个成员所在的类和这个类的方法可以使用，其他的类都无法访问到这个private成员。</p>

<p>上面描述了private修饰符的基本职能，今天来研究一下private功能失效的情况。</p>

<!--more-->


<h2>Java内部类</h2>

<p>在Java中相信很多人都用过内部类，Java允许在一个类里面定义另一个类，类里面的类就是内部类，也叫做嵌套类。一个简单的内部类实现可以如下
```java
class OuterClass {</p>

<pre><code>class InnerClass{
}
</code></pre>

<p>}
```
今天的问题和Java内部类相关，只涉及到部分和本文研究相关的内部类知识，具体关于Java内部类后续的文章会介绍。</p>

<h2>第一次失效?</h2>

<p>一个我们在编程中经常用到的场景，就是在一个内部类里面访问外部类的private成员变量或者方法，这是可以的。如下面的代码实现。
```java
public class OuterClass {</p>

<pre><code>private String language = "en";
private String region = "US";


public class InnerClass {
    public void printOuterClassPrivateFields() {
        String fields = "language=" + language + ";region=" + region;
        System.out.println(fields);
    }
}

public static void main(String[] args) {
    OuterClass outer = new OuterClass();
    OuterClass.InnerClass inner = outer.new InnerClass();
    inner.printOuterClassPrivateFields();
}
</code></pre>

<p>}
```
这是为什么呢，不是private修饰的成员只能被成员所述的类才能访问么？难道private真的失效了么？</p>

<h3>编译器在捣鬼？</h3>

<p>我们使用javap命令查看一下生成的两个class文件</p>

<p> OuterClass的反编译结果
```java
15:30 $ javap -c  OuterClass
Compiled from &ldquo;OuterClass.java&rdquo;
public class OuterClass extends java.lang.Object{
public OuterClass();
  Code:
   0:   aload_0
   1:   invokespecial   #11; //Method java/lang/Object.&ldquo;<init>&rdquo;:()V
   4:   aload_0
   5:   ldc #13; //String en
   7:   putfield    #15; //Field language:Ljava/lang/String;
   10:  aload_0
   11:  ldc #17; //String US
   13:  putfield    #19; //Field region:Ljava/lang/String;
   16:  return</p>

<p>public static void main(java.lang.String[]);
  Code:
   0:   new #1; //class OuterClass
   3:   dup
   4:   invokespecial   #27; //Method &ldquo;<init>&rdquo;:()V
   7:   astore_1
   8:   new #28; //class OuterClass$InnerClass
   11:  dup
   12:  aload_1
   13:  dup
   14:  invokevirtual   #30; //Method java/lang/Object.getClass:()Ljava/lang/Class;
   17:  pop
   18:  invokespecial   #34; //Method OuterClass$InnerClass.&ldquo;<init>&rdquo;:(LOuterClass;)V
   21:  astore_2
   22:  aload_2
   23:  invokevirtual   #37; //Method OuterClass$InnerClass.printOuterClassPrivateFields:()V
   26:  return</p>

<p>static java.lang.String access$0(OuterClass);
  Code:
   0:   aload_0
   1:   getfield    #15; //Field language:Ljava/lang/String;
   4:   areturn</p>

<p>static java.lang.String access$1(OuterClass);
  Code:
   0:   aload_0
   1:   getfield    #19; //Field region:Ljava/lang/String;
   4:   areturn</p>

<p>}
<code>
咦？不对，在OuterClass中我们并没有定义这两个方法
</code>java
static java.lang.String access$0(OuterClass);
  Code:
   0:   aload_0
   1:   getfield    #15; //Field language:Ljava/lang/String;
   4:   areturn</p>

<p>static java.lang.String access$1(OuterClass);
  Code:
   0:   aload_0
   1:   getfield    #19; //Field region:Ljava/lang/String;
   4:   areturn</p>

<p>}
```
从给出来的注释来看，access$0返回outerClass的language属性；access$1返回outerClass的region属性。并且这两个方法都接受OuterClass的实例作为参数。这两个方法为什么生成呢，有什么作用呢？我们看一下内部类的反编译结果就知道了。</p>

<p><strong>OuterClass$InnerClass的反编译结果</strong>
```java
15:37 $ javap -c OuterClass\$InnerClass
Compiled from &ldquo;OuterClass.java&rdquo;
public class OuterClass$InnerClass extends java.lang.Object{
final OuterClass this$0;</p>

<p>public OuterClass$InnerClass(OuterClass);
  Code:
   0:   aload_0
   1:   aload_1
   2:   putfield    #10; //Field this$0:LOuterClass;
   5:   aload_0
   6:   invokespecial   #12; //Method java/lang/Object.&ldquo;<init>&rdquo;:()V
   9:   return</p>

<p>public void printOuterClassPrivateFields();
  Code:
   0:   new #20; //class java/lang/StringBuilder
   3:   dup
   4:   ldc #22; //String language=
   6:   invokespecial   #24; //Method java/lang/StringBuilder.&ldquo;<init>&rdquo;:(Ljava/lang/String;)V
   9:   aload_0
   10:  getfield    #10; //Field this$0:LOuterClass;
   13:  invokestatic    #27; //Method OuterClass.access$0:(LOuterClass;)Ljava/lang/String;
   16:  invokevirtual   #33; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
   19:  ldc #37; //String ;region=
   21:  invokevirtual   #33; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
   24:  aload_0
   25:  getfield    #10; //Field this$0:LOuterClass;
   28:  invokestatic    #39; //Method OuterClass.access$1:(LOuterClass;)Ljava/lang/String;
   31:  invokevirtual   #33; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
   34:  invokevirtual   #42; //Method java/lang/StringBuilder.toString:()Ljava/lang/String;
   37:  astore_1
   38:  getstatic   #46; //Field java/lang/System.out:Ljava/io/PrintStream;
   41:  aload_1
   42:  invokevirtual   #52; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   45:  return
}
<code>
下面代码调用access$0的代码,其目的是得到OuterClass的language 私有属性。
</code>java
13: invokestatic    #27; //Method OuterClass.access$0:(LOuterClass;)Ljava/lang/String;
<code>
下面代码调用了access$1的代码，其目的是得到OutherClass的region 私有属性。
</code>java
28: invokestatic    #39; //Method OuterClass.access$1:(LOuterClass;)Ljava/lang/String;
```</p>

<p><strong>注意：在内部类构造的时候，会将外部类的引用传递进来，并且作为内部类的一个属性，所以内部类会持有一个其外部类的引用。</strong><br/>
this$0就是内部类持有的外部类引用，通过构造方法传递引用并赋值。
```java
final OuterClass this$0;</p>

<p>public OuterClass$InnerClass(OuterClass);
  Code:
   0:   aload_0
   1:   aload_1
   2:   putfield    #10; //Field this$0:LOuterClass;
   5:   aload_0
   6:   invokespecial   #12; //Method java/lang/Object.&ldquo;<init>&rdquo;:()V
   9:   return
```</p>

<h3>小结</h3>

<p>这部分private看上去失效可，实际上并没有失效，因为当内部类调用外部类的私有属性时，其真正的执行是调用了编译器生成的属性的静态方法（即acess$0,access$1等）来获取这些属性值。这一切都是编译器的特殊处理。</p>

<h2>这次也失效？</h2>

<p>如果说上面的写法很常用，那么这样的写法是不是很少接触，但是却可以运行。
```java
public class AnotherOuterClass {</p>

<pre><code>public static void main(String[] args) {
    InnerClass inner = new AnotherOuterClass().new InnerClass();
    System.out.println("InnerClass Filed = " + inner.x);
}

class InnerClass {
    private int x = 10;
}
</code></pre>

<p>}
<code>
和上面一样，使用javap反编译看一下。不过这次我们先看一下InnerClass的结果
</code>java
16:03 $ javap -c AnotherOuterClass\$InnerClass
Compiled from &ldquo;AnotherOuterClass.java&rdquo;
class AnotherOuterClass$InnerClass extends java.lang.Object{
final AnotherOuterClass this$0;</p>

<p>AnotherOuterClass$InnerClass(AnotherOuterClass);
  Code:
   0:   aload_0
   1:   aload_1
   2:   putfield    #12; //Field this$0:LAnotherOuterClass;
   5:   aload_0
   6:   invokespecial   #14; //Method java/lang/Object.&ldquo;<init>&rdquo;:()V
   9:   aload_0
   10:  bipush  10
   12:  putfield    #17; //Field x:I
   15:  return</p>

<p>static int access$0(AnotherOuterClass$InnerClass);
  Code:
   0:   aload_0
   1:   getfield    #17; //Field x:I
   4:   ireturn</p>

<p>}
```
又出现了，编译器又自动生成了一个获取私有属性的后门方法access$0一次来获取x的值。</p>

<p>AnotherOuterClass.class的反编译结果
```java
16:08 $ javap -c AnotherOuterClass
Compiled from &ldquo;AnotherOuterClass.java&rdquo;
public class AnotherOuterClass extends java.lang.Object{
public AnotherOuterClass();
  Code:
   0:   aload_0
   1:   invokespecial   #8; //Method java/lang/Object.&ldquo;<init>&rdquo;:()V
   4:   return</p>

<p>public static void main(java.lang.String[]);
  Code:
   0:   new #16; //class AnotherOuterClass$InnerClass
   3:   dup
   4:   new #1; //class AnotherOuterClass
   7:   dup
   8:   invokespecial   #18; //Method &ldquo;<init>&rdquo;:()V
   11:  dup
   12:  invokevirtual   #19; //Method java/lang/Object.getClass:()Ljava/lang/Class;
   15:  pop
   16:  invokespecial   #23; //Method AnotherOuterClass$InnerClass.&ldquo;<init>&rdquo;:(LAnotherOuterClass;)V
   19:  astore_1
   20:  getstatic   #26; //Field java/lang/System.out:Ljava/io/PrintStream;
   23:  new #32; //class java/lang/StringBuilder
   26:  dup
   27:  ldc #34; //String InnerClass Filed =
   29:  invokespecial   #36; //Method java/lang/StringBuilder.&ldquo;<init>&rdquo;:(Ljava/lang/String;)V
   32:  aload_1
   33:  invokestatic    #39; //Method AnotherOuterClass$InnerClass.access$0:(LAnotherOuterClass$InnerClass;)I
   36:  invokevirtual   #43; //Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
   39:  invokevirtual   #47; //Method java/lang/StringBuilder.toString:()Ljava/lang/String;
   42:  invokevirtual   #51; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   45:  return</p>

<p>}
<code>
其中这句调用就是外部类通过内部类的实例获取私有属性x的操作
</code>java
33: invokestatic    #39; //Method AnotherOuterClass$InnerClass.access$0:(LAnotherOuterClass$InnerClass;)I
```</p>

<h3>再来个总结</h3>

<p>其中<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6.1">java官方文档</a> 有这样一句话</p>

<blockquote><p>if the member or constructor is declared private, then access is permitted if and only if it occurs within the body of the top level class (§7.6) that encloses the declaration of the member or constructor.</p></blockquote>

<p>意思是 如果（内部类的）成员和构造方法设定成了私有修饰符，当且仅当其外部类访问时是允许的。</p>

<h2>如何让内部类私有成员不被外部访问</h2>

<p>相信看完上面两部分，你会觉得，内部类的私有成员想不被外部类访问都很困难吧，谁让编译器“爱管闲事”呢，其实也是可以做到的。那就是使用匿名内部类。</p>

<p>由于mRunnable对象的类型为Runnable，而不是匿名内部类的类型（我们无法正常拿到），而Runanble中没有x这个属性，所以mRunnable.x是不被允许的。
```java</p>

<p>public class PrivateToOuter {</p>

<pre><code>Runnable mRunnable = new Runnable(){
    private int x=10;
    @Override
    public void run() {
        System.out.println(x);
    }
};

public static void main(String[] args){
    PrivateToOuter p = new PrivateToOuter();
    //System.out.println("anonymous class private filed= "+ p.mRunnable.x); //not allowed
    p.mRunnable.run(); // allowed
}
</code></pre>

<p>}
```</p>

<h2>最后总结</h2>

<ul>
<li>在本文中，private表面上看上去失效了，但实际上是没有的，而是在调用时通过间接的方法来获取私有的属性。</li>
<li>Java的内部类构造时持有对外部类的应用，C++不会，这一点和C++不一样。</li>
</ul>


<h3>深入Java细节的书籍</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0011F7WU4&linkCode=as2&tag=droidyue-23">Java编程思想</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B0011F7WU4" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B001PTGR52/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B001PTGR52&linkCode=as2&tag=droidyue-23">Sun 公司核心技术丛书:Effective Java中文版</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B001PTGR52" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B00D2ID4PK/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00D2ID4PK&linkCode=as2&tag=droidyue-23">深入理解Java虚拟机:JVM高级特性与最佳实践</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00D2ID4PK" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MissingFormatArgumentException: Format specifier 's']]></title>
    <link href="http://droidyue.com/blog/2014/09/27/missingformatargumentexception-format-specifier-s/"/>
    <updated>2014-09-27T10:09:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/09/27/missingformatargumentexception-format-specifier-s</id>
    <content type="html"><![CDATA[<p>贴出一个简单的异常，分析一下原因，以及推荐一个相对好一些的替代方法。
如下，如果我们进行字符串格式化提供的值的数量少于字符串格式符（%s）的数量，就会抛出MissingFormatArgumentException异常。</p>

<!--more-->


<h3>错误代码</h3>

<p><code>java lineos:false
String format = "%s/%s";
String.format(format, "a");
</code></p>

<h3>崩溃信息</h3>

<p>```java lineos:false
Exception in thread &ldquo;main&rdquo; java.util.MissingFormatArgumentException: Format specifier &rsquo;s'</p>

<pre><code>at java.util.Formatter.format(Unknown Source)
at java.util.Formatter.format(Unknown Source)
at java.lang.String.format(Unknown Source)
at Concatenation.testFormat(Concatenation.java:17)
at Concatenation.main(Concatenation.java:4)
</code></pre>

<p>```</p>

<h3>替代方法</h3>

<p>相比字符串的格式化操作，使用字符串的替换更加安全，避免因为疏忽或者考虑不全等带来的崩溃问题。
<code>java lineos:false
String s = "%country%/%city%".replace("%country%", "China").replace("%city%", "Beijing");
</code></p>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B0084ASO7E/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0084ASO7E&linkCode=as2&tag=droidyue-23">数学之美</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B0084ASO7E" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B00D36S64K/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00D36S64K&linkCode=as2&tag=droidyue-23">像计算机科学家一样思考Java</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00D36S64K" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B00HQW9FMO/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00HQW9FMO&linkCode=as2&tag=droidyue-23">微信公众平台应用开发:方法、技巧与案例</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00HQW9FMO" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中Java和JavaScript交互]]></title>
    <link href="http://droidyue.com/blog/2014/09/20/interaction-between-java-and-javascript-in-android/"/>
    <updated>2014-09-20T21:37:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/09/20/interaction-between-java-and-javascript-in-android</id>
    <content type="html"><![CDATA[<p>Android提供了一个很强大的WebView控件用来处理Web网页，而在网页中，JavaScript又是一个很举足轻重的脚本。本文将介绍如何实现Java代码和Javascript代码的相互调用。</p>

<!--more-->


<h2>如何实现</h2>

<p>实现Java和js交互十分便捷。通常只需要以下几步。</p>

<ul>
<li>WebView开启JavaScript脚本执行</li>
<li>WebView设置供JavaScript调用的交互接口。</li>
<li>客户端和网页端编写调用对方的代码。</li>
</ul>


<h2>本例代码</h2>

<p>为了便于讲解，先贴出全部代码</p>

<h3>Java代码</h3>

<p>```java lineos:false
package com.example.javajsinteractiondemo;</p>

<p>import android.annotation.SuppressLint;
import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.view.Menu;
import android.webkit.JavascriptInterface;
import android.webkit.WebChromeClient;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.widget.Toast;</p>

<p>public class MainActivity extends Activity {</p>

<pre><code>private static final String LOGTAG = "MainActivity";
@SuppressLint("JavascriptInterface")
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    final WebView myWebView = (WebView) findViewById(R.id.myWebView);
    WebSettings settings = myWebView.getSettings();
    settings.setJavaScriptEnabled(true);
    myWebView.addJavascriptInterface(new JsInteration(), "control");
    myWebView.setWebChromeClient(new WebChromeClient() {});
    myWebView.setWebViewClient(new WebViewClient() {

        @Override
        public void onPageFinished(WebView view, String url) {
            super.onPageFinished(view, url);
            testMethod(myWebView);
        }

    });
    myWebView.loadUrl("file:///android_asset/js_java_interaction.html");
}

private void testMethod(WebView webView) {
    String call = "javascript:sayHello()";

    call = "javascript:alertMessage(\"" + "content" + "\")";

    call = "javascript:toastMessage(\"" + "content" + "\")";

    call = "javascript:sumToJava(1,2)";
    webView.loadUrl(call);

}

public class JsInteration {

    @JavascriptInterface
    public void toastMessage(String message) {
        Toast.makeText(getApplicationContext(), message, Toast.LENGTH_LONG).show();
    }

    @JavascriptInterface
    public void onSumResult(int result) {
        Log.i(LOGTAG, "onSumResult result=" + result);
    }
}
</code></pre>

<p>}</p>

<p>```</p>

<h3>前端网页代码</h3>

<p>```html lineos:false js_java_interaction.html
<html></p>

<script type="text/javascript">
    function sayHello() {
        alert("Hello")
    }

    function alertMessage(message) {
        alert(message)
    }

    function toastMessage(message) {
        window.control.toastMessage(message)
    }

    function sumToJava(number1, number2){
       window.control.onSumResult(number1 + number2) 
    }
</script>


<p>Java-Javascript Interaction In Android
</html>
```</p>

<h2>调用示例</h2>

<h3>js调用Java</h3>

<p>调用格式为window.jsInterfaceName.methodName(parameterValues)
此例中我们使用的是control作为注入接口名称。
```html lineos:false
function toastMessage(message) {</p>

<pre><code>window.control.toastMessage(message)
</code></pre>

<p>}</p>

<p>function sumToJava(number1, number2){
   window.control.onSumResult(number1 + number2)
}
```</p>

<h3>Java调用JS</h3>

<p>webView调用js的基本格式为webView.loadUrl(&ldquo;javascript:methodName(parameterValues)&rdquo;)</p>

<h4>调用js无参无返回值函数</h4>

<p><code>java lineos:false
String call = "javascript:sayHello()";
webView.loadUrl(call);
</code></p>

<h4>调用js有参无返回值函数</h4>

<p>注意对于字符串作为参数值需要进行转义双引号。
<code>java lineos:false
String call = "javascript:alertMessage(\"" + "content" + "\")";
webView.loadUrl(call);
</code></p>

<h4>调用js有参数有返回值的函数</h4>

<p>Android在4.4之前并没有提供直接调用js函数并获取值的方法，所以在此之前，常用的思路是 java调用js方法，js方法执行完毕，再次调用java代码将值返回。</p>

<h5>1.Java调用js代码</h5>

<p><code>java lineos:false
String call = "javascript:sumToJava(1,2)";
webView.loadUrl(call);
</code></p>

<h5>2.js函数处理，并将结果通过调用java方法返回</h5>

<p>```javascript lineos:false
function sumToJava(number1, number2){</p>

<pre><code>   window.control.onSumResult(number1 + number2) 
</code></pre>

<p>}
```</p>

<h5>3.Java在回调方法中获取js函数返回值</h5>

<p>```java lineos:false
@JavascriptInterface
public void onSumResult(int result) {</p>

<pre><code>Log.i(LOGTAG, "onSumResult result=" + result);
</code></pre>

<p>}
```</p>

<h4><font color="blue">4.4处理</font></h4>

<p>Android 4.4之后使用evaluateJavascript即可。这里展示一个简单的交互示例
具有返回值的js方法
```html lineos:false
function getGreetings() {</p>

<pre><code>    return 1;
</code></pre>

<p>}
<code>
java代码时用evaluateJavascript方法调用
</code>java lineos:false
private void testEvaluateJavascript(WebView webView) {</p>

<pre><code>webView.evaluateJavascript("getGreetings()", new ValueCallback&lt;String&gt;() {

@Override
public void onReceiveValue(String value) {
    Log.i(LOGTAG, "onReceiveValue value=" + value);
}});
</code></pre>

<p>}
<code>
输出结果
</code>bash lineos:false
I/MainActivity( 1432): onReceiveValue value=1
```</p>

<p>注意</p>

<ul>
<li>上面限定了结果返回结果为String，对于简单的类型会尝试转换成字符串返回，对于复杂的数据类型，建议以字符串形式的json返回。</li>
<li>evaluateJavascript方法必须在UI线程（主线程）调用，因此onReceiveValue也执行在主线程。</li>
</ul>


<h2>疑问解答</h2>

<h3><font color="red">Alert无法弹出</font></h3>

<p>你应该是没有设置WebChromeClient,按照以下代码设置
```java
myWebView.setWebChromeClient(new WebChromeClient() {});</p>

<p>```</p>

<h3><font color="red">Uncaught ReferenceError: functionName is not defined</font></h3>

<p>问题出现原因，<strong>网页的js代码没有加载完成</strong>，就调用了js方法。解决方法是在网页加载完成之后调用js方法
```java fileos:false
myWebView.setWebViewClient(new WebViewClient() {</p>

<pre><code>@Override
public void onPageFinished(WebView view, String url) {
    super.onPageFinished(view, url);
    //在这里执行你想调用的js函数
}
</code></pre>

<p>});
```</p>

<h3><font color="red">Uncaught TypeError: Object [object Object] has no method</font></h3>

<h4>安全限制问题</h4>

<p>如果只在4.2版本以上的机器出问题，那么就是系统处于安全限制的问题了。Android文档这样说的</p>

<blockquote><p>Caution: If you&rsquo;ve set your targetSdkVersion to 17 or higher, you must add the @JavascriptInterface annotation to any method that you want available your web page code (the method must also be public). If you do not provide the annotation, then the method will not accessible by your web page when running on Android 4.2 or higher.</p></blockquote>

<p>中文大意为</p>

<blockquote><p>警告：如果你的程序目标平台是17或者是更高，你必须要在暴露给网页可调用的方法（这个方法必须是公开的）加上@JavascriptInterface注释。如果你不这样做的话，在4.2以以后的平台上，网页无法访问到你的方法。</p></blockquote>

<h5>两种解决方法</h5>

<ul>
<li>将targetSdkVersion设置成17或更高，引入@JavascriptInterface注释</li>
<li>自己创建一个注释接口名字为@JavascriptInterface，然后将其引入。注意这个接口不能混淆。</li>
</ul>


<p>注，创建@JavascriptInterface代码
```java lineos:false
public @interface JavascriptInterface {</p>

<p>}
```</p>

<h4>代码混淆问题</h4>

<p>如果在没有混淆的版本运行正常，在混淆后的版本的代码运行错误，并提示Uncaught TypeError: Object [object Object] has no method，那就是你没有做混淆例外处理。
在混淆文件加入类似这样的代码
```ruby lineos:false
-keep class com.example.javajsinteractiondemo$JsInteration {</p>

<pre><code>*;
</code></pre>

<p>}</p>

<p>```</p>

<h3><font color="red">All WebView methods must be called on the same thread</font></h3>

<p>过滤日志曾发现过这个问题。
<code>java lineos:false
E/StrictMode( 1546): java.lang.Throwable: A WebView method was called on thread 'JavaBridge'. All WebView methods must be called on the same thread. (Expected Looper Looper (main, tid 1) {528712d4} called on Looper (JavaBridge, tid 121) {52b6678c}, FYI main Looper is Looper (main, tid 1) {528712d4})
E/StrictMode( 1546):    at android.webkit.WebView.checkThread(WebView.java:2063)
E/StrictMode( 1546):    at android.webkit.WebView.loadUrl(WebView.java:794)
E/StrictMode( 1546):    at com.xxx.xxxx.xxxx.xxxx.xxxxxxx$JavaScriptInterface.onCanGoBackResult(xxxx.java:96)
E/StrictMode( 1546):    at com.android.org.chromium.base.SystemMessageHandler.nativeDoRunLoopOnce(Native Method)
E/StrictMode( 1546):    at com.android.org.chromium.base.SystemMessageHandler.handleMessage(SystemMessageHandler.java:27)
E/StrictMode( 1546):    at android.os.Handler.dispatchMessage(Handler.java:102)
E/StrictMode( 1546):    at android.os.Looper.loop(Looper.java:136)
E/StrictMode( 1546):    at android.os.HandlerThread.run(HandlerThread.java:61)
</code>
在js调用后的Java回调线程并不是主线程。如打印日志可验证
<code>bash lineos:false
ThreadInfo=Thread[WebViewCoreThread,5,main]
</code>
解决上述的异常，将webview操作放在主线程中即可。
```java
webView.post(new Runnable() {</p>

<pre><code>@Override
public void run() {
    webView.loadUrl(YOUR_URL).
}
</code></pre>

<p>});
```</p>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00LVHTI9U/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00LVHTI9U&linkCode=as2&tag=droidyue-23">第一行代码:Android</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00LVHTI9U" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B0097CON2S/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0097CON2S&linkCode=as2&tag=droidyue-23">JavaScript语言精粹</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B0097CON2S" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B00B14IGUK/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00B14IGUK&linkCode=as2&tag=droidyue-23">安全技术大系:Web前端黑客技术揭秘</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00B14IGUK" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
</feed>
