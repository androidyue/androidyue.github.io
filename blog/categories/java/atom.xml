<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2016-03-13T20:23:48+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[理解Java中ThreadLocal]]></title>
    <link href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/"/>
    <updated>2016-03-13T20:21:00+08:00</updated>
    <id>http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java</id>
    <content type="html"><![CDATA[<p>提到ThreadLocal，有些Android或者Java程序员可能有所陌生，可能会提出种种问题，它是做什么的，是不是和线程有关，怎么使用呢？等等问题，本文将总结一下我对ThreadLocal的理解和认识，希望让大家理解ThreadLocal更加透彻一些。</p>

<!--more-->


<h2>ThreadLocal是什么</h2>

<p>ThreadLocal是一个关于创建线程局部变量的类。</p>

<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。</p>

<h2>Global &amp;&amp; Local</h2>

<p>上面的两个修饰看似矛盾，实则不然。</p>

<ul>
<li>Global 意思是在当前线程中，任何一个点都可以访问到ThreadLocal的值。</li>
<li>Local 意思是该线程的ThreadLocal只能被该线程访问，一般情况下其他线程访问不到。</li>
</ul>


<h2>用法简介</h2>

<h3>创建，支持泛型</h3>

<p><code>java
ThreadLocal&lt;String&gt; mStringThreadLocal = new ThreadLocal&lt;&gt;();
</code></p>

<h3>set方法</h3>

<p><code>java
mStringThreadLocal.set("droidyue.com");
</code></p>

<h3>get方法</h3>

<p><code>java
mStringThreadLocal.get();
</code></p>

<p>完整的使用示例
```java
private void testThreadLocal() {</p>

<pre><code>Thread t = new Thread() {
    ThreadLocal&lt;String&gt; mStringThreadLocal = new ThreadLocal&lt;&gt;();

    @Override
    public void run() {
        super.run();
        mStringThreadLocal.set("droidyue.com");
        mStringThreadLocal.get();
    }
};

t.start();
</code></pre>

<p>}
```</p>

<h3>ThreadLocal初始值</h3>

<p>为ThreadLocal设置默认的get初始值，需要重写<code>initialValue</code>方法，下面是一段代码，我们将默认值修改成了线程的名字
```java
ThreadLocal<String> mThreadLocal = new ThreadLocal<String>() {</p>

<pre><code>@Override
protected String initialValue() {
    return Thread.currentThread().getName();
}
</code></pre>

<p>};
```</p>

<h2>Android中的应用</h2>

<p>在Android中，Looper类就是利用了ThreadLocal的特性，保证每个线程只存在一个Looper对象。
```java
static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();
private static void prepare(boolean quitAllowed) {</p>

<pre><code>if (sThreadLocal.get() != null) {
    throw new RuntimeException("Only one Looper may be created per thread");
}
sThreadLocal.set(new Looper(quitAllowed));
</code></pre>

<p>}
```</p>

<h2>如何实现</h2>

<p>为了更好的掌握ThreadLocal，我认为了解其内部实现是很有必要的，这里我们以set方法从起始看一看ThreadLocal的实现原理。</p>

<p>下面是ThreadLocal的set方法，大致意思为</p>

<ul>
<li>首先获取当前线程</li>
<li>利用当前线程作为句柄获取一个ThreadLocalMap的对象</li>
<li>如果上述ThreadLocalMap对象不为空，则设置值，否则创建这个ThreadLocalMap对象并设置值</li>
</ul>


<p>源码如下
```java
public void set(T value) {</p>

<pre><code>Thread t = Thread.currentThread();
ThreadLocalMap map = getMap(t);
if (map != null)
    map.set(this, value);
else
    createMap(t, value);
</code></pre>

<p>}
```</p>

<p>下面是一个利用Thread对象作为句柄获取ThreadLocalMap对象的代码</p>

<p>```java
ThreadLocalMap getMap(Thread t) {</p>

<pre><code>return t.threadLocals;
</code></pre>

<p>}
```</p>

<p>上面的代码获取的实际上是Thread对象的threadLocals变量，可参考下面代码
```java
class Thread implements Runnable {</p>

<pre><code>/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */

ThreadLocal.ThreadLocalMap threadLocals = null;
</code></pre>

<p>}
```</p>

<p>而如果一开始设置，即ThreadLocalMap对象未创建，则新建ThreadLocalMap对象，并设置初始值。
```java
void createMap(Thread t, T firstValue) {</p>

<pre><code>t.threadLocals = new ThreadLocalMap(this, firstValue);
</code></pre>

<p>}
```</p>

<p>总结：实际上ThreadLocal的值是放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问，其他线程无法访问。</p>

<h2>对象存放在哪里</h2>

<p>在Java中，栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</p>

<h3>问：那么是不是说ThreadLocal的实例以及其值存放在栈上呢？</h3>

<p>其实不是，因为ThreadLocal实例实际上也是被其创建的类持有（更顶端应该是被线程持有）。而ThreadLocal的值其实也是被线程实例持有。</p>

<p><strong>它们都是位于堆上，只是通过一些技巧将可见性修改成了线程可见。</strong></p>

<p>关于堆和栈的比较，请参考<a href="http://droidyue.com/blog/2014/12/07/differences-between-stack-and-heap-in-java/">Java中的堆和栈的区别</a></p>

<h2>真的只能被一个线程访问么</h2>

<p>既然上面提到了ThreadLocal只对当前线程可见，是不是说ThreadLocal的值只能被一个线程访问呢？</p>

<p>使用InheritableThreadLocal可以实现多个线程访问ThreadLocal的值。</p>

<p>如下，我们在主线程中创建一个InheritableThreadLocal的实例，然后在子线程中得到这个InheritableThreadLocal实例设置的值。</p>

<p>```java
private void testInheritableThreadLocal() {</p>

<pre><code>final ThreadLocal threadLocal = new InheritableThreadLocal();
threadLocal.set("droidyue.com");
Thread t = new Thread() {
    @Override
    public void run() {
        super.run();
        Log.i(LOGTAG, "testInheritableThreadLocal =" + threadLocal.get());
    }
};

t.start();
</code></pre>

<p>}
<code>
上面的代码输出的日志信息为
</code>
I/MainActivity( 5046): testInheritableThreadLocal =droidyue.com
<code>
使用InheritableThreadLocal可以将某个线程的ThreadLocal值在其子线程创建时传递过去。因为在线程创建过程中，有相关的处理逻辑。
</code>java
//Thread.java
 private void init(ThreadGroup g, Runnable target, String name,</p>

<pre><code>                  long stackSize, AccessControlContext acc) {
    //code goes here
    if (parent.inheritableThreadLocals != null)
        this.inheritableThreadLocals =
            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
    /* Stash the specified stack size in case the VM cares */
    this.stackSize = stackSize;

    /* Set thread ID */
    tid = nextThreadID();
</code></pre>

<p>}
```
上面代码就是在线程创建的时候，复制父线程的inheritableThreadLocals的数据。</p>

<h2>会导致内存泄露么</h2>

<p>有网上讨论说ThreadLocal会导致内存泄露，原因如下</p>

<ul>
<li>首先ThreadLocal实例被线程的ThreadLocalMap实例持有，也可以看成被线程持有。</li>
<li>如果应用使用了线程池，那么之前的线程实例处理完之后出于复用的目的依然存活</li>
<li>所以，ThreadLocal设定的值被持有，导致内存泄露。</li>
</ul>


<p>上面的逻辑是清晰的，可是ThreadLocal并不会产生内存泄露，因为ThreadLocalMap做选择key的时候，并不是直接选择ThreadLocal实例，而是ThreadLocalMap实例的弱引用。
```java
static class ThreadLocalMap {</p>

<p>/<em>*
* The entries in this hash map extend WeakReference, using
* its main ref field as the key (which is always a
* ThreadLocal object).  Note that null keys (i.e. entry.get()
* == null) mean that the key is no longer referenced, so the
* entry can be expunged from table.  Such entries are referred to
* as &ldquo;stale entries&rdquo; in the code that follows.
</em>/</p>

<pre><code>static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
    /** The value associated with this ThreadLocal. */
    Object value;

    Entry(ThreadLocal&lt;?&gt; k, Object v) {
        super(k);
        value = v;
    }
}
</code></pre>

<p>}
```
所以实际上从ThreadLocal设计角度来说是不会导致内存泄露的。</p>

<h2>使用场景</h2>

<ul>
<li>实现单个线程单例以及单个线程上下文信息存储，比如交易id等</li>
<li>实现线程安全，非线程安全的对象使用ThreadLocal之后就会变得线程安全，因为每个线程都会有一个对应的实例</li>
<li>承载一些线程相关的数据，避免在方法中来回传递参数</li>
</ul>


<h2>参考文章</h2>

<ul>
<li><a href="http://tutorials.jenkov.com/java-concurrency/threadlocal.html">Java ThreadLocal</a></li>
<li><a href="http://cs.oswego.edu/pipermail/concurrency-interest/2007-October/004456.html">Threadlocals and memory leaks in J2EE</a></li>
<li><a href="http://veerasundar.com/blog/2010/11/java-thread-local-how-to-use-and-code-sample/">Java Thread Local – How to use and code sample</a></li>
<li><a href="http://javarevisited.blogspot.hk/2012/05/how-to-use-threadlocal-in-java-benefits.html">ThreadLocal in Java &ndash; Example Program and Tutorial</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入探索Java 8 Lambda表达式]]></title>
    <link href="http://droidyue.com/blog/2015/11/28/article-java-8-lambdas-a-peek-under-the-hood/"/>
    <updated>2015-11-28T19:05:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/11/28/article-java-8-lambdas-a-peek-under-the-hood</id>
    <content type="html"><![CDATA[<h2>版权说明</h2>

<p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/Java-8-Lambdas-A-Peek-Under-the-Hood">http://www.infoq.com/cn/articles/Java-8-Lambdas-A-Peek-Under-the-Hood</a>。如需转载，请与 InfoQ 中文站联系。</p>

<h2>正文</h2>

<p>2014年3月，Java 8发布，Lambda表达式作为一项重要的特性随之而来。或许现在你已经在使用Lambda表达式来书写简洁灵活的代码。比如，你可以使用Lambda表达式和新增的流相关的API，完成如下的大量数据的查询处理：
```
int total = invoices.stream()</p>

<pre><code>                .filter(inv -&gt; inv.getMonth() == Month.JULY)
                .mapToInt(Invoice::getAmount)
                .sum();
</code></pre>

<p>```
上面的示例代码描述了如何从一打发票中计算出7月份的应付款总额。其中我们使用Lambda表达式过滤出7月份的发票，使用方法引用来提取出发票的金额。</p>

<!--more-->


<p>到这里，你可能会对Java编译器和JVM内部如何处理Lambda表达式和方法引用比较好奇。可能会提出这样的问题，Lambda表达式会不会就是匿名内部类的语法糖呢？毕竟上面的示例代码可以使用匿名内部类实现，将Lambda表达式的方法体实现移到匿名内部类对应的方法中即可，但是我们并不赞成这样做。如下为匿名内部类实现版本：
```
int total = invoices.stream()</p>

<pre><code>                .filter(new Predicate&lt;Invoice&gt;() {
                    @Override
                    public boolean test(Invoice inv) {
                        return inv.getMonth() == Month.JULY;
                    }
                })
                .mapToInt(new ToIntFunction&lt;Invoice&gt;() {
                    @Override
                    public int applyAsInt(Invoice inv) {
                        return inv.getAmount();
                    }
                })
                .sum();
</code></pre>

<p>```</p>

<p>本文将会介绍为什么Java编译器没有采用内部类的形式处理Lambda表达式，并解密Lambda表达式和方法引用的内部实现。接着介绍字节码生成并简略分析Lambda表达式理论上的性能。最后，我们将讨论一下实践中Lambda表达式的性能问题。</p>

<h2>为什么匿名内部类不好？</h2>

<p>实际上，匿名内部类存在着影响应用性能的问题。</p>

<p>首先，编译器会为每一个匿名内部类创建一个类文件。创建出来的类文件的名称通常按照这样的规则 ClassName$1， 其中ClassName就是匿名内部类定义所属的类的名称，ClassName后面需要接上$符合和数字。生成如此多的文件就会带来问题，因为类在使用之前需要加载类文件并进行验证，这个过程则会影响应用的启动性能。类文件的加载很有可能是一个耗时的操作，这其中包含了磁盘IO和解压JAR文件。</p>

<p>假设Lambda表达式翻译成匿名内部类，那么每一个Lambda表达式都会有一个对应的类文件。随着匿名内部类进行加载，其必然要占用JVM中的元空间（从Java 8开始永久代的一种替代实现）。如果匿名内部类的方法被JIT编译成机器代码，则会存储到代码缓存中。同时，匿名内部类都需要实例化成独立的对象。以上关于匿名内部类的种种会使得应用的内存占用增加。因此我们有必要引入新的缓存机制减少过多的内存占用，这也就意味着我们需要引入某种抽象层。</p>

<p>最重要的，一旦Lambda表达式使用了匿名内部类实现，就会限制了后续Lambda表达式实现的更改，降低了其随着JVM改进而改进的能力。</p>

<p>我们看一下下面的这段代码：
```
import java.util.function.Function;
public class AnonymousClassExample {</p>

<pre><code>Function&lt;String, String&gt; format = new Function&lt;String, String&gt;() {
    public String apply(String input){
        return Character.toUpperCase(input.charAt(0)) + input.substring(1);
    }
};
</code></pre>

<p>}
<code>
使用这个命令我们可以检查任何类文件生成的字节码
</code>
javap -c -v ClassName
<code>
示例中使用Function创建的匿名内部类对应的字节码如下：
</code>
0: aload_0     <br/>
1: invokespecial #1 // Method java/lang/Object.&ldquo;<init>&rdquo;:()V
4: aload_0     <br/>
5: new           #2 // class AnonymousClassExample$1
8: dup         <br/>
9: aload_0     <br/>
10: invokespecial #3 // Method AnonymousClass$1.&ldquo;<init>&rdquo;:(LAnonymousClassExample;)V
13: putfield      #4 // Field format:Ljava/util/function/Function;
16: return<br/>
```
上述字节码的含义如下：</p>

<ul>
<li>第5行，使用字节码操作new创建了类型AnonymousClassExample$1的一个对象，同时将新创建的对象的的引用压入栈中。</li>
<li>第8行，使用dup操作复制栈上的引用。</li>
<li>第10行，上面的复制的引用被指令invokespecial消耗使用，用来初始化匿名内部类实例。</li>
<li>第13行，栈顶依旧是创建的对象的引用，这个引用通过putfield指令保存到AnonymousClassExample类的format属性中。</li>
</ul>


<p>AnonymousClassExample$1就是由编译器生成的匿名内部类的名称。如果想更加验证的话，你可以检查AnonymousClassExample$1这个类文件，你会发现这个类就是Function接口的实现。</p>

<p>将Lambda表达式翻译成匿名内部类会限制以后可能进行的优化（比如缓存）。因为一旦使用了翻译成匿名内部类形式，那么Lambda表达式则和匿名内部类的字节码生成机制绑定。因而，Java语言和JVM工程师需要设计一个稳定并且具有足够信息的二进制表示形式来支持以后的JVM实现策略。下面的部分将介绍不使用匿名内部类机制，Lambda表达式是如何工作的。</p>

<h2>Lambdas表达式和invokedynamic</h2>

<p>为了解决前面提到的担心，Java语言和JVM工程师决定将翻译策略推迟到运行时。利用Java 7引入的invokedynamic字节码指令我们可以高效地完成这一实现。将Lambda表达式转化成字节码只需要如下两步：</p>

<p>1.生成一个invokedynamic调用点，也叫做Lambda工厂。当调用时返回一个Lambda表达式转化成的<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html">函数式接口</a>实例。</p>

<p>2.将Lambda表达式的方法体转换成方法供invokedynamic指令调用。</p>

<p>为了阐明上述的第一步，我们这里举一个包含Lambda表达式的简单类：
```
import java.util.function.Function;</p>

<p>public class Lambda {</p>

<pre><code>Function&lt;String, Integer&gt; f = s -&gt; Integer.parseInt(s);
</code></pre>

<p>}
<code>
查看上面的类经过编译之后生成的字节码：
</code>
0: aload_0
1: invokespecial #1 // Method java/lang/Object.&ldquo;<init>&rdquo;:()V
4: aload_0
5: invokedynamic #2, 0 // InvokeDynamic</p>

<pre><code>              #0:apply:()Ljava/util/function/Function;
</code></pre>

<p>10: putfield #3 // Field f:Ljava/util/function/Function;
13: return
```
需要注意的是，方法引用的编译稍微有点不同，因为javac不需要创建一个合成的方法，javac可以直接访问该方法。</p>

<p>Lambda表达式转化成字节码的第二步取决于Lambda表达式是否为对变量捕获。Lambda表达式方法体需要访问外部的变量则为对变量捕获，反之则为对变量不捕获。</p>

<p>对于不进行变量捕获的Lambda表达式，其方法体实现会被提取到一个与之具有相同签名的静态方法中，这个静态方法和Lambda表达式位于同一个类中。比如上面的那段Lambda表达式会被提取成类似这样的方法：
```
static Integer lambda$1(String s) {</p>

<pre><code>return Integer.parseInt(s);
</code></pre>

<p>}
```
需要注意的是，这里的$1并不是代表内部类，这里仅仅是为了展示编译后的代码而已。</p>

<p>对于捕获变量的Lambda表达式情况有点复杂，同前面一样Lambda表达式依然会被提取到一个静态方法中，不同的是被捕获的变量同正常的参数一样传入到这个方法中。在本例中，采用通用的翻译策略预先将被捕获的变量作为额外的参数传入方法中。比如下面的示例代码：
<code>
int offset = 100;
Function&lt;String, Integer&gt; f = s -&gt; Integer.parseInt(s) + offset;
</code>
对应的翻译后的实现方法为：
```
static Integer lambda$1(int offset, String s) {</p>

<pre><code>return Integer.parseInt(s) + offset;
</code></pre>

<p>}
```</p>

<p>需要注意的是编译器对于Lambda表达式的翻译策略并非固定的，因为这样invokedynamic可以使编译器在后期使用不同的翻译实现策略。比如，被捕获的变量可以放入数组中。如果Lambda表达式用到了类的实例的属性，其对应生成的方法可以是实例方法，而不是静态方法，这样可以避免传入多余的参数。</p>

<h2>性能分析</h2>

<p>Lambda表达式最主要的优势表现在性能方面，虽然使用它很轻松的将很多行代码缩减成一句，但是其内部实现却不这么简单。下面对内部实现的每一步进行性能分析。</p>

<p>第一步就是连接，对应的就是我们上面提到的Lambda工厂。这一步相当于匿名内部类的类加载过程。来自Oracle的Sergey Kuksenko发布过相关的<a href="http://www.google.com/url?q=http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Fjvmls2013kuksen-2014088.pdf&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNEvk_uT2Gf5fi6oU2cBm29FJ9X0ZA">性能报告</a>，并且他也在2013 <a href="https://www.google.com/url?q=https%3A%2F%2Fmedianetwork.oracle.com%2Fvideo%2Fplayer%2F2623576348001&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHq8XfMibI94INM3Zl8UGzk-kKbew">JVM语言大会</a>就该话题做过<a href="http://www.oracle.com/technetwork/java/jvmls2013kuksen-2014088.pdf">分享</a>。报告表明，Lambda工厂的预热准备需要消耗时间，并且这个过程比较慢。伴随着更多的调用点连接，代码被频繁调用后（比如被JIT编译优化）性能会提升。另一方面如果连接处于不频繁调用的情况，那么Lambda工厂方式也会比匿名内部类加载要快，最高可达100倍。</p>

<p>第二步就是捕获变量。正如我们前面提到的，如果是不进行捕获变量，这一步会自动进行优化，避免在基于Lambda工厂实现下额外创建对象。对于匿名内部类而言，这一步对应的是创建外部类的实例，为了优化内部类这一步的问题，我们需要手动的修改代码，如创建一个对象，并将它设置给一个静态的属性。如下述代码：
```java
// Hoisted Function
public static final Function&lt;String, Integer> parseInt = new Function&lt;String, Integer>() {</p>

<pre><code>public Integer apply(String arg) {
    return Integer.parseInt(arg);
}
</code></pre>

<p>};</p>

<p>// Usage:
int result = parseInt.apply(“123”);
```</p>

<p>第三部就是真实方法的调用。在这一步中匿名内部类和Lambda表达式执行的操作相同，因此没有性能上的差别。不进行捕获的Lambda表达式要比进行static优化过的匿名内部类较优。进行变量捕获的Lambda表达式和匿名内部类表达式性能大致相同。</p>

<p>在这一节中，我们明显可以看到Lambda表达式的实现表现良好，匿名内部类通常需要我们手动的进行优化来避免额外对象生成，而对于不进行变量捕获的Lambda表达式，JVM已经为我们做好了优化。</p>

<h2>实践中的性能分析</h2>

<p>理解了Lambda的性能模型很是重要，但是实际应用中的总体性能如何呢？我们在使用Java 8 编写了一些软件项目，一般都取得了很好的效果。非变量捕获的Lambda表达式给我们带来了很大的帮助。这里有一个很特殊的例子描述了关于优化方向的一些有趣的问题。</p>

<p>这个例子的场景是代码需要运行在一个要求GC暂定时间越少越好的系统上。因而我们需要避免创建大量的对象。在这个工程中，我们使用了大量的Lambda表达式来实现回调处理。然而在这些使用Lambda实现的回调中很多并没有捕获局部变量，而是需要引用当前类的变量或者调用当前类的方法。然而目前仍需要对象分配。下面就是我们提到的例子的代码：
```java
public MessageProcessor() {}</p>

<p>public int processMessages() {</p>

<pre><code>return queue.read(obj -&gt; {
    if (obj instanceof NewClient) {
        this.processNewClient((NewClient) obj);
    } 
    ...
});
</code></pre>

<p>}
```</p>

<p>有一个简单的办法解决这个问题，我们将Lambda表达式的代码提前到构造方法中，并将其赋值给一个成员属性。在调用点我们直接引用这个属性即可。下面就是修改后的代码：
```java
private final Consumer<Msg> handler;</p>

<p>public MessageProcessor() {</p>

<pre><code>handler = obj -&gt; {
    if (obj instanceof NewClient) {
        this.processNewClient((NewClient) obj);
    }
    ...
};
</code></pre>

<p>}</p>

<p>public int processMessages() {</p>

<pre><code>return queue.read(handler);
</code></pre>

<p>}
```
然而上面的修改后代码给却给整个工程带来了一个严重的问题：性能分析表明，这种修改产生很大的对象申请，其产生的内存申请在总应用的60%以上。</p>

<p>类似这种无关上下文的优化可能带来其他问题。</p>

<p>  1.纯粹为了优化的目的，使用了非惯用的代码写法，可读性会稍差一些。<br/>
  2.内存分配方面的问题，示例中为MessageProcessor增加了一个成员属性，使得MessageProcessor对象需要申请更大的内存空间。Lambda表达式的创建和捕获位于构造方式中，使得MessageProcessor的构造方法调用缓慢一些。</p>

<p>我们遇到这种情况，需要进行内存分析，结合合理的业务用例来进行优化。有些情况下，我们使用成员属性确保为经常调用的Lambda表达式只申请一个对象，这样的缓存策略大有裨益。任何性能调优的科学的方法都可以进行尝试。</p>

<p>上述的方法也是其他程序员对Lambda表达式进行优化应该使用的。书写整洁，简单，函数式的代码永远是第一步。任何优化，如上面的提前代码作为成员属性，都必须结合真实的具体问题进行处理。变量捕获并申请对象的Lambda表达式并非不好，就像我们我们写出<code>new Foo()</code>代码并非一无是处一样。</p>

<p>除此之外，我们想要写出最优的Lambda表达式，常规书写很重要。如果一个Lambda表达式用来表示一个简单的方法，并且没有必要对上下文进行捕获，大多数情况下，一切以简单可读即可。</p>

<h2>总结</h2>

<p>在这片文章中，我们研究了Lambda表达式不是简单的匿名内部类的语法糖，为什么匿名内部类不是Lambda表达式的内部实现机制以及Lambda表达式的具体实现机制。对于大多数情况来说，Lambda表达式要比匿名内部类性能更优。然而现状并非完美，基于测量驱动优化，我们仍然有很大的提升空间。</p>

<p>Lambda表达式的这种实现形式并非Java 8 所有。Scala曾经通过生成匿名内部类的形式支持Lambda表达式。在Scala 2.12版本，Lambda的实现形式替换为Java 8中的Lambda 工厂机制。后续其他可以在JVM上运行的语言也可能支持Lambda的这种机制。</p>

<h2>关于作者</h2>

<p>Richard Warburton是一位资深专家，善于技术攻坚。最近，他写了一个关于<a href="http://tinyurl.com/java8lambdas">Java 8 Lambda表达式</a>的书，由O'Reilly出版，同时他也在<a href="http://java8training.com/">java8training</a>网站为Java程序员教授函数式编程。他涉猎的领域相当广泛，如数据分析，静态分析，编译器和网络协议等领域。他是伦敦Java协会的Leader，并举办OpenJdk hack活动。他进行了多次演讲，曾在Devoxx, JavaOne, JFokus, Devoxx UK, Geecon, Oredev, JAX London 和 Codemotion等会议做分享。除上述之外，他还是Warwick大学的计算机科学博士。</p>

<p>Raoul-Gabriel Urma是剑桥大学计算机科学的博士生。他也是Manning出版社出版的<a href="http://manning.com/urma/">Java 8 in Action: Lambdas, streams, and functional-style programming</a>的联合作者。他发表过10多篇论文，也在国际会议做过20多场分享。他既在诸如Google，eBay，Oracle和Goldman Sachs这样的大公司工作过，也参与过小的创业公司。Raoul也是皇家艺术协会的一员。他的Twitter是@raoulUK。</p>

<p>Mario Fusco是来自Red Hat的高级软件工程师，他的工作是开发Drools核心开发和JBoss规则引擎。他有着相当丰富的Java经验，参与并领导了很多业界企业级的项目。他的兴趣是函数式编程和领域专用语言。由于对着两项的热爱，他创建了一个叫做lambdaj的开源库，目的是提供一个管理集合的Java DSL实现，使得使用更加函数式编码化。他的Twitter ID是@mariofusco。</p>

<p><strong>查看英文原文：</strong><a href="http://www.infoq.com/articles/Java-8-Lambdas-A-Peek-Under-the-Hood">Java 8 Lambdas &ndash; A Peek Under the Hood</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java永久代去哪儿了]]></title>
    <link href="http://droidyue.com/blog/2015/08/22/where-has-the-java-permgen-gone/"/>
    <updated>2015-08-22T17:01:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/08/22/where-has-the-java-permgen-gone</id>
    <content type="html"><![CDATA[<h2>版权说明</h2>

<p>本文为 InfoQ 中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/Java-PERMGEN-Removed">Java永久代去哪儿了</a>。如需转载，请与 InfoQ 中文站联系。</p>

<h2>摘要</h2>

<p>在JDK8之前，类的元数据和常量都存放在一个与堆内存相邻的数据区，即永久代。但是在这种情况下有一个问题，如果类的元数据大小超过了应用的可分配内存，那么就会出现内存溢出问题。在JDK8之后，永久代被移除，原本存储在永久代的数据将存放在一个叫做元空间的本地内存区域。</p>

<!--more-->


<p>在Java虚拟机（以下简称JVM）中，类包含其对应的元数据，比如类的层级信息，方法数据和方法信息（如字节码，栈和变量大小），运行时常量池，已确定的符号引用和虚方法表。</p>

<p>在过去（当自定义类加载器使用不普遍的时候），类几乎是“静态的”并且很少被卸载和回收，因此类也可以被看成“永久的”。另外由于类作为JVM实现的一部分，它们不由程序来创建，因为它们也被认为是“非堆”的内存。</p>

<p>在JDK8之前的HotSpot虚拟机中，类的这些“永久的”数据存放在一个叫做永久代的区域。永久代一段连续的内存空间，我们在JVM启动之前可以通过设置-XX:MaxPermSize的值来控制永久代的大小，32位机器默认的永久代的大小为64M，64位的机器则为85M。永久代的垃圾回收和老年代的垃圾回收是绑定的，一旦其中一个区域被占满，这两个区都要进行垃圾回收。但是有一个明显的问题，由于我们可以通过‑XX:MaxPermSize 设置永久代的大小，一旦类的元数据超过了设定的大小，程序就会耗尽内存，并出现内存溢出错误(OOM)。</p>

<p><strong>备注</strong>：在JDK7之前的HotSpot虚拟机中，纳入字符串常量池的字符串被存储在永久代中，因此导致了一系列的性能问题和内存溢出错误。想要了解这些永久代移除这些字符串的信息，请访问<a href="http://bugs.java.com/view_bug.do?bug_id=6962931">这里</a>查看。</p>

<h2>辞永久代，迎元空间</h2>

<p>随着Java8的到来，我们再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域就是我们要提到的元空间。</p>

<p>这项改动是很有必要的，因为对永久代进行调优是很困难的。永久代中的元数据可能会随着每一次Full GC发生而进行移动。并且为永久代设置空间大小也是很难确定的，因为这其中有很多影响因素，比如类的总数，常量池的大小和方法数量等。</p>

<p>同时，HotSpot虚拟机的每种类型的垃圾回收器都需要特殊处理永久代中的元数据。将元数据从永久代剥离出来，不仅实现了对元空间的无缝管理，还可以简化Full GC以及对以后的并发隔离类元数据等方面进行优化。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/removal_of_permen_gen.jpg">http://7jpolu.com1.z0.glb.clouddn.com/removal_of_permen_gen.jpg</a>"></p>

<h2>移除永久代的影响</h2>

<p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。因此，我们就不会遇到永久代存在时的内存溢出错误，也不会出现泄漏的数据移到交换区这样的事情。最终用户可以为元空间设置一个可用空间最大值，如果不进行设置，JVM会自动根据类的元数据大小动态增加元空间的容量。</p>

<p><strong>注意</strong>：永久代的移除并不代表自定义的类加载器泄露问题就解决了。因此，你还必须监控你的内存消耗情况，因为一旦发生泄漏，会占用你的大量本地内存，并且还可能导致交换区交换更加糟糕。</p>

<h2>元空间内存管理</h2>

<p>元空间的内存管理由元空间虚拟机来完成。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。在元空间中，类和其元数据的生命周期和其对应的类加载器是相同的。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。</p>

<p>我们从行文到现在提到的元空间稍微有点不严谨。准确的来说，每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。</p>

<p>元空间虚拟机负责元空间的分配，其采用的形式为组块分配。组块的大小因类加载器的类型而异。在元空间虚拟机中存在一个全局的空闲组块列表。当一个类加载器需要组块时，它就会从这个全局的组块列表中获取并维持一个自己的组块列表。当一个类加载器不再存活，那么其持有的组块将会被释放，并返回给全局组块列表。类加载器持有的组块又会被分成多个块，每一个块存储一个单元的元信息。组块中的块是线性分配（指针碰撞分配形式）。组块分配自内存映射区域。这些全局的虚拟内存映射区域以链表形式连接，一旦某个虚拟内存映射区域清空，这部分内存就会返回给操作系统。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/mmap_virtual_space.jpg">http://7jpolu.com1.z0.glb.clouddn.com/mmap_virtual_space.jpg</a>"></p>

<p>上图展示的是虚拟内存映射区域如何进行元组块的分配。类加载器1和3表明使用了反射或者为匿名类加载器，他们使用了特定大小组块。 而类加载器2和4根据其内部条目的数量使用小型或者中型的组块。</p>

<h2>元空间调优与工具</h2>

<p>正如上面提到的，元空间虚拟机控制元空间的增长。但是有些时候我们想限制其增长，比如通过显式在命令行中设置-XX:MaxMetaspaceSize。默认情况下，-XX:MaxMetaspaceSize的值没有限制，因此元空间甚至可以延伸到交换区，但是这时候当我们进行本地内存分配时将会失败。</p>

<p>对于一个64位的服务器端JVM来说，其默认的–XX:MetaspaceSize值为21MB。这就是初始的高水位线。一旦触及到这个水位线，Full GC将会被触发并卸载没有用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，这个高水位线则上升。如果释放空间过多，则高水位线下降。如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志我们可以观察到Full GC多次调用。为了避免频繁的GC，建议将–XX:MetaspaceSize设置为一个相对较高的值。</p>

<p>经过多次GC之后，元空间虚拟机自动调节高水位线，以此来推迟下一次垃圾回收到来。</p>

<p>有这样两个选项 ‑XX:MinMetaspaceFreeRatio和‑XX:MaxMetaspaceFreeRatio，他们类似于GC的FreeRatio选项，用来设置元空间空闲比例的最大值和最小值。我们可以通过命令行对这两个选项设置对应的值。</p>

<p>下面是一些改进的工具，用来获取更多关于元空间的信息。</p>

<ul>
<li>jmap -clstats PID 打印类加载器数据。（-clstats是-permstat的替代方案，在JDK8之前，-permstat用来打印类加载器的数据）。下面的例子输出就是DaCapo’s Avrora benchmark程序的类加载器数据
```bash
$ jmap -clstats <PID>
Attaching to process ID 6476, please wait&hellip;
Debugger attached successfully.
Server compiler detected.
JVM version is 25.5-b02
finding class loader instances ..done.
computing per loader stat ..done.
please wait.. computing liveness.liveness analysis may be inaccurate &hellip;
class_loader classes    bytes parent_loader     alive? type</li>
</ul>


<p><bootstrap>     655  1222734     null   live   <internal>
0x000000074004a6c0  0   0   0x000000074004a708  dead    java/util/ResourceBundle$RBClassLoader@0x00000007c0053e20
0x000000074004a760  0   0     null      dead    sun/misc/Launcher$ExtClassLoader@0x00000007c002d248
0x00000007401189c8  1   1471 0x00000007400752f8 dead    sun/reflect/DelegatingClassLoader@0x00000007c0009870
0x000000074004a708  116   316053    0x000000074004a760   dead   sun/misc/Launcher$AppClassLoader@0x00000007c0038190
0x00000007400752f8  538  773854 0x000000074004a708   dead   org/dacapo/harness/DacapoClassLoader@0x00000007c00638b0
total = 6   1310   2314112          N/A    alive=1, dead=5  N/A  <br/>
```</p>

<ul>
<li><strong>jstat -gc LVMID</strong> 用来打印元空间的信息，具体内容如下</li>
</ul>


<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/jstat.jpg">http://7jpolu.com1.z0.glb.clouddn.com/jstat.jpg</a>">
  * <strong>jcmd PID GC.class_stats</strong> 一个新的诊断命令，用来连接到运行的JVM并输出详尽的类元数据的柱状图。</p>

<p><strong>注意</strong>：在JDK 6 build 13下，需要加上<strong>‑XX:+UnlockDiagnosticVMOptions</strong> 才能正确使用jcmd这个命令。</p>

<p>```
$ jcmd <PID> help GC.class_stats
9522:
GC.class_stats
Provide statistics about Java class meta data. Requires -XX:+UnlockDiagnosticVMOptions.</p>

<p>Impact: High: Depends on Java heap size and content.</p>

<p>Syntax : GC.class_stats [options] [<columns>]</p>

<p>Arguments:</p>

<pre><code>columns : [optional] Comma-separated list of all the columns to show. If not specified, the following columns are shown: InstBytes,KlassBytes,CpAll,annotations,MethodCount,Bytecodes,MethodAll,ROAll,RWAll,Total (STRING, no default value)
</code></pre>

<p>Options: (options must be specified using the <key> or <key>=<value> syntax)</p>

<pre><code>-all : [optional] Show all columns (BOOLEAN, false)
-csv : [optional] Print in CSV (comma-separated values) format for spreadsheets (BOOLEAN, false)
-help : [optional] Show meaning of all the columns (BOOLEAN, false)
</code></pre>

<p>```
<strong>提示</strong>：如果想了解字段的更多信息，请访问<a href="https://bugs.openjdk.java.net/secure/attachment/11600/ver_010_help.txt">这里</a></p>

<p>使用jcmd的示例输出
```
 $ jcmd <PID> GC.class_stats</p>

<p>7140:
Index Super InstBytes KlassBytes annotations   CpAll MethodCount Bytecodes MethodAll   ROAll   RWAll   Total ClassName</p>

<pre><code>1   -1  426416      480         0       0           0       0       0   24  576     600 [C
2   -1  290136      480         0       0           0       0       0   40  576     616 [Lavrora.arch.legacy.LegacyInstr;
3   -1  269840      480         0       0           0       0       0   24  576     600 [B
4   43  137856      648         0   19248       129     4886    25288   16368   30568   46936 java.lang.Class
5   43  136968      624         0   8760        94      4570    33616   12072   32000   44072 java.lang.String
6   43  75872       560         0   1296        7       149     1400    880 2680    3560 java.util.HashMap$Node
7   836     57408       608         0   720         3       69      1480    528 2488    3016 avrora.sim.util.MulticastFSMProbe
8   43  55488       504         0   680         1       31      440     280 1536    1816 avrora.sim.FiniteStateMachine$State
9   -1  53712       480         0       0           0       0       0   24  576     600 [Ljava.lang.Object;
</code></pre>

<p>   10   -1  49424       480         0       0           0       0       0   24  576     600 [I
   11   -1  49248       480         0       0           0       0       0   24  576     600 [Lavrora.sim.platform.ExternalFlash$Page;
   12   -1  24400       480         0       0           0       0       0   32  576     608 [Ljava.util.HashMap$Node;
   13   394     21408       520         0   600         3       33      1216    432 2080    2512 avrora.sim.AtmelInterpreter$IORegBehavior
   14   727     19800       672         0   968         4       71      1240    664 2472    3136 avrora.arch.legacy.LegacyInstr$MOVW
…<snipped>
…<snipped>
1299  1300      0       608         0   256         1       5       152     104 1024    1128 sun.util.resources.LocaleNamesBundle
 1300  1098         0       608         0   1744        10      290     1808    1176    3208    4384 sun.util.resources.OpenListResourceBundle
 1301  1098         0       616         0   2184        12      395     2200    1480    3800    5280 sun.util.resources.ParallelListResourceBundle</p>

<pre><code>        2244312     794288      2024 2260976    12801   561882   3135144 1906688 4684704 6591392 Total
            34.0%   12.1%       0.0%   34.3%        -   8.5%    47.6%   28.9%   71.1%  100.0%
</code></pre>

<p>Index Super InstBytes KlassBytes annotations   CpAll MethodCount Bytecodes MethodAll   ROAll   RWAll   Total ClassName
```</p>

<h2>存在的问题</h2>

<p>前面已经提到，元空间虚拟机采用了组块分配的形式，同时区块的大小由类加载器类型决定。类信息并不是固定大小，因此有可能分配的空闲区块和类需要的区块大小不同，这种情况下可能导致碎片存在。元空间虚拟机目前并不支持压缩操作，所以碎片化是目前最大的问题。</p>

<p><img class="<a" src="href="http://7jpolu.com1.z0.glb.clouddn.com/fragment_issue.jpg">http://7jpolu.com1.z0.glb.clouddn.com/fragment_issue.jpg</a>"></p>

<h2>关于作者</h2>

<p>Monica Beckwith是一位在硬件行业有着10多年经验的性能研究工程师。她目前在Servergy公司任性能架构师一职。该公司为一家提供高效服务器的创业公司。此外，Monica曾在Sun，Oracle和AMD等公司致力于服务器端JVM优化。Monica还是JavaOne 2013会议的演讲嘉宾。想要关注的可以在twitter上查找@mon_beck。</p>

<p><strong>查看英文原文：</strong><a href="http://www.infoq.com/articles/Java-PERMGEN-Removed">Where Has the Java PermGen Gone?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[垃圾回收器如何处理循环引用]]></title>
    <link href="http://droidyue.com/blog/2015/06/05/how-garbage-collector-handles-circular-references/"/>
    <updated>2015-06-05T23:24:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/06/05/how-garbage-collector-handles-circular-references</id>
    <content type="html"><![CDATA[<p>垃圾回收是一门编程语言中必不可少的一部分，不论是手动释放内存的C和C++，还是自动回收垃圾的Java和C#等语言。对于Java这样的语言，一般的开发者不强求关心对象回收和内存释放，但是理解垃圾回收对开发工作还是大有裨益的。</p>

<!--more-->


<p>在编程语言中，普遍存在着循环引用这样的问题，垃圾回收器是如何处理循环引用呢，常用的垃圾回收有引用计数和引用对象遍历两种实现，它们各自又是如何处理循环引用呢？本文讲以JVM中的GC为例逐一回答这些问题。</p>

<h2>何为循环引用</h2>

<p>如果有两个或者以上的对象，它们彼此引用，就会造成循环引用。如下面的例子
```java
class Node {</p>

<pre><code>Node next;
</code></pre>

<p>}</p>

<p>Node a = new Node();
Node b = new Node();
a.next = b;
b.next = a;
```
代码中，a对象引用了b对象，b对象也引用了a对象，这种情况下a对象和b对象就形成了循环引用。</p>

<h2>引用计数GC处理</h2>

<h3>什么是引用计数</h3>

<p>引用计数是一种垃圾回收的形式，每一个对象都会有一个计数来记录有多少指向它的引用。其引用计数会变换如下面的场景</p>

<ul>
<li>当对象增加一个引用，比如赋值给变量，属性或者传入一个方法，引用计数执行加1运算。</li>
<li>当对象减少一个引用，比如变量离开作用域，属性被赋值为另一个对象引用，属性所在的对象被回收或者之前传入参数的方法返回，引用计数执行减1操作。</li>
<li>当引用计数变为0，代表该对象不被引用，可以标记成垃圾进行回收。</li>
</ul>


<h3>如何处理</h3>

<p>实际上单纯的基于引用计数实现的计数器无法处理循环引用带来的问题。</p>

<p>CPython的垃圾回收就是采用引用计数,采用引用计数的主垃圾回收器会清理垃圾，对于那些因为循环引用无法清理的对象，CPython会不时启动一个辅助的基于引用遍历的垃圾回收器来清理它们。</p>

<h2>引用遍历GC处理</h2>

<h3>什么是引用对象遍历</h3>

<p>垃圾回收器从被称为GC Roots的点开始遍历遍历对象，凡是可以达到的点都会标记为存活，堆中不可到达的对象都会标记成垃圾，然后被清理掉。
GC Roots有哪些</p>

<ul>
<li>类，由系统类加载器加载的类。这些类从不会被卸载，它们可以通过静态属性的方式持有对象的引用。注意，一般情况下由自定义的类加载器加载的类不能成为GC Roots</li>
<li>线程，存活的线程</li>
<li>Java方法<a href="http://droidyue.com/blog/2014/12/07/differences-between-stack-and-heap-in-java/">栈</a>中的局部变量或者参数</li>
<li><a href="http://droidyue.com/blog/2014/12/21/java-runtime-data-areas/">JNI方法栈</a>中的局部变量或者参数</li>
<li>JNI全局引用</li>
<li>用做同步监控的对象</li>
<li>被JVM持有的对象，这些对象由于特殊的目的不被GC回收。这些对象可能是系统的类加载器，一些重要的异常处理类，一些为处理异常预留的对象，以及一些正在执行类加载的自定义的类加载器。但是具体有哪些前面提到的对象依赖于具体的JVM实现。</li>
</ul>


<h3>如何处理</h3>

<p>基于引用对象遍历的垃圾回收器可以处理循环引用，只要是涉及到的对象不能从GC Roots<a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">强引用</a>可到达，垃圾回收器都会进行清理来释放内存。</p>

<h2>总结</h2>

<p>基于引用计数的垃圾回收器无法处理循环引用导致的内存泄露问题，但是其在主流的JVM中很少，几乎所有的JVM都是采用引用对象遍历的方法，垃圾回收器都会处理循环引用潜在的问题。</p>

<h2>一本书</h2>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00D2ID4PK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00D2ID4PK&amp;linkCode=as2&amp;tag=droidyue-23">深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的自动装箱与拆箱]]></title>
    <link href="http://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/"/>
    <updated>2015-04-07T07:31:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java</id>
    <content type="html"><![CDATA[<p>自动装箱和拆箱从Java 1.5开始引入，目的是将原始类型值转自动地转换成对应的对象。自动装箱与拆箱的机制可以让我们在Java的变量赋值或者是方法调用等情况下使用原始类型或者对象类型更加简单直接。</p>

<p>如果你在Java1.5下进行过编程的话，你一定不会陌生这一点，你不能直接地向集合(Collections)中放入原始类型值，因为集合只接收对象。通常这种情况下你的做法是，将这些原始类型的值转换成对象，然后将这些转换的对象放入集合中。使用Integer,Double,Boolean等这些类我们可以将原始类型值转换成对应的对象，但是从某些程度可能使得代码不是那么简洁精炼。为了让代码简练，Java 1.5引入了具有在原始类型和对象类型自动转换的装箱和拆箱机制。但是自动装箱和拆箱并非完美，在使用时需要有一些注意事项，如果没有搞明白自动装箱和拆箱，可能会引起难以察觉的bug。</p>

<p>本文将介绍，什么是自动装箱和拆箱，自动装箱和拆箱发生在什么时候，以及要注意的事项。</p>

<!--more-->


<h2>什么是自动装箱和拆箱</h2>

<p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型byte,short,char,int,long,float,double和boolean对应的封装类为Byte,Short,Character,Integer,Long,Float,Double,Boolean。</p>

<h2>自动装箱拆箱要点</h2>

<ul>
<li>自动装箱时编译器调用valueOf将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似intValue(),doubleValue()这类的方法将对象转换成原始类型值。</li>
<li>自动装箱是将boolean值转换成Boolean对象，byte值转换成Byte对象，char转换成Character对象，float值转换成Float对象，int转换成Integer，long转换成Long，short转换成Short，自动拆箱则是相反的操作。</li>
</ul>


<h2>何时发生自动装箱和拆箱</h2>

<p>自动装箱和拆箱在Java中很常见，比如我们有一个方法，接受一个对象类型的参数，如果我们传递一个原始类型值，那么Java会自动讲这个原始类型值转换成与之对应的对象。最经典的一个场景就是当我们向ArrayList这样的容器中增加原始类型数据时或者是创建一个参数化的类，比如下面的ThreadLocal。
```java
ArrayList<Integer> intList = new ArrayList<Integer>();
intList.add(1); //autoboxing &ndash; primitive to object
intList.add(2); //autoboxing</p>

<p>ThreadLocal<Integer> intLocal = new ThreadLocal<Integer>();
intLocal.set(4); //autoboxing</p>

<p>int number = intList.get(0); // unboxing
int local = intLocal.get(); // unboxing in Java
```</p>

<h2>举例说明</h2>

<p>上面的部分我们介绍了自动装箱和拆箱以及它们何时发生，我们知道了自动装箱主要发生在两种情况，一种是赋值时，另一种是在方法调用的时候。为了更好地理解这两种情况，我们举例进行说明。</p>

<h3>赋值时</h3>

<p>这是最常见的一种情况，在Java 1.5以前我们需要手动地进行转换才行，而现在所有的转换都是由编译器来完成。
```java
//before autoboxing
Integer iObject = Integer.valueOf(3);
Int iPrimitive = iObject.intValue()</p>

<p>//after java5
Integer iObject = 3; //autobxing &ndash; primitive to wrapper conversion
int iPrimitive = iObject; //unboxing &ndash; object to primitive conversion
```</p>

<h3>方法调用时</h3>

<p>这是另一个常用的情况，当我们在方法调用时，我们可以传入原始数据值或者对象，同样编译器会帮我们进行转换。
```java
public static Integer show(Integer iParam){
   System.out.println(&ldquo;autoboxing example &ndash; method invocation i: &rdquo; + iParam);
   return iParam;
}</p>

<p>//autoboxing and unboxing in method invocation
show(3); //autoboxing
int result = show(3); //unboxing because return type of method is Integer
```</p>

<p>show方法接受Integer对象作为参数，当调用<code>show(3)</code>时，会将int值转换成对应的Integer对象，这就是所谓的自动装箱，show方法返回Integer对象，而<code>int result = show(3);</code>中result为int类型，所以这时候发生自动拆箱操作，将show方法的返回的Integer对象转换成int值。</p>

<h2>自动装箱的弊端</h2>

<p>自动装箱有一个问题，那就是在一个循环中进行自动装箱操作的情况，如下面的例子就会创建多余的对象，影响程序的性能。
<code>java
Integer sum = 0;
 for(int i=1000; i&lt;5000; i++){
   sum+=i;
}
</code></p>

<p>上面的代码<code>sum+=i</code>可以看成<code>sum = sum + i</code>，但是<code>+</code>这个操作符不适用于Integer对象，首先sum进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成Integer对象。其内部变化如下
<code>java
sum = sum.intValue() + i;
Integer sum = new Integer(result);   
</code></p>

<p>由于我们这里声明的sum为Integer类型，在上面的循环中会创建将近4000个无用的Integer对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。因此在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题。</p>

<h2>重载与自动装箱</h2>

<p>当重载遇上自动装箱时，情况会比较有些复杂，可能会让人产生有些困惑。在1.5之前，value(int)和value(Integer)是完全不相同的方法，开发者不会因为传入是int还是Integer调用哪个方法困惑，但是由于自动装箱和拆箱的引入，处理重载方法时稍微有点复杂。一个典型的例子就是ArrayList的remove方法，它有<code>remove(index)</code>和<code>remove(Object)</code>两种重载，我们可能会有一点小小的困惑，其实这种困惑是可以验证并解开的，通过下面的例子我们可以看到，当出现这种情况时，不会发生自动装箱操作。
```java
public void test(int num){</p>

<pre><code>System.out.println("method with primitive argument");
</code></pre>

<p>}</p>

<p>public void test(Integer num){</p>

<pre><code>System.out.println("method with wrapper argument");
</code></pre>

<p>}</p>

<p>//calling overloaded method
AutoboxingTest autoTest = new AutoboxingTest();
int value = 3;
autoTest.test(value); //no autoboxing
Integer iValue = value;
autoTest.test(iValue); //no autoboxing</p>

<p>Output:
method with primitive argument
method with wrapper argument
```</p>

<h2>要注意的事项</h2>

<p>自动装箱和拆箱可以使代码变得简洁,但是其也存在一些问题和极端情况下的问题，以下几点需要我们加强注意。</p>

<h3>对象相等比较</h3>

<p>这是一个比较容易出错的地方，"==&ldquo;可以用于原始值进行比较，也可以用于对象进行比较，当用于对象与对象之间比较时，比较的不是对象代表的值，而是检查两个对象是否是同一对象，这个比较过程中没有自动装箱发生。进行对象值比较不应该使用&rdquo;==&ldquo;，而应该使用对象对应的equals方法。看一个能说明问题的例子。
```java
public class AutoboxingTest {</p>

<pre><code>public static void main(String args[]) {

    // Example 1: == comparison pure primitive – no autoboxing
    int i1 = 1;
    int i2 = 1;
    System.out.println("i1==i2 : " + (i1 == i2)); // true

    // Example 2: equality operator mixing object and primitive
    Integer num1 = 1; // autoboxing
    int num2 = 1;
    System.out.println("num1 == num2 : " + (num1 == num2)); // true

    // Example 3: special case - arises due to autoboxing in Java
    Integer obj1 = 1; // autoboxing will call Integer.valueOf()
    Integer obj2 = 1; // same call to Integer.valueOf() will return same
                        // cached Object

    System.out.println("obj1 == obj2 : " + (obj1 == obj2)); // true

    // Example 4: equality operator - pure object comparison
    Integer one = new Integer(1); // no autoboxing
    Integer anotherOne = new Integer(1);
    System.out.println("one == anotherOne : " + (one == anotherOne)); // false

}
</code></pre>

<p>}</p>

<p>Output:
i1==i2 : true
num1 == num2 : true
obj1 == obj2 : true
one == anotherOne : false
```
值得注意的是第三个小例子，这是一种极端情况。obj1和obj2的初始化都发生了自动装箱操作。但是处于节省内存的考虑，JVM会缓存-128到127的Integer对象。因为obj1和obj2实际上是同一个对象。所以使用"==&ldquo;比较返回true。</p>

<h3>容易混乱的对象和原始数据值</h3>

<p>另一个需要避免的问题就是混乱使用对象和原始数据值，一个具体的例子就是当我们在一个原始数据值与一个对象进行比较时，如果这个对象没有进行初始化或者为Null，在自动拆箱过程中obj.xxxValue，会抛出NullPointerException,如下面的代码
```java
private static Integer count;</p>

<p>//NullPointerException on unboxing
if( count &lt;= 0){
  System.out.println(&ldquo;Count is not started yet&rdquo;);
}
```</p>

<h3>缓存的对象</h3>

<p>这个问题就是我们上面提到的极端情况，在Java中，会对-128到127的Integer对象进行缓存，当创建新的Integer对象时，如果符合这个这个范围，并且已有存在的相同值的对象，则返回这个对象，否则创建新的Integer对象。</p>

<p>在Java中另一个节省内存的例子就是<a href="http://droidyue.com/blog/2014/12/21/string-literal-pool-in-java/">字符串常量池</a>,感兴趣的同学可以了解一下。</p>

<h3>生成无用对象增加GC压力</h3>

<p>因为自动装箱会隐式地创建对象，像前面提到的那样，如果在一个循环体中，会创建无用的中间对象，这样会增加GC压力，拉低程序的性能。所以在写循环时一定要注意代码，避免引入不必要的自动装箱操作。</p>

<p>如想了解垃圾回收和内存优化，可以查看本文<a href="http://droidyue.com/blog/2014/11/02/note-for-google-io-memory-management-for-android-chinese-edition/">Google IO：Android内存管理主题演讲记录</a></p>

<p>总的来说，自动装箱和拆箱着实为开发者带来了很大的方便，但是在使用时也是需要格外留意，避免引起出现文章提到的问题。</p>

<h2>原文信息</h2>

<ul>
<li><a href="http://javarevisited.blogspot.com/2012/07/auto-boxing-and-unboxing-in-java-be.html">What is Autoboxing and Unboxing in Java – Example Tutorial and Corner cases</a></li>
</ul>


<h2>好书推荐</h2>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011F7WU4&amp;linkCode=as2&amp;tag=droidyue-23">Java编程思想(第4版) </a></li>
<li><a href="http://www.amazon.cn/gp/product/B00G9KF4JC/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00G9KF4JC&amp;linkCode=as2&amp;tag=droidyue-23">Java核心技术(卷1):基础知识</a></li>
<li><a href="http://www.amazon.cn/gp/product/B00D2ID4PK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00D2ID4PK&amp;linkCode=as2&amp;tag=droidyue-23">深入理解Java虚拟机:JVM高级特性与最佳实践</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
