<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2014-11-29T17:26:58+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby执行shell命令的六种方法]]></title>
    <link href="http://droidyue.com/blog/2014/11/18/six-ways-to-run-shell-in-ruby/"/>
    <updated>2014-11-18T21:17:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/11/18/six-ways-to-run-shell-in-ruby</id>
    <content type="html"><![CDATA[<p>在Ruby中，执行shell命令是一件不奇怪的事情，Ruby提供了大概6种方法供开发者进行实现。这些方法都很简单，本文将具体介绍一下如何在Ruby脚本中进行调用终端命令。</p>

<!--more-->


<h2>exec</h2>

<p>exec会将指定的命令替换掉当前进程中的操作,指定命令结束后，进程结束。
<code>ruby
exec 'echo "hello world"'
print 'abc'
</code>
执行上述的命令，结果如下，我们可以看到没有abc的输出，可以看出来，在执行<code>echo "hello world"</code>命令后进程就结束了。不会继续执行后面的<code>print 'abc'</code>。
<code>ruby
ruby testCommand.rb
hello world
</code>
使用exec一个头疼的事情就是没有办法知道shell命令执行成功还是失败。</p>

<h2>system</h2>

<p>system和exec相似，但是system执行的命令不会是在当前进程，而是在一个新创建的进程。system会返回布尔值来表明命令执行结果是成功还是失败。
```ruby
$ irb</p>

<blockquote><p>system &lsquo;echo &ldquo;hello $HOSTNAME&rdquo;&rsquo;
hello androidyue
 => true
puts $?
pid 11845 exit 0
 => nil
system &lsquo;false&rsquo;
 => false
puts $?
pid 11858 exit 1
 => nil</p>

<blockquote><p>```
system会将进程的退出的状态码赋值给$?，如果程序正常退出，$?的值为0，否则为非0。通过检测退出的状态码我们可以在ruby脚本中抛出异常或者进行重试操作。</p></blockquote></blockquote>

<p>注：在Unix-like系统中进程的退出状态码以0和非0表示，0代表成功，非0代表失败。</p>

<p>system可以告诉我们命令执行是成功还是失败，但是有些时候我们需要得到执行命令的输出，并在脚本中使用。显然system无法直接满足，需要我们使用反引号来实现。</p>

<h2>反引号(`)</h2>

<p>使用反引号是shell中常用的获取命令输出内容的方法，在ruby中也是可以，而且一点都需要做改变。使用反引号执行命令也会将命令在另一个进程中执行。
<code>ruby
1.9.3p448 :013 &gt; today = `date`
 =&gt; "Sat Nov 15 19:28:55 CST 2014\n"
1.9.3p448 :014 &gt; $?
 =&gt; #&lt;Process::Status: pid 11925 exit 0&gt;
1.9.3p448 :015 &gt; $?.to_i
 =&gt; 0
1.9.3p448 :016 &gt;
</code></p>

<p>上面的方法如此简单，我们可以直接对返回的字符串结果进行操作。</p>

<p>注意，$?已经不再是上述的那样单纯的退出状态码了，它实际上是一个Process::Status对象。我们从中不仅可以知道进程的退出状态码也可以知道进程的ID。使用<code>$?.to_i</code>会得到退出的状态码，使用<code>$?.to_s</code>会得到包含了进程id，退出状态码等信息的字符串。</p>

<p>使用反引号的一个结果就是我们只能得到标准的输出（stdout）而不能得到标准的错误信息(stderr),比如下面的例子，我们执行一个输出错误字符串的perl脚本。
```ruby
  $ irb</p>

<blockquote><blockquote><p>warning = <code>perl -e "warn 'dust in the wind'"</code>
  dust in the wind at -e line 1.
  => &ldquo;&rdquo;
puts warning</p></blockquote></blockquote>

<p>  => nil
```
可以看出，warning并没有得到出错的信息，这就表明反引号无法得到标准错误的信息。</p>

<h2>IO#popen</h2>

<p>IO#popen也是一种执行命令的方法,其命令也是在另外的进程中执行。使用popen你可以像操作IO对象一样处理标准输入和输出。
```ruby
$ irb</p>

<blockquote><blockquote><p>IO.popen(&ldquo;date&rdquo;) { |f| puts f.gets }
Mon Mar 12 18:58:56 PDT 2007
=> nil
```</p></blockquote></blockquote>

<h2>Open3#popen3</h2>

<p>在标准的Ruby库中还提供了一个Open3。使用这个类我们可以很容易的对标准输入，输出，错误进行处理。这里我们使用一个可以交互的工具dc。dc是一种逆波兰表达式（又叫做后缀表达式，每一运算符都置于其运算对象之后）的计算器，支持从标准输入读取数学表达式。在这个例子中，我们将两个数值和一个操作符进行压栈处理。然后使用p来输出结果。比如我们输入5和10，然后输入+，然后会得到15\n的输出。
```ruby
  $ irb</p>

<blockquote><blockquote><p>stdin, stdout, stderr = Open3.popen3(&lsquo;dc&rsquo;)
  => [#&lt;IO:0x6e5474>, #&lt;IO:0x6e5438>, #&lt;IO:0x6e53d4>]
stdin.puts(5)
  => nil
stdin.puts(10)
  => nil
stdin.puts(&ldquo;+&rdquo;)
  => nil
stdin.puts(&ldquo;p&rdquo;)
  => nil
stdout.gets
  => &ldquo;15\n&rdquo;
<code>
使用这个方法，我们不仅可以读取到命令的输出还可以对命令进行输入操作。这个方法对于进行交互操作很方便。通过popen3，我们还可以得到标准的错误信息。
</code>ruby
  # (irb continued&hellip;)
stdin.puts(&ldquo;asdfasdfasdfasdf&rdquo;)
  => nil
stderr.gets
  => &ldquo;dc: stack empty\n&rdquo;
<code>
但是，在ruby 1.8.5中popen3有一个缺陷，进程的退出状态没有写入到$?中。
</code>ruby
  $ irb
require &ldquo;open3&rdquo;
  => true
stdin, stdout, stderr = Open3.popen3(&lsquo;false&rsquo;)
  => [#&lt;IO:0x6f39c0>, #&lt;IO:0x6f3984>, #&lt;IO:0x6f3920>]
$?
  => #&lt;Process::Status: pid=26285,exited(0)>
$?.to_i
  => 0
```
为什么是0，false命令执行后的退出状态应该是非0才对，由于这个缺陷，我们需要了解一下Open4</p></blockquote></blockquote>

<h2>Open4#popen4</h2>

<p>Open4#popen4使用起来和Open3#popen3差不多，而且我们也可以得到程序的退出状态。popen4还可以返回一个子进程ID。你也可以通过Process::waitpid2 加上对应的进程ID获得进程退出状态。但是前提是要安装open4的gem。
```ruby
  $ irb</p>

<blockquote><blockquote><p>require &ldquo;open4&rdquo;
  => true
pid, stdin, stdout, stderr = Open4::popen4 &ldquo;false&rdquo;
  => [26327, #&lt;IO:0x6dff24>, #&lt;IO:0x6dfee8>, #&lt;IO:0x6dfe84>]
$?
  => nil
pid
  => 26327
ignored, status = Process::waitpid2 pid
  => [26327, #&lt;Process::Status: pid=26327,exited(1)>]
status.to_i
  => 256
```</p></blockquote></blockquote>

<h2>原文</h2>

<ul>
<li><a href="http://tech.natemurray.com/2007/03/ruby-shell-commands.html">http://tech.natemurray.com/2007/03/ruby-shell-commands.html</a></li>
<li>在原文基础上，进行了部分删减。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[效率脚本：删除已经合并的git分支]]></title>
    <link href="http://droidyue.com/blog/2014/10/24/auto-delete-merged-branches/"/>
    <updated>2014-10-24T22:45:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/10/24/auto-delete-merged-branches</id>
    <content type="html"><![CDATA[<p>使用Git管理代码工程，着实方便了很多，但是当做完feature分支或者完成hotfix之后，总是忘记删除这些无用的分支，一个一个地删除着实麻烦，重复手工劳动不符合程序员的风格，于是写了一个简单的脚本。一键删除那些不需要的分支，让多余的干扰信息离开视线。</p>

<!--more-->


<h2>删除哪些分支？</h2>

<p>删除的为Merge（合并）操作的源分支。如果工程正在处于分支A(HEAD为A分支),分支B已经合并到了分支A，即A分支包含了B分支的内容，则会删除B分支。</p>

<h2>代码</h2>

<p>```ruby</p>

<h1>!/usr/bin/env ruby</h1>

<h1>encoding: utf-8</h1>

<p>exceptBranches = [&lsquo;master&rsquo;, &lsquo;pre&rsquo;, &lsquo;develop&rsquo;]
for branch in <code>cd #{ARGV[0]} &amp;&amp; git branch -l</code>.split(&lsquo; &rsquo;) &ndash; [&lsquo;*&rsquo;]</p>

<pre><code>next if exceptBranches.include? branch
system("git branch -d #{branch}")
</code></pre>

<p>end
```</p>

<h2>使用方法</h2>

<p><code>bash
ruby removeMergedBranches.rb your_git_project
</code></p>

<h2>执行结果</h2>

<p>执行结果类似如下，注意如果没有进行合并，则会提示警告或者错误，这些可以忽略。
```bash
warning: deleting branch &lsquo;custom&rsquo; that has been merged to</p>

<pre><code>     'refs/remotes/origin/custom', but not yet merged to HEAD.
</code></pre>

<p>Deleted branch custom (was b63ab7d).
Deleted branch hotfix (was 340cca0).
Deleted branch mgit (was 86b4004).
error: The branch &lsquo;develop_rtl&rsquo; is not fully merged.
If you are sure you want to delete it, run &lsquo;git branch -D develop_rtl&rsquo;.
```</p>

<h2>链接</h2>

<p><a href="https://github.com/androidyue/weekly-scripts/blob/master/ruby/removeMergedBranches.rb">在Github上的脚本</a></p>

<h3>学习书籍</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B0058FLC40/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0058FLC40&linkCode=as2&tag=droidyue-23">Git权威指南</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B0058FLC40" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B008041DUY/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B008041DUY&linkCode=as2&tag=droidyue-23">七周七语言:理解多种编程范型</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B008041DUY" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby常用文件操作]]></title>
    <link href="http://droidyue.com/blog/2014/08/21/file-code-sinppets-in-ruby/"/>
    <updated>2014-08-21T19:20:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/08/21/file-code-sinppets-in-ruby</id>
    <content type="html"><![CDATA[<p>初学Ruby，很多需要学习，现在开始尝试使用Ruby来写一个脚本，其中用到了很多文件相关的操作，这里阶段地整理一些。便于后续的再次查找。</p>

<!--more-->


<h3>文件或目录是否存在</h3>

<p><code>ruby
File.exist?('file_path')
</code></p>

<h3>是否为文件</h3>

<p><code>ruby
File.file?("file_path")
</code></p>

<h3>是否为目录</h3>

<p><code>ruby
File.directory?("file_path")
</code></p>

<h3>从路径中获取文件名</h3>

<p>```ruby
File.basename(&lsquo;/tmp/adb.log&rsquo;)  #=> &ldquo;adb.log&rdquo;</p>

<h1>从上面结果中移除扩展名</h1>

<p>File.basename(&lsquo;/tmp/adb.log&rsquo;, &lsquo;.log&rsquo;) #=> &ldquo;adb&rdquo;</p>

<h1>或者</h1>

<p>File.basename(&lsquo;/tmp/adb.log&rsquo;, &lsquo;.*&rsquo;)   #=> &ldquo;adb&rdquo;
```</p>

<h3>列出目录下的全部子文件</h3>

<p>```ruby</p>

<h1>替换puts child为自己的操作</h1>

<p>Dir[&lsquo;/tmp/*&rsquo;].each{|child|puts child}
```</p>

<h3>获得父目录</h3>

<p>```ruby</p>

<h1>特定目录的父路径</h1>

<p>File.expand_path(&ldquo;..&rdquo;,specific_path)</p>

<h1>当前目录的父路径</h1>

<p>File.expand_path(&ldquo;..&rdquo;,Dir.pwd)</p>

<h1>或者</h1>

<p>File.expand_path(&ldquo;..&rdquo;)
```</p>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B0061XKRXA/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0061XKRXA&linkCode=as2&tag=droidyue-23">代码大全</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B0061XKRXA" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B005KGBTQ8/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B005KGBTQ8&linkCode=as2&tag=droidyue-23">松本行弘的程序世界</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B005KGBTQ8" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B004WHZGZQ/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004WHZGZQ&linkCode=as2&tag=droidyue-23">黑客与画家:硅谷创业之父Paul Graham文集</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B004WHZGZQ" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby检测Gem是否安装]]></title>
    <link href="http://droidyue.com/blog/2014/08/19/check-for-ruby-gem-availability/"/>
    <updated>2014-08-19T20:04:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/08/19/check-for-ruby-gem-availability</id>
    <content type="html"><![CDATA[<p>最近参加七牛的<a href="https://portal.qiniu.com/contest/demo2014" target="_blank">demo大赛</a>,决定使用ruby开发。于是遇到了一些疑问，然后解决了，这里记录一下。</p>

<p>在Ruby中，Gem是一个很常见的东西，其相当于插件，Ruby有很多很棒的gem，避免了我们重复造轮子，我的demo中需要安装gem，但是为了更加实现好一些，先检测gem是否已经安装，如果没有安装，在继续安装，否则不安装。</p>

<!--more-->


<p>于是，怎么在Ruby中检测gem是否安装呢，其实也很简单，直接上代码就可以了。不需太多解释。begin&hellip;rescue&hellip;相当于java中的try catch。
```ruby lineos:false</p>

<h1>!/usr/bin/env ruby</h1>

<h1>encoding: utf-8</h1>

<p>def checkGemAvailable(gemName, versionLimit=nil)</p>

<pre><code>isAvailable = false
begin
    if versionLimit == nil
        gem  gemName
    else
        gem  gemName, versionLimit
    end
    isAvailable = true
rescue LoadError
end
isAvailable
</code></pre>

<p>end
<code>
跑起来看一看
</code>ruby lineos:false
puts checkGemAvailable(&lsquo;rack&rsquo;)
puts checkGemAvailable(&lsquo;rack&rsquo;, &lsquo;>=2&rsquo;)
<code>
我机器的rack信息
</code>bash lineos:false
rack (1.5.2)
<code>
所以上面执行的结果为
</code>bash lineos:false
true
false
```</p>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B0061XKRXA/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0061XKRXA&linkCode=as2&tag=droidyue-23">代码大全</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B0061XKRXA" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B005KGBTQ8/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B005KGBTQ8&linkCode=as2&tag=droidyue-23">松本行弘的程序世界</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B005KGBTQ8" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B004WHZGZQ/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004WHZGZQ&linkCode=as2&tag=droidyue-23">黑客与画家:硅谷创业之父Paul Graham文集</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B004WHZGZQ" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress中嵌入ruby代码如何不被解析]]></title>
    <link href="http://droidyue.com/blog/2014/08/18/how-to-escape-embeded-ruby-block-in-octopress/"/>
    <updated>2014-08-18T07:48:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/08/18/how-to-escape-embeded-ruby-block-in-octopress</id>
    <content type="html"><![CDATA[<p>用Octopress写博客即将快一年了，感觉自己用的还可以，并且借此熟练使用了Markdown，但是前几天写一篇关于如何在Octopress中集成多说评论的文章的时候，遇到了一个代码高亮的问题，就是如何处理{{}}代码块的问题。</p>

<!--more-->


<h2>问题描述</h2>

<p>默认的{{}}作为嵌入的ruby代码会被解释然后转成其真实的值对应的HTML代码形式。</p>

<h2>举个例子</h2>

<p><code>{{ page.title }}</code>代表当前页面的标题，默认情况下，如果执行了<code>rake generate &amp;&amp; rake preview</code>，这段代码会被解释成了<strong>{{page.title}}</strong></p>

<p>但是我们想要的是原样输出，类似这样在代码块中。
<code>html
{% raw %}{{ page.title }}{% endraw %}
</code></p>

<h2>如何做到</h2>

<p>如果想避免嵌入的ruby代码块被解析，使用&#123;% raw %&#125;和&#123;% endraw %&#125;来包裹不想被解析的代码块即可。示例如下</p>

<p>&#123;% raw %&#125;{% raw %}{{ page.title }}{% endraw %}&#123;% endraw %&#125;
&#123;% raw %&#125;{% raw %}{{ page.url }}{% endraw %}&#123;% endraw %&#125;</p>

<h2>更棘手的</h2>

<p>如果出现了<code>Liquid Exception: Unknown tag 'endraw' in _posts</code>这样的问题，
使用<code>&amp;#123;</code>代替<strong>{</strong>,使用<code>&amp;#125;</code>代替<strong>}</strong></p>

<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B0061XKRXA/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B0061XKRXA&linkCode=as2&tag=droidyue-23">代码大全</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B0061XKRXA" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B005KGBTQ8/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B005KGBTQ8&linkCode=as2&tag=droidyue-23">松本行弘的程序世界</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B005KGBTQ8" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B004WHZGZQ/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B004WHZGZQ&linkCode=as2&tag=droidyue-23">黑客与画家:硅谷创业之父Paul Graham文集</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B004WHZGZQ" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
</feed>
