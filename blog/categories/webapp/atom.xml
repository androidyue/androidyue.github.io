<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: WebApp | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/webapp/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2015-06-27T10:59:09+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android中处理Touch Icon的方案]]></title>
    <link href="http://droidyue.com/blog/2015/01/18/deal-with-touch-icon-in-android/"/>
    <updated>2015-01-18T21:23:00+08:00</updated>
    <id>http://droidyue.com/blog/2015/01/18/deal-with-touch-icon-in-android</id>
    <content type="html"><![CDATA[<p>苹果的Touch Icon相对我们都比较熟悉，是苹果为了支持网络应用（或者说网页）添加到桌面需要的图标，有了这些Touch Icon的网页链接更加和Native应用更相像了。由于苹果设备IPod，IPhone,IPad等设备广泛，很多网页都提供了touch icon这种图标资源。由于Android中并没有及早的有一份这样的标准，当我们想把网页添加到桌面时，仍然需要使用苹果的Touch Icon。</p>

<!--more-->


<h2>Touch Icon</h2>

<p>当我们想让一个网页比较完美地添加到桌面，通常情况下我们需要设置一个png图片文件作为apple-touch-icon。比如
<code>html
&lt;link rel="apple-touch-icon" href="http://droidyue.com/custom_icon.png"&gt;
</code>
如果想支持IPhone和IPad，我们需要使用sizes属性来制定多个图片，默认sizes的值为60 x 60。
<code>html
&lt;link rel="apple-touch-icon" href="touch-icon-iphone.png"&gt;
&lt;link rel="apple-touch-icon" sizes="76x76" href="touch-icon-ipad.png"&gt;
&lt;link rel="apple-touch-icon" sizes="120x120" href="touch-icon-iphone-retina.png"&gt;
&lt;link rel="apple-touch-icon" sizes="152x152" href="touch-icon-ipad-retina.png"&gt;
</code>
在IOS7之前，苹果系统会对添加到桌面的图标进行圆角化等视觉上的处理，为了不让其处理，我们可以使用apple-touch-icon-precomposed来作为rel的值实现。</p>

<p>更多关于Touch Icon的信息，可以访问<a href="https://developer.apple.com/library/mac/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html">水果开发者网站</a>了解更多。</p>

<h2>Android中有缺陷的实现</h2>

<p>在Android WebView提供了处理Touch Icon的回调，<code>onReceivedTouchIconUrl(WebView view, String url,boolean precomposed)</code>该方法返回了对我们有用的touch icon的url，和是否为预组合（在IOS中不需要进行视觉处理）。虽然有这些数据，我们可以进行处理，但是这其中是有问题的，就是我们不好确定文件的大小，来选择适合的图片。</p>

<p>举个例子,如下一个网页的源码，其中sizes的顺序不规律
<code>html
&lt;link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://www.qiyipic.com/20130423143600/fix/H5-72x72.png"&gt;
&lt;link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://www.qiyipic.com/20130423143600/fix/H5-114x114.png"&gt;
&lt;link rel="apple-touch-icon-precomposed" sizes="57x57" href="http://www.qiyipic.com/20130423143600/fix/H5-57x57.png"&gt;
&lt;link rel="apple-touch-icon-precomposed"  href="http://www.qiyipic.com/20130423143600/fix/H5-0x0.png"&gt;
</code>
加载网页，onReceivedTouchIconUrl输出的日志
<code>bash
I/MainActivity( 6995): onReceivedTouchIconUrl url=http://www.qiyipic.com/20130423143600/fix/H5-0x0.png;precomposed=true
I/MainActivity( 6995): onReceivedTouchIconUrl url=http://www.qiyipic.com/20130423143600/fix/H5-57x57.png;precomposed=true
I/MainActivity( 6995): onReceivedTouchIconUrl url=http://www.qiyipic.com/20130423143600/fix/H5-114x114.png;precomposed=true
I/MainActivity( 6995): onReceivedTouchIconUrl url=http://www.qiyipic.com/20130423143600/fix/H5-72x72.png;precomposed=true
</code>
从上面的输出来看，基本上是后面（书写）的元素先打印出来，所以这个回调的缺陷如下</p>

<ul>
<li>由于Touch Icon url地址没有硬性规定，不能根据url包含某些尺寸来判断使用哪个icon</li>
<li>由于网页编写touch icon元素相对随意，不能根据onReceivedTouchIconUrl调用先后来决定使用哪个icon</li>
<li>回调中没有sizes属性值，不好确定使用哪个icon</li>
<li>如果我们选取质量最高的图片，然后进行适当压缩处理或许可以解决问题，但是将全部icon下载下来或者根据Head头信息总感觉不怎么好。</li>
</ul>


<h2>改进方法</h2>

<p>既然WebView没有现成的方法满足我们的需求，只好自己来实现。其实实现方法还是比较简单地就是js脚本注入检测网页元素中得touch icon，返回json数据。</p>

<h3>JavaScript方法</h3>

<p>下面的JS代码所做的功能为查找所有为touch icon的link元素，包含正常的还标记为precomposed。然后将这些link元素的属性存入json数据，最后返回给Java代码中对应的回调。
```javascript
var touchIcons = [];
function gatherTouchIcons(elements) {</p>

<pre><code>var normalTouchIconLength = elements.length;
var currentElement;
for (var i =0; i &lt; normalTouchIconLength;i++) {
    currentElement = elements[i];
    var size;
    if (currentElement.hasAttribute('sizes')) {
        size = currentElement.sizes[0];
    } else {
        size = '';
    }
    var info = {'sizes':size, 'rel': currentElement.rel, 'href': currentElement.href};
    touchIcons.push(info);
}
</code></pre>

<p>}</p>

<p>function obtainTouchIcons() {</p>

<pre><code>normalElements = document.querySelectorAll("link[rel='apple-touch-icon']");
precomposedElements = document.querySelectorAll("link[rel='apple-touch-icon-precomposed']");
gatherTouchIcons(normalElements);
gatherTouchIcons(precomposedElements);
var info = JSON.stringify(touchIcons);
window.app_native.onReceivedTouchIcons(document.URL, info);
</code></pre>

<p>}
obtainTouchIcons();
```</p>

<h3>Java代码</h3>

<p>这里为了便于理解还是全部贴出了demo的源码，demo中当网页加载完成之后注入上面的js代码获取touch icon信息，然后返回给java的回调方法中。如果不清楚Java和JavaScript交互，可以访问<a href="http://droidyue.com/blog/2014/09/20/interaction-between-java-and-javascript-in-android/">Android中Java和JavaScript交互</a>了解更多。
```java
package com.example.obtaintouchicon;</p>

<p>import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;</p>

<p>import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.webkit.JavascriptInterface;
import android.webkit.WebChromeClient;
import android.webkit.WebView;
import android.webkit.WebViewClient;</p>

<p>public class MainActivity extends Activity {</p>

<pre><code>protected String LOGTAG = "MainActivity";

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    WebView webView = new WebView(this);
    webView.getSettings().setJavaScriptEnabled(true);
    webView.setWebViewClient(new WebViewClient() {
        @Override
        public void onPageFinished(WebView view, String url) {
            super.onPageFinished(view, url);
            final String touchIconJsCode = getTouchIconJsCode();
            Log.i(LOGTAG , "onPageFinished url = " + url + ";touchIconJsCode=" + touchIconJsCode);
            view.loadUrl("javascript:" + touchIconJsCode);
        }
    });
    webView.addJavascriptInterface(new JsObject(), "app_native");
    webView.loadUrl("http://192.168.1.5:8000/html/touchicon.html");
}


private class JsObject {

    @JavascriptInterface
    public void onReceivedTouchIcons(String url, String json) {
        Log.i(LOGTAG, "onReceivedTouchIcons url=" + url + ";json=" + json);
    }
}

private String getTouchIconJsCode() {
    StringBuilder total = new StringBuilder();
    InputStream inputStream = null;
    BufferedReader bufferReader = null;
    try {
        inputStream = getAssets().open("touchicon.js");
        bufferReader = new BufferedReader(new InputStreamReader(inputStream));
        String line;
        while ((line = bufferReader.readLine()) != null) {
            total.append(line);
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (null != inputStream) {
            try {
                inputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    return total.toString();
}
</code></pre>

<p>}
```</p>

<h3>返回的JSON数据</h3>

<p>```java
[</p>

<pre><code>{
    "sizes":"72x72",
    "rel":"apple-touch-icon-precomposed",
    "href":"http://www.qiyipic.com/20130423143600/fix/H5-72x72.png"
},
{
    "sizes":"114x114",
    "rel":"apple-touch-icon-precomposed",
    "href":"http://www.qiyipic.com/20130423143600/fix/H5-114x114.png"
},
{
    "sizes":"57x57",
    "rel":"apple-touch-icon-precomposed",
    "href":"http://www.qiyipic.com/20130423143600/fix/H5-57x57.png"
},
{
    "sizes":"",
    "rel":"apple-touch-icon-precomposed",
    "href":"http://www.qiyipic.com/20130423143600/fix/H5-0x0.png"
}
</code></pre>

<p>]
```
我们可以对得到的JSON数据按照需要处理。</p>

<h2>Google会改进么</h2>

<p>答案是会，而且已经改进，但Google修改的不是onReceivedTouchIconUrl这个方法，而是Google正在推行自己的一套规则。</p>

<p>在Chrome上，Google增加了这样一个元素，这是Google提供的为网页程序定义元数据的方法。
<code>html
&lt;link rel="manifest" href="manifest.json"&gt;
</code>
在元数据json中，你可以自定义title，起始页，程序是横屏还是竖屏展示。一个简单地json实例如下，这里我们可以看到其中icons中存在多个类似touch icon的图标，src代表图标路径，sizes代表大小，type就是mimetype，density指的是Android中的屏幕密度（这样更加Android化了）。
```java
{
  &ldquo;name&rdquo;: &ldquo;Web Application Manifest Sample&rdquo;,
  &ldquo;icons&rdquo;: [</p>

<pre><code>{
  "src": "launcher-icon-0-75x.png",
  "sizes": "36x36",
  "type": "image/png",
  "density": "0.75"
},
{
  "src": "launcher-icon-1x.png",
  "sizes": "48x48",
  "type": "image/png",
  "density": "1.0"
},
{
  "src": "launcher-icon-1-5x.png",
  "sizes": "72x72",
  "type": "image/png",
  "density": "1.5"
},
{
  "src": "launcher-icon-2x.png",
  "sizes": "96x96",
  "type": "image/png",
  "density": "2.0"
},
{
  "src": "launcher-icon-3x.png",
  "sizes": "144x144",
  "type": "image/png",
  "density": "3.0"
},
{
  "src": "launcher-icon-4x.png",
  "sizes": "192x192",
  "type": "image/png",
  "density": "4.0"
}
</code></pre>

<p>  ],
  &ldquo;start_url&rdquo;: &ldquo;index.html&rdquo;,
  &ldquo;display&rdquo;: &ldquo;standalone&rdquo;,
  &ldquo;orientation&rdquo;: &ldquo;landscape&rdquo;
}
```
关于Google这套新的标准，可以参考<a href="https://developer.chrome.com/multidevice/android/installtohomescreen">Add to Homescreen</a></p>

<p>但是由于目前，这种标准实施率相对比较低，所以我们还是需要使用苹果的touch icon。</p>

<h2>推荐阅读</h2>

<ul>
<li><a href="https://mathiasbynens.be/notes/touch-icons">Everything you always wanted to know about touch icons</a></li>
</ul>


<h2>源码下载</h2>

<ul>
<li><a href="http://pan.baidu.com/s/1dDD3gZZ">http://pan.baidu.com/s/1dDD3gZZ</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
