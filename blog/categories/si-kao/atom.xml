<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 思考 | 技术小黑屋]]></title>
  <link href="http://droidyue.com/blog/categories/si-kao/atom.xml" rel="self"/>
  <link href="http://droidyue.com/"/>
  <updated>2016-02-29T15:29:11+08:00</updated>
  <id>http://droidyue.com/</id>
  <author>
    <name><![CDATA[androidyue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于获取当前Activity的一些思考]]></title>
    <link href="http://droidyue.com/blog/2016/02/21/thinking-of-getting-the-current-activity-in-android/"/>
    <updated>2016-02-21T20:53:00+08:00</updated>
    <id>http://droidyue.com/blog/2016/02/21/thinking-of-getting-the-current-activity-in-android</id>
    <content type="html"><![CDATA[<p>在Android开发过程中，我们有时候需要获取当前的Activity实例，比如弹出Dialog操作，必须要用到这个。关于如何实现由很多种思路，这其中有的简单，有的复杂，这里简单总结一下个人的一些经验吧。</p>

<!--more-->


<h2>反射</h2>

<p>反射是我们经常会想到的方法，思路大概为</p>

<p>  1 获取ActivityThread中所有的ActivityRecord <br/>
  2 从ActivityRecord中获取状态不是<code>pause</code>的Activity并返回</p>

<p>一个使用反射来实现的代码大致如下
```java</p>

<pre><code>public static Activity getActivity() {
    Class activityThreadClass = null;
    try {
        activityThreadClass = Class.forName("android.app.ActivityThread");
        Object activityThread = activityThreadClass.getMethod("currentActivityThread").invoke(null);
        Field activitiesField = activityThreadClass.getDeclaredField("mActivities");
        activitiesField.setAccessible(true);
        Map activities = (Map) activitiesField.get(activityThread);
        for (Object activityRecord : activities.values()) {
            Class activityRecordClass = activityRecord.getClass();
            Field pausedField = activityRecordClass.getDeclaredField("paused");
            pausedField.setAccessible(true);
            if (!pausedField.getBoolean(activityRecord)) {
                Field activityField = activityRecordClass.getDeclaredField("activity");
                activityField.setAccessible(true);
                Activity activity = (Activity) activityField.get(activityRecord);
                return activity;
            }
        }
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } catch (NoSuchMethodException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (InvocationTargetException e) {
        e.printStackTrace();
    } catch (NoSuchFieldException e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>

<p>```</p>

<p>然而这种方法并不是很推荐，主要是有以下的不足：</p>

<ul>
<li>反射通常会比较慢</li>
<li>不稳定性，这个才是不推荐的原因，Android框架代码存在修改的可能性，谁要无法100%保证<code>mActivities</code>，<code>paused</code>固定不变。所以可靠性不是完全可靠。</li>
</ul>


<h2>Activity基类</h2>

<p>既然反射不是很可靠，那么有一种比较可靠的方式，就是使用Activity基类。</p>

<p>在Activity的<code>onResume</code>方法中，将当前的Activity实例保存到一个变量中。
```java
public class BaseActivity extends Activity{</p>

<pre><code>@Override
protected void onResume() {
    super.onResume();
    MyActivityManager.getInstance().setCurrentActivity(this);
}
</code></pre>

<p>}
```</p>

<p>然而，这一种方法也不仅完美，因为这种方法是基于约定的，所以必须每个Activity都继承BaseActivity，如果一旦出现没有继承BaseActivity的就可能有问题。</p>

<h2>回调方法</h2>

<p>介绍了上面两种不是尽善尽美的方法，这里实际上还是有一种更便捷的方法，那就是通过Framework提供的回调来实现。</p>

<p>Android自 API 14开始引入了一个方法，即Application的<code>registerActivityLifecycleCallbacks</code>方法，用来监听所有Activity的生命周期回调，比如<code>onActivityCreated</code>,<code>onActivityResumed</code>等。</p>

<p>So，一个简单的实现如下
```java
public class MyApplication extends Application {</p>

<pre><code>@Override
public void onCreate() {
    super.onCreate();
    registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {
        @Override
        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {

        }

        @Override
        public void onActivityStarted(Activity activity) {

        }

        @Override
        public void onActivityResumed(Activity activity) {
            MyActivityManager.getInstance().setCurrentActivity(activity);
        }

        @Override
        public void onActivityPaused(Activity activity) {

        }

        @Override
        public void onActivityStopped(Activity activity) {

        }

        @Override
        public void onActivitySaveInstanceState(Activity activity, Bundle outState) {

        }

        @Override
        public void onActivityDestroyed(Activity activity) {

        }
    });
}
</code></pre>

<p>}
```</p>

<p>然而，金无足赤人无完人，这种方法唯一的遗憾就是只支持API 14即其以上。不过还在现在大多数设备都满足了这个要求。</p>

<h3>为什么是弱引用</h3>

<p>可能有人会带着疑问看到这里，MyActivityManager是个什么鬼，好，我们现在看一下这个类的实现
```java
public class MyActivityManager {</p>

<pre><code>private static MyActivityManager sInstance = new MyActivityManager();
private WeakReference&lt;Activity&gt; sCurrentActivityWeakRef;


private MyActivityManager() {

}

public static MyActivityManager getInstance() {
    return sInstance;
}

public Activity getCurrentActivity() {
    Activity currentActivity = null;
    if (sCurrentActivityWeakRef != null) {
        currentActivity = sCurrentActivityWeakRef.get();
    }
    return currentActivity;
}

public void setCurrentActivity(Activity activity) {
    sCurrentActivityWeakRef = new WeakReference&lt;Activity&gt;(activity);
}
</code></pre>

<p>}
```</p>

<p>这个类，实现了当前Activity的设置和获取。</p>

<p>那么为什么要使用弱引用持有Activity实例呢？</p>

<p>其实最主要的目的就是避免内存泄露，因为使用默认的强引用会导致Activity实例无法释放，导致内存泄露的出现。详细了解弱引用，请参考本文<a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">译文：理解Java中的弱引用</a></p>

<h2>Demo源码</h2>

<ul>
<li><a href="https://github.com/androidyue/GetCurrentActivityDemo">GetCurrentActivityDemo</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[龟兔赛跑中为什么要用兔子]]></title>
    <link href="http://droidyue.com/blog/2014/08/30/story-thinking-guituisaipao/"/>
    <updated>2014-08-30T10:09:00+08:00</updated>
    <id>http://droidyue.com/blog/2014/08/30/story-thinking-guituisaipao</id>
    <content type="html"><![CDATA[<p>龟兔赛跑的童话故事，想必是家喻户晓，前几天很好奇，为什么要故事要使用兔子，为什么不使用狗狼或者人类作为角色呢？</p>

<p>下面不妨替我慢慢讲解</p>

<p>龟兔赛跑这篇故事摘自古希腊的文学著作《伊索寓言》，《伊索寓言》的一系列故事，大都篇辐短小，却能阐述大道理，深具哲理。</p>

<!--more-->


<p>《伊索寓言》里面的角色大多是拟人化的动物，它们用人的方式来表现行为举
止，作者借以形象化地说出某种思想、道德观或生活经验，使读者从中得到教育。</p>

<p>《伊索寓言》中，有关狮子、豺狼、毒蛇、鳄鱼和狐狸象征著统治者，他们残暴专横，对人民姿意巧取横夺。是不是有点像古代诗人写诗的时候常用到的借古讽今的手法啊。</p>

<p>上面可以说明为什么不使用人类的了。那么为什么又要兔子呢？其实兔子本身有着某种象征。</p>

<p>野兔在体育界的某些项目中被认为是速度的象征，一些以速度见长的运动员被冠以野兔的花名，如澳洲著名网球运动员休伊特</p>

<p>相信看到上面就明白了为什么用兔子了吧。所以兔子作为赛跑先天优势者和先天劣势者乌龟赛跑是可以被理解的。</p>

<p>最重要的应该是我们从这篇故事中学到的启发和思考。</p>

<p>这个故事的教训有两面：</p>

<ul>
<li>先天优势者：要虚心学习，谦虚做人，不要轻敌，因为骄兵必败，只有时刻都保持谦卑之心，才能保持头脑清醒，从而使做事更为成功。</li>
<li>先天弱势者：勿自暴自弃，保持自信，只有坚持目标，努力不懈，最后才可能成功。</li>
</ul>


<p>如果你有更好的解释，请告诉我哈。</p>

<h3>参考链接</h3>

<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E9%BE%9C%E5%85%94%E8%B3%BD%E8%B7%91" target="_blank">龟兔赛跑@维基百科</a></li>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%85%94" target="_blank">兔子@维基百科</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E4%BC%8A%E7%B4%A2%E5%AF%93%E8%A8%80" target="_blank">伊索寓言@维基百科</a></li>
</ul>


<h3>其他</h3>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B00AH8Z384/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00AH8Z384&linkCode=as2&tag=droidyue-23">如何提问最好</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00AH8Z384" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B003SRH9M4/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B003SRH9M4&linkCode=as2&tag=droidyue-23">经典译林:伊索寓言全集</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B003SRH9M4" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.cn/gp/product/B00AR8JWA4/ref=as_li_tf_tl?ie=UTF8&camp=536&creative=3200&creativeASIN=B00AR8JWA4&linkCode=as2&tag=droidyue-23">清醒思考的艺术:你最好让别人去犯的52种思维错误</a><img src="http://ir-cn.amazon-adsystem.com/e/ir?t=droidyue-23&l=as2&o=28&a=B00AR8JWA4" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
</feed>
